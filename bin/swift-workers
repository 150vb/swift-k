#!/bin/bash 

export SWIFT_BIN="$( cd "$( dirname "$0" )" && pwd )"
export SERVICE_DIR="$HOME/.swift/service"

# Report a problem and exit
crash()
{
   MSG=$1
   echo ${MSG} >&2
   exit 1
}

# Print usage
usage()
{
   crash "$( basename $0 ) [ -start | -stop ] [ -service servicename ]"
}

# Return current timestamp
get_timestamp()
{
   date +"%b %d %H:%M:%S "
}

# Write command to log, run command, wait for completion
run_command()
{
   command="$@"
   echo "$( get_timestamp ) Running command $command" >> $LOG
   $command 2>&1 | tee -a $LOG
}

# Write command to log, run in background, return PID
run_command_bg()
{
   command="$@"
   echo "$( get_timestamp ) Running background command $command" >> $LOG
   $command >> $LOG 2>&1 &
   echo $!
}

verify_files_exist()
{
   for file in "$@"
   do
      if [ ! -f "$file" ]; then
         crash "File $file does not exist. Service is in a corrupt state, please stop and restart"
      fi
   done
}

# Kill all children processes
nicely_kill_all_children()
{
   PID=$1
   ps -u $USER -o "pid,ppid"|sed 1d | while read PROC
   do  
      PROC_PID=$( echo $PROC | awk '{print $1}' )
      PROC_PPID=$( echo $PROC | awk '{print $2}' )
      if [ $PROC_PPID == $PID ]; then
         nice_kill $PROC_PID 5
      fi  
   done
   nice_kill $PID 5
}

# Try to nicely kill a process before giving it a SIGKILL
nice_kill()
{
   pid=$1
   grace=$2
   run_command kill $pid &>/dev/null

   count=0
   while ps -p $pid &>/dev/null
   do  
      sleep 1
      (( count++ ))
      if [ "$count" -ge "$grace" ]; then
         run_command kill -9 $pid
      fi  
   done  
}

# Start SSH workers
start-workers-ssh()
{
   for MACHINE in $WORKER_HOSTS
   do
      # Enable ssh tunneling if needed
      if [ "$SSH_TUNNELING" != "no" ]; then
         run_command_bg ssh -N -T -R *:$LOCAL_PORT:localhost:$LOCAL_PORT "$WORKER_USERNAME@$MACHINE"
      fi

      # Connect directly
      run_command ssh $WORKER_USERNAME@$MACHINE mkdir -p $WORKER_LOCATION
      run_command scp $WORKER $WORKER_USERNAME@$MACHINE:$WORKER_LOCATION
      echo Starting worker on $MACHINE
      run_command_bg ssh $WORKER_USERNAME@$MACHINE "WORKER_LOGGING_LEVEL=$WORKER_LOGGING_LEVEL $WORKER_LOCATION/worker.pl $WORKERURL $MACHINE $WORKER_LOG_DIR"
   done
   return 0
}

# Start local workers
start-workers-local()
{
   for service in $SERVICE
   do
      echo Connecting local workers to service $service
      service="$SERVICE_DIR/$service"
      verify_files_exist $service/worker.path $service/worker.url
      LOG=$service/workers.log
      WORKER=$( cat $service/worker.path )
      WORKERURL=$( cat $service/worker.url )
      WORKERPID=$( run_command_bg $WORKER $WORKERURL $WORKER_LOG $WORKER_LOG_DIR )
      echo $WORKERPID >> $service/worker.pid
   done
}

# Start condor workers
start-workers-scheduler()
{
   echo Starting workers
   run_command $SCHEDULER_COMMAND
}

# Print a list of services
get_services()
{
   find $SERVICE_DIR -mindepth 1 -maxdepth 1 -type d 2>/dev/null | sort -n
}

# Stop worker processes
stop_workers()
{
   if [ ! -d "$SERVICE_DIR/$SERVICE" ]; then
      crash "Service $SERVICE does not work"
   fi
   echo Stopping service $SERVICE
   verify_files_exist "$SERVICE_DIR/$SERVICE/worker.pid"
   nicely_kill_all_children $( cat $SERVICE_DIR/$SERVICE/worker.pid )
   rm $SERVICE_DIR/$SERVICE/worker.pid
}

# Parse command line arguments
START=0;STOP=0
while [ $# -gt 0 ]; do
   case $1 in
      -conf) CMDLN_CONF=$2; shift 2;;
      -start) START=1; shift;;
      -stop) STOP=1; shift;;
      -service) SERVICE=$2; shift 2;;
      *) echo "Do not recognize command line option: $1" 1>&2; exit 1;;
   esac
done

if [ -z "$SERVICE" ] || [ $(($START+$STOP)) != 1 ]; then
   usage
fi

# Defaults for worker logging
WORKER_LOG="worker.log"
WORKER_LOG_DIR="NOLOGGING"
WORKER_LOGGING_LEVEL="OFF"

# Import settings
if [ -f "$CMDLN_CONF" ]; then
   CONFIG_FILE=$CMDLN_CONF
elif [ -f "coaster-service.conf" ]; then
   CONFIG_FILE="coaster-service.conf"
fi

if [ -f "$CONFIG_FILE" ]; then
   echo "Configuration: $CONFIG_FILE"
   source $CONFIG_FILE
fi

if [ "$START" -eq 1 ]; then
   case $WORKER_MODE in
      ssh) start-workers-ssh;;
      local) start-workers-local;;
      scheduler) start-workers-scheduler;;
      *) crash "Unknown WORKER_MODE";;
  esac
elif [ "$STOP" -eq 1 ]; then
   stop_workers
fi
