#!/usr/bin/perl -w

use strict;
use warnings;
use File::Basename;

# Print basic usage info
sub usage() {
   &crash("Usage: $0 <logdir>");
}

# Print error message and exit
sub crash() {
   print STDERR "@_\n";
   exit(1);
}

# Check usage
if ( !$ARGV[0] ) {
   &usage();
}

# Given a Swift log entry, decide if we want to it or not
sub processLogEntry() {
   (my $date, my $time, my $loglevel, my $class, my $message) = split(/\s+/, $_[0], 5);
   $time = (split(',', $time))[0];
   my @keywords_to_keep= ("VERSION", "ARGUMENTS", "SWIFT_CONFIGURATION", "SITES:", "TC:",
                          "file:", "Using tc.data:");
   foreach my $keyword(@keywords_to_keep) {
      if( $message =~ m/$keyword/ ) {
      # if( grep /$keyword/, @messageArray ) {
         print "$time $message";
         last;
      }
   }
}

# Return true if input string starts with a date stamp
sub hasDateStamp() {
   my $input = $_[0];
   if ( $input =~ m/^\d{4}-\d{2}-\d{2}/ ) { 
      return 1;
   } 
   return 0;
}

# Verify $run_directory
my $run_directory = $ARGV[0];
if ( ! -d "$run_directory" ) {
   &crash("Directory $run_directory does not exist!");
}

# Open Swift log
my $swift_log_name = "$run_directory/" . basename($run_directory) . ".log";
open(SWIFTLOG, $swift_log_name) || &crash("Unable to open log file $swift_log_name");

# Parse Swift log
my @multiline_entry = ();
my $previous_line = "";

# Parse each log entry, figure out if they're multiline entries or not
while(my $line = <SWIFTLOG>) {
   if ( &hasDateStamp($line) ) {
      if ( &hasDateStamp($previous_line) ) {
         &processLogEntry($previous_line);
      }
      $previous_line = $line;
   } else {
      $previous_line .= "$line";
   }
}
