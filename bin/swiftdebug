#!/usr/bin/perl -w

use strict;
use warnings;
use File::Basename;
use Class::Struct;

# Task structure
struct Task          => { 
    app              => '$',
    arguments        => '$',
    host             => '$',
    replicationGroup => '$',
    stageIn          => '$',
    stageOut         => '$',
    startTime        => '$',
    stopTime         => '$',
    taskNumber       => '$',
    thread           => '$',
    workdir          => '$',
};

# Hash for storing all tasks
my %tasks = ();
my $taskCounter = 1;

# Print basic usage info
sub usage() {
   &crash("Usage: $0 <logdir>");
}

# Print error message and exit
sub crash() {
   print STDERR "@_\n";
   exit(1);
}

# Logic for what to do with a log entry
sub processLogEntry() {
   (my $date, my $time, my $loglevel, my $class, my $message) = split(/\s+/, $_[0], 5);
   $time = (split(',', $time))[0];
   $message = "$time $message";

   # my @keywords_to_keep= ("VERSION", "ARGUMENTS", "SWIFT_CONFIGURATION", "SITES:", "TC:", "SWIFTSCRIPT:" );
   my @keywords_to_keep=("xyzzy");
   my $keyword_regexp = join('|', @keywords_to_keep);

   if ( $message =~ m/THREAD_ASSOCIATION/ ) {
      &taskCreated($message);
      return;
   }

   elsif ( $message =~ m/JOB_START/ ) {
      &taskStarted($message);
      return;
   }

   elsif ( $message =~ m/JOB_END/ ) {
      &taskEnded($message);
      return;
   }

   elsif ( $message =~ /Staging in files/ ) {
      &taskStagingIn($message);
      return;
   }

   elsif ( $message =~ /FILE_STAGE_OUT_START/ ) {
      &taskStagingOut($message);
      return;
   }

   elsif ( $message =~ m/$keyword_regexp/ ) {
      print "$message";
      return;
   }
}

# Gather information about a task
sub taskCreated() {
   # Input: THREAD_ASSOCIATION jobid=sleep-n5t2pajl thread=R-4 host=westmere replicationGroup=null
   $_[0] =~ s/jobid=|thread=|host=|replicationGroup=//g;
   my ( $date, $ignore, $taskid, $thread, $host, $replicationGroup ) = split(/\s+/, $_[0]);
   
   my $t = Task->new();
   $t->taskNumber($taskCounter);
   $t->thread($thread);
   $t->host($host);
   $t->replicationGroup($replicationGroup);

   $tasks{$taskid} = $t; 
   $taskCounter += 1;
}

# Record that a task has started
sub taskStarted() {
   # Input: JOB_START jobid=sleep-k5t2pajl tr=sleep arguments=[1] tmpdir=sleep-run002/jobs/k/sleep-k5t2pajl host=westmere
   $_[0] =~ s/jobid=|tr=|arguments=|tmpdir=|hostdir=//g;
   my ( $date, $ignore, $taskid, $app, $remainder ) = split(/\s+/, $_[0], 5);
   my $arguments = &getBracketedText($remainder);
   my $workdir = (split(/\s+/, $_[0]))[-2];
   my $t = $tasks{$taskid};
   $t->app($app);
   $t->workdir($workdir);
   $t->arguments($arguments);
   $t->startTime($date);
}   

sub taskEnded() {
   # Input: JOB_END jobid=sleep-k5t2pajl
   $_[0] =~ s/jobid=//g;
   my ( $date, $ignore, $taskid ) = split(/\s+/, $_[0]);
   my $t = $tasks{$taskid};
   $t->stopTime($date);
}

sub taskStagingIn() {
   # Input: jobid=cat-nff3bpjl - Staging in files [file://localhost/data.txt, file://localhost/data2.txt]
   $_[0] =~ s/jobid=//g;
   my ( $date, $start, $taskid, $leftover ) = split(/\s+/, $_[0], 4);
   my $files = getBracketedText($leftover);
   my $t = $tasks{$taskid};
   $t->stageIn($files);
}

sub taskStagingOut() {
   # Input: FILE_STAGE_OUT_START srcname=catsn.0001.out srcdir=catsn-run015/shared/output srchost=westmere destdir=output desthost=localhost provider=file jobid=cat-xpyldpjl
   $_[0] =~ s/srcname=|srcdir=|srchost=|destdir=|desthost=|provider=|jobid=//g;
   my ( $date, $junk, $srcname, $srcdir, $srchost, $destdir, $desthost, $provider, $taskid ) = split(/\s+/, $_[0]);
   my $t = $tasks{$taskid};
   if(defined($t->stageOut())) {
      $t->stageOut($t->stageOut() . "$srcname ");
   } else {
      $t->stageOut("$srcname");
   }
}

sub getBracketedText() {
   $_[0] =~ /\[([^\]]*)\]/x;
   my $result = $1;
   $result =~ s/,//g;
   return $result;
}

sub printTasks() {
   foreach my $key (sort { $tasks{$a}->taskNumber <=> $tasks{$b}->taskNumber } keys %tasks) {
      my $value = $tasks{$key}; 
      printf "Task %s\n" .
             "\tApp name = %s\n" . 
             "\tCommand line arguments = %s\n" .
             "\tHost = %s\n" .
             "\tStart time = %s\n" .
             "\tStop time = %s\n" .
             "\tWork directory = %s\n" .
             "\tStaged in files = %s\n" .
             "\tStaged out files = %s\n",
             $value->taskNumber, 
             $value->app, 
             $value->arguments,
             $value->host, 
             $value->startTime,
             $value->stopTime,
             $value->workdir,
             $value->stageIn,
             $value->stageOut,
   }
}

# Return true if input string starts with a date stamp
sub hasDateStamp() {
   my $input = $_[0];
   if ( $input =~ m/^\d{4}-\d{2}-\d{2}/ ) { 
      return 1;
   } 
   return 0;
}

# Check usage
if ( !$ARGV[0] ) {
   &usage();
}

# Verify $run_directory
my $run_directory = $ARGV[0];
if ( ! -d "$run_directory" ) {
   &crash("Directory $run_directory does not exist!");
}

# Open Swift log
my $swift_log_name = "$run_directory/" . basename($run_directory) . ".log";
open(SWIFTLOG, $swift_log_name) || &crash("Unable to open log file $swift_log_name");

# Parse Swift log
my @multiline_entry = ();
my $previous_line = "";

# Read log, and send each entry (single or multi-line) to processLogEntry()
while(my $line = <SWIFTLOG>) {
   if ( &hasDateStamp($line) ) {
      if ( &hasDateStamp($previous_line) ) {
         &processLogEntry($previous_line);
      }
      $previous_line = $line;
   } else {
      $previous_line .= "$line";
   }
}

# Print tasks
&printTasks();
