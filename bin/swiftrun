#!/usr/bin/perl -w

use strict;
use warnings;
use FindBin qw($Bin);
use lib "$FindBin::Bin/../lib/perl";
use File::Basename;
use File::Path;
use Getopt::Long qw(GetOptionsFromArray);
use Cwd;

Getopt::Long::Configure("pass_through");

my %properties = ();		# Hash storing all swift properties
my @property_files = ();	# List of swift property files to be read
my $option_tcfile;		# Value of -tc.file option
my $option_sitesfile;		# Value of -sites.file option
my $option_siteslist;		# Value of -sites option, comma separated
my $option_config;		# Value of -config option
my $option_listconfig; 		# List configuration files used, values, then exit
my $option_properties;          # Use a swift.properties specified in the command line
my $option_help;                # Print help
my $option_version;             # Print version number
my @sites;			# List of sites from -sites in array
my $run_directory;		# Run directory to be created, run.NNNN
my @new_swift_args;		# New command line arguments
my @original_swift_args;	# Original arguments

# List of xml shortcuts
my %xml_aliases = (
                   'allocationstepsize'        => 'globus.allocationstepsize',
                   'delaybase'                 => 'karajan.delaybase',
                   'highoverallocation'        => 'globus.highoverallocation',
                   'initialscore'              => 'karajan.initialscore',
                   'internalhostname'          => 'globus.internalhostname',
                   'jobgranularity'            => 'globus.nodegranularity',
		   'jobproject'                => 'globus.project',
                   'jobqueue'                  => 'globus.queue',
                   'jobspernode'               => 'globus.jobspernode',
                   'jobthrottle'               => 'karajan.jobthrottle',
                   'jobtype'                   => 'globus.jobtype',
		   'jobwalltime'               => 'globus.maxtime',
                   'jobwalltimereserve'        => 'globus.reserve',
                   'lowoverallocation'         => 'globus.lowoverallocation',
		   'maxjobs'                   => 'globus.slots',
                   'maxnodes'                  => 'globus.maxnodes',
                   'maxnodesperjob'            => 'globus.maxnodes',
                   'maxsubmitrate'             => 'karajan.maxsubmitrate',
                   'maxtime'                   => 'globus.maxtime',
                   'maxwalltime'               => 'globus.maxwalltime',
                   'nodegranularity'           => 'globus.nodegranularity',
                   'overallocationdecayfactor' => 'globus.overallocationdecayfactor',
                   'project'                   => 'globus.project',
                   'provider'                  => 'provider.coaster',
                   'queue'                     => 'globus.queue',
                   'remotemonitorenabled'      => 'globus.remotemonitorenabled',
                   'reserve'                   => 'globus.reserve',
                   'slots'                     => 'globus.slots',
                   'spread'                    => 'globus.spread',
                   'tasksperworker'            => 'globus.jobspernode',
                   'taskthrottle'              => 'karajan.jobthrottle',
                   'taskwalltime'              => 'globus.maxwalltime',
		   'workerlogginglevel'        => 'globus.workerlogginglevel',
		   'workerloglevel'            => 'globus.workerlogginglevel',
                   'workerloggingdirectory'    => 'globus.workerloggingdirectory',
                   'workerlogdirectory'        => 'globus.workerloggingdirectory',
);

# Verify a property file exists and add it to the search path
sub add_property_file {
   my $property_file = $_[0];
   if( -e "$property_file" ) {
      push( @property_files, $property_file );
   }
}

# Create a string with a single pool entry
sub create_pool_entry {
   my $site = $_[0];
   my $pool = "\n<pool handle=\"" . $site . "\">\n";
   while( my( $key, $value ) = each( %properties ) ) {
      if( $key =~ /^\s*site.$site/ ) {
         $pool .= &property_to_xml( $key, $value );
      }
   }
   $pool .= "</pool>\n";
   return $pool;
}

sub verify_in_hhmmss {
   my $parameter_name =  $_[0];
   my $parameter_value = $_[1];
   my $ccount = ($parameter_value =~ s/:/:/g);
   if ($ccount != 2) {
      swiftquit("Error: $parameter_name value $parameter_value is not in hh:mm:ss format");
   }
}

# Convert hh:mm:ss to seconds
sub hhmmss_to_seconds {
   (my $hh, my $mm, my $ss) = split(':', $_[0]);
   return ($hh*60*60)+($mm*60)+$ss;
}

# Convert to job throttle format
sub number_to_throttle {
   my $input = $_[0];
   if ( $input !~ /\d/) {  
      swiftquit("Error: taskthrottle must be numeric");
   }
   return ($input - 1) / 100;
}  
 
# Given a string in format site.beagle.globus.jobsPerNode=12, convert to xml
sub property_to_xml {
   my $key = $_[0];
   my $value = $_[1];
   my ( $site, $sitename, $namespace, $property ) = split(/\./, $key);

   # Allow exceptions for swift properties with dot separators (ie key=slurm.properties)
   if ( defined($property) && $namespace =~ m/^slurm|^condor/ ) { 
      ( $site, $sitename, $namespace, $property ) = split(/\./, $key);
      $property = "$namespace.$property";
      $namespace = "globus";
   }

   # In the case of a shortened definition, check for aliases 
   if ( !defined( $property ) ) {
      if ( defined( $xml_aliases{ lc( $namespace )})) { 
         $namespace=lc($namespace);

         # Values that need that may need modifications
         if( $namespace eq "jobwalltime" ) {
            verify_in_hhmmss($namespace, $value);
            $value = hhmmss_to_seconds($value); 
         } 
         elsif ( $namespace eq "taskthrottle" ) {
            $value = number_to_throttle($value);
         }
         elsif ( $namespace eq "taskwalltime" ) {
            verify_in_hhmmss($namespace, $value);
         }

         ( $namespace, $property ) = split(/\./, $xml_aliases{ $namespace });
      }
   }     
   
   # Make sure to handle special cases that are not in the namespace=x, key=y, format
   if ( $namespace eq "jobmanager" && defined($value)) { 
      my $ccount = ($value =~ s/:/:/g);
      my $jobmanager = "";
      my $jobmanagerURL = "";

      # With no separators, assume local 
      if( $ccount == 0 ) {
         $jobmanager = "local:$value";
      }

      # With one separator, use ssh-cl and assume hostname:type
      elsif ( $ccount == 1) {
         (my $first, my $second) = split(':', $value);
         $jobmanager = "ssh-cl:$second";
         $jobmanagerURL = "$first";
      }
 
      # Other, in the format of proto:host:jobMgr
      elsif ( $ccount == 2) {
         (my $first, my $second, my $third) = split(':', $value);
         $jobmanager="$first:$third";
         $jobmanagerURL = "$second";
      }
 
      if ( defined($jobmanagerURL) && length($jobmanagerURL) > 0) {
         return "<execution provider=\"coaster\" jobmanager=\"" . $jobmanager . "\" url=\"" . $jobmanagerURL . "\"/>\n";
      } else {
         return "<execution provider=\"coaster\" jobmanager=\"" . $jobmanager . "\"/>\n"; 
      }
   }
     
   elsif ( $namespace eq "workdirectory" ) { return "<workdirectory>$value</workdirectory>\n"; }
   elsif ( $namespace eq "workdir" )       { return "<workdirectory>$value</workdirectory>\n"; }
   elsif ( $namespace eq "taskdir" )       { return "<scratch>$value</scratch>\n"; }
   elsif ( $namespace eq "filesystem" )    { return "<filesystem provider=\"" . $value . "\"/>\n"; }

   if ( defined($property) && defined($value) ) {
      return "<profile namespace=\"" . $namespace . "\" key=\"" . $property . "\">" . $value . "</profile>\n"; 
   }
} 

# Write apps to file in tc.data format
sub write_apps {
   my $app_filename = $_[0];
   my $use_wildcard = 1;
   open( APP_FILE, ">$run_directory/$app_filename" ) || &swiftquit("Unable to open $run_directory/$app_filename");

   # Find app definitions
   while( my( $key, $value ) = each( %properties ) ) {
      if( $key =~ /^\s*app./ ) {
         my ( $app, $site, $command ) = split(/\./, $key);

         # Handle wildcards for site names
         if ( $site eq "*" ) { 
            $use_wildcard=0;
            foreach my $nsite( @sites ) {
               print APP_FILE "$nsite $command $value\n";
            }
         } 

         # Handle apps for defined sites
         elsif ( grep( /^$site$/, @sites ) ) {
            $use_wildcard=0;
            print APP_FILE "$site $command $value\n";
         }
      }
   }

   if ($use_wildcard) {
      print APP_FILE "* * * INSTALLED INTEL32::LINUX null\n";
   }

   close(APP_FILE);
   push( @new_swift_args, "-tc.file $run_directory/$app_filename" );
}

# Write properties to file
sub write_properties {
   my $property_filename = $_[0];
   open( PROPERTY_FILE, ">$run_directory/$property_filename" ) || &swiftquit("Unable to open $run_directory/$property_filename");
   while( my( $key, $value ) = each( %properties ) ) {
      # Ignore properties that start with app. or site.
      next if $key =~ /^\s*app./;
      next if $key =~ /^\s*site/;
      print PROPERTY_FILE "$key=$value\n";
   }
   push( @new_swift_args, "-config $run_directory/$property_filename" );
}

# Check if a site is defined
sub site_is_defined {
   my $site = $_[0];
   my $isDefined=0;
   while( my( $key, $value ) = each( %properties ) ) {
     if( $key =~ m/^site\.$site/i ) {
        $isDefined=1;
      }
   }
   return $isDefined;
}

# Check if a service is defined
sub service_is_defined {
   my $site = $_[0];
   my $isDefined=0;
   while( my( $key, $value ) = each( %properties ) ) {
      if( $key =~ m/^service\.$site/i ) {
         $isDefined=1;
      }
   }
   return $isDefined;
}

# Verify a service is running
sub service_is_running {
   my $site = $_[0];
   my $service_is_running = 0;
   my $service_directory = "$ENV{HOME}/.swift/service/$site";
   if( -d "$service_directory" ) {
      if ( -f "$service_directory/pid" ) {
         my $pid = `cat $service_directory/pid`;
         $service_is_running = kill 0, $pid;
      }
   }
   return $service_is_running;
}

# Retrieve a service sites.xml
sub retrieve_service_xml {
   my $site = $_[0];
   my $sitexmlfile = "$ENV{HOME}/.swift/service/$site/sites.xml";
   my @xml;
   open(SXML, $sitexmlfile) || &swiftquit("Unable to open $sitexmlfile: $!\n");
   while(<SXML>) {
      if(m/^<\?xml|^<config|config>$/i){ next; }
         push(@xml, $_);
   }
   close(SXML);
   return @xml;
}

sub swiftquit {
   print STDERR $_[0] . "\n";
   print " --SWIFTRUNQUIT ";
   if (defined($run_directory) && -d "$run_directory") { 
      rmtree $run_directory || die "Failed to remove $run_directory: $!\n";
   }
   exit 1;
} 

# Write sites.xml to disk
sub write_sites {
   my $filename = $_[0];
   open(SITES, ">$run_directory/$filename") || &swiftquit("Unable to open $run_directory/$filename");
   print SITES "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
   print SITES "<config xmlns=\"http://www.ci.uchicago.edu/swift/SwiftSites\">\n";

   if(defined ($properties{site}) && !defined($option_siteslist) ) { 
      push(@sites, split(',', $properties{site}))
   } 

   foreach my $site(@sites) {
      # XML from site definition
      if ( &site_is_defined($site) ) {
         print SITES &create_pool_entry($site);
      }

      # XML from service definition 
      elsif ( &service_is_defined($site)) {
         if( ! &service_is_running($site) ) {
            &swiftquit("Service process for $site is not running");
         }
         print SITES &retrieve_service_xml($site);
      }

      # Can't find definition
      else {
         &swiftquit("Site $site is not defined");
      }
   }

   print SITES "\n</config>\n";
   close(SITES);
   push(@new_swift_args, "-sites.file $run_directory/$filename");
}

# Getopt::Long can't accept dots in arguments, work around to make things easy
foreach my $arg(@ARGV) {
   $arg =~ s/sites.file/sitesfile/g;
   $arg =~ s/tc.file/tcfile/g;
}

# Command line arguments we care about
@original_swift_args = @ARGV;
GetOptionsFromArray(
           \@original_swift_args, 
           'config=s'              => \$option_config,
           'help'                  => \$option_help,
           'listconfig'      	   => \$option_listconfig,
           'property|properties=s' => \$option_properties,
           'site|sites=s'          => \$option_siteslist,
           'sitesfile=s'           => \$option_sitesfile,
           'tcfile=s'              => \$option_tcfile,
           'version'               => \$option_version,
);

# Create/increment run directory
my $run_number = 0;
my @run_directories = <run???>;

if(@run_directories) {
   $run_number = $run_directories[-1];
   $run_number =~ s/run//g;
   $run_number++;
}

$run_directory = getcwd() . "/" . sprintf "run%03s", $run_number;
$ENV{RUNDIRECTORY} = "$run_directory";
mkdir($run_directory) || &swiftquit("Unable to create run directory $run_directory");

# Set @sites array from comma separated list of sites
if(defined($option_siteslist)) {
   @sites = split(',', $option_siteslist);
}

# Verify Swift is found in PATH
my $swift_etc_directory = dirname(dirname($0)) . "/etc";
if( ! -d $swift_etc_directory ) { &swiftquit("Unable to find a valid Swift installation"); }

# Set the search order for properties
&add_property_file("$swift_etc_directory/swift.properties");
&add_property_file("$ENV{SWIFT_SITE_CONF}/swift.properties") if defined($ENV{SWIFT_SITE_CONF});
&add_property_file("$ENV{HOME}/.swift/swift.properties");
&add_property_file("swift.properties");
if(defined($option_properties)) {
   if(! -f $option_properties) {
      swiftquit("Unable to find properties file $option_properties");
   }
   &add_property_file($option_properties);
}

# Set property values
foreach my $property_file(@property_files) {
   open(PROPERTIES, $property_file) || &swiftquit("Unable to open $property_file");

   while( <PROPERTIES> ) {
      chomp;
      next if /^\s*#/ || /^(\s)*$/; # Ignore blank lines and comments
      $_ =~ s/^\s+//;               # Remove leading whitespace

      # Handle brackets 
      if( /^site\.|^service\./ && /{/ ) { 
         my $prefix = (split /\s+{/)[0];
         while( <PROPERTIES> ) {
            chomp;
            next if /^\s*#/ || /^(\s)*$/; 
            $_ =~ s/^\s+//;               
            if( /^}/ ) { last; } 
            my ($key, $value) = split('=', ($prefix . ".$_"), 2);
            if($key eq "sites") { $key = "site"; }
            $value =~ s/\$(\w+)/$ENV{$1}/g;
            $properties{ $key } = $value;
         }
      }

      else {
         my ($key, $value) = split('=', $_, 2);
         if($key eq "sites") { $key = "site"; }
         if(defined($key) && defined($value) && length($key) && length($value)) {
            $value =~ s/\$(\w+)/$ENV{$1}/g; # Substitute environment variables
            $properties{ $key } = $value;
         }
      }
   }
}

# If -listconfig is specified, print values and exit
if( $option_listconfig ) {
   print "\n";
   foreach my $site(@property_files) {
      print "Reading from: $site\n";
   }
   print "\nValues:\n";
   foreach my $key (sort keys %properties) {
      print "\t$key=$properties{$key}\n";
   }
   print "\n";
   exit;
}

# If -version or -help is specified, pass and exit
if ( $option_help ) {
   print "-help\n";
   exit;
} elsif ( $option_version ) {
   print "-version\n";
   exit;
}

@new_swift_args = ("-Dscript.dir=$run_directory/scripts");
push(@new_swift_args, "-Drestart.log.name=$run_directory/restart.log");
push(@new_swift_args, "-swiftoutlog=$run_directory/swift.out");
push(@new_swift_args, "-runid " . basename($run_directory));

# Write swift configuration files
&write_sites("sites.xml") if defined( $option_siteslist ) || defined($properties{site});
&write_apps("apps")    if !defined( $option_tcfile ) && ( defined( $option_siteslist ) || defined($properties{site}));
&write_properties("cf")   if !defined( $option_config );

# Repair args with dots
foreach my $arg(@ARGV) {
   $arg =~ s/sitesfile/sites.file/g;
   $arg =~ s/tcfile/tc.file/g;
}

# Make sure swiftrun arguments aren't sent back to swift
while( @ARGV ) {
   my $option = shift;
   if ( $option eq "-site" || $option eq "-sites" || $option eq "-properties" || $option eq "-property") { shift; }
   else { push( @new_swift_args, $option ); }
}

push( @new_swift_args, sprintf( "-logfile $run_directory/run%03s.log", $run_number ));

foreach my $arg( @new_swift_args ) {
   print "$arg ";
}

print "\n";
