#!/usr/bin/perl -w

use strict;
use warnings;
use File::Basename;
use Getopt::Long qw(GetOptionsFromArray);
use Switch;
use Cwd;

Getopt::Long::Configure("pass_through");

my %properties = ();		# Hash storing all swift properties
my @property_files = ();	# List of swift property files to be read
my $option_tcfile;		# Value of -tc.file option
my $option_sitesfile;		# Value of -sites.file option
my $option_siteslist;		# Value of -sites option, comma separated
my $option_config;		# Value of -config option
my @sites;			# List of sites from -sites in array
my $run_directory;		# Run directory to be created, run.NNNN
my @new_swift_args;		# New command line arguments
my @original_swift_args;	# Original arguments

# List of xml shortcuts. Keep in lower case.
my %xml_aliases = (
                   'provider'     => 'provider.coaster',
                   'jobspernode'  => 'globus.jobspernode',
                   'maxwalltime'  => 'globus.maxwalltime',
                   'queue'        => 'globus.queue',
                   'initialscore' => 'karajan.initialscore',
);

# Verify a property file exists and add it to the search path
sub add_property_file {
   my $property_file = $_[0];
   if( -e "$property_file" ) {
      push( @property_files, $property_file );
   }
}

# Create a string with a single pool entry
sub create_pool_entry {
   my $site = $_[0];
   my $pool = "\n<pool handle=\"" . $site . "\">\n";
   while( my( $key, $value ) = each( %properties ) ) {
      if( $key =~ /^\s*site.$site/ ) {
         $pool .= &property_to_xml( $key, $value );
      }
   }
   $pool .= "</pool>\n";
   return $pool;
}

# Given a string in format site.beagle.globus.jobsPerNode=12, convert to xml
sub property_to_xml {
   my $key = $_[0];
   my $value = $_[1];
   my ( $site, $sitename, $namespace, $property ) = split(/\./, $key);

   # In the case of a shortened definition, check for aliases 
   if ( !defined( $property ) ) {
      if ( defined( $xml_aliases{ lc( $namespace )})) { 
         ( $namespace, $property ) = split(/\./, $xml_aliases{ lc($namespace) });
      }
   }     
   
   # Make sure to handle special cases that are not in the namespace=x, key=y, format
   switch($namespace) {
      case "provider"	   { return "<execution provider=\"" . $property . "\" jobmanager=\"" . $value . "\"/>\n"; }
      case "workdirectory" { return "<workdirectory>$value</workdirectory>\n"; }
      case "filesystem"    { return "<filesystem provider=\"" . $value . "\"/>\n"; }
      else                 { return "<profile namespace=\"" . $namespace . "\" key=\"" . $property . "\">" . $value . "</profile>\n"; }
   }
} 

# Write apps to file in tc.data format
sub write_apps {
   my $app_filename = $_[0];
   open( APP_FILE, ">$run_directory/$app_filename" ) || die "Unable to open $run_directory/$app_filename\n";

   # Find app definitions
   while( my( $key, $value ) = each( %properties ) ) {
      if( $key =~ /^\s*app./ ) {
         my ( $app, $site, $command ) = split(/\./, $key);

         # Handle wildcards for site names
         if ( $site eq "*" ) { 
            foreach my $nsite( @sites ) {
               print APP_FILE "$nsite $command $value\n";
            }
         } 

         # Handle apps for defined sites
         elsif ( grep( /^$site$/, @sites ) ) {
            print APP_FILE "$site $command $value\n";
         }
      }
   }
   # Update command line args
   push( @new_swift_args, "-tc.file $run_directory/$app_filename" );
}

# Write properties to file
sub write_properties {
   my $property_filename = $_[0];
   open( PROPERTY_FILE, ">$run_directory/$property_filename" ) || die "Unable to open $run_directory/$property_filename\n";
   while( my( $key, $value ) = each( %properties ) ) {
      # Ignore properties that start with app. or site.
      next if $key =~ /^\s*app./;
      next if $key =~ /^\s*site./;
      print PROPERTY_FILE "$key=$value\n";
   }
   push( @new_swift_args, "-config $run_directory/$property_filename" );
}

# Write sites.xml to disk
sub write_sites {
   my $filename = $_[0];
   open(SITES, ">$run_directory/$filename") || die "Unable to open $run_directory/$filename\n";
   print SITES "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
   print SITES "<config xmlns=\"http://www.ci.uchicago.edu/swift/SwiftSites\">\n";

   foreach my $site(@sites) {
      print SITES &create_pool_entry($site);
   }

   print SITES "\n</config>\n";
   close(SITES);
   push(@new_swift_args, "-sites.file $run_directory/$filename");
}

# Getopt::Long can't accept dots in arguments, work around to make things easy
foreach my $arg(@ARGV) {
   $arg =~ s/sites.file/sitesfile/g;
   $arg =~ s/tc.file/tcfile/g;
}

# Command line arguments we care about
@original_swift_args = @ARGV;
GetOptionsFromArray(
           \@original_swift_args, 
           'sitesfile=s'     => \$option_sitesfile,
           'tcfile=s'        => \$option_tcfile,
           'config=s'        => \$option_config,
           'site|sites=s'    => \$option_siteslist,
);

# Set @sites array from comma separated list of sites
if(defined($option_siteslist)) {
   @sites = split(',', $option_siteslist);
}

# Verify Swift is found in PATH
my $swift_etc_directory = dirname(dirname(`which swift`)) . "/etc";
if( ! -d $swift_etc_directory ) { die "Unable to find a valid Swift installation"; }

# Set the search order for properties
&add_property_file("$swift_etc_directory/swift.properties");
&add_property_file("$ENV{SWIFT_CONFIG}/swift.properties") if defined($ENV{SWIFT_CONFIG});
&add_property_file("$ENV{HOME}/.swift/swift.properties");
&add_property_file("swift.properties");

# Set property values
foreach my $property_file(@property_files) {
   open(PROPERTIES, $property_file) || die "Unable to open $property_file";
   while( <PROPERTIES> ) {
      chomp;
      next if /^\s*#/ || /^(\s)*$/; # Ignore blank lines and comments
      my ($key, $value) = split('=', $_, 2);
      $value =~ s/\$(\w+)/$ENV{$1}/g; # Substitute environment variables
      $properties{ $key } = $value;
   }
}

# Create/increment run directory
my $run_number = 0;
my @run_directories = <run????>;

if(@run_directories) {
   $run_number = $run_directories[-1];
   $run_number =~ s/run//g;
   $run_number++;
}

$run_directory = getcwd() . "/" . sprintf "run%04s", $run_number;
mkdir($run_directory) || die "Unable to create run directory $run_directory\n";

# Write swift configuration files
&write_sites("sites.xml") if defined( $option_siteslist );
&write_apps("tc.data")    if ( !defined( $option_tcfile ) && defined( $option_siteslist ));
&write_properties("cf")   if !defined( $option_config );

# Repair args with dots
foreach my $arg(@ARGV) {
   $arg =~ s/sitesfile/sites.file/g;
   $arg =~ s/tcfile/tc.file/g;
}

# Make sure -sites isn't in the arguments we send back to swift
while( @ARGV ) {
   my $option = shift;
   switch( $option ) {
      case "-site" { shift; }
      case "-sites" { shift; }
      else { push( @new_swift_args, $option ); }
   }
}

push( @new_swift_args, sprintf( "-logfile $run_directory/run%04s.log", $run_number ));

foreach my $arg( @new_swift_args ) {
   print "$arg ";
}

print "\n";
