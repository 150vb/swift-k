<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [] >

<article>
    <articleinfo>
        <title>A Swift Tutorial for Live Presentation</title>
        <abstract>
            <formalpara>
                <para>
This is an introductory tutorial on the use of Swift and its
programming language SwiftScript. It is intended for use as part of a live
tutorial with instructor-provided exercise environments, and as such probably
doesn't make much sense to attempt outside of those environments.
                </para>
                <para>
$LastChangedRevision$
                </para>
            </formalpara>
        </abstract>
    </articleinfo>

<sect1> <title>Introduction</title>
    <para>
This tutorial is intended to introduce new users to the basics of Swift.
It is structured as a series of small exercise/examples which you can
try for yourself as you read along.
    </para>
</sect1>

<sect1> <title>Hello World</title>
    <para>
The first example program (found in the file
examples/vdsk/tutorial/q1.swift) outputs a hello world message into
a file called hello.txt.
    </para>

<programlisting>
type messagefile;

(messagefile t) greeting () {
    app {
        echo &quot;Hello, world!&quot; stdout=@filename(t);
    }
}

messagefile outfile &lt;&quot;hello.txt&quot;&gt;;

outfile = greeting();
</programlisting>

<para>We can run this program as follows:</para>

<programlisting>
$ cd examples/vdsk/tutorial/

$ swift q1.swift

Swift v0.1-dev

RunID: e1bupgygrzn12
echo started
echo completed

$ cat hello.txt
Hello, world!
</programlisting>

<para>The basic structure of this program is a type definition,
a procedure definition, a variable definition and
then a call to the procedure:</para>

<para>
All data in SwiftScript must have a type. This line defines a new type
called messagefile, which will be the type of the in which we will store
our 'hello world' message.
</para>

<programlisting>
type messagefile;
</programlisting>

<para>
Next we define a procedure called write. This procedure will write out
the &quot;hello world&quot; message to a file.
</para>

<para>
To achieve this, it executes the standard unix utility 'echo' with a parameter
&quot;Hello, world!&quot; and send the standard output into the output file t.
</para>

<para>
The output of a program looks like a return value. It has a type, but also
has a variable name (unlike in other programming languages).
</para>

<programlisting>
(messagefile t) greeting () {
    app {
        echo &quot;Hello, world!&quot; stdout=@filename(t);
    }
}
</programlisting>


<para>
Next we define a variable called outfile. The type of this variable is
messagefile, and we specify that the contents of this variable will
be stored on disk in a file called hello.txt. This is called Mapping
and will be discussed in more depth later, but for now accept that
it means that assigning to outfile will cause data to appear in a disk
file called &quot;hello.txt&quot;.
</para>

<programlisting>
messagefile outfile &lt;&quot;hello.txt&quot;&gt;;
</programlisting>

<programlisting>
outfile = greeting();
</programlisting>

<para>
Now we call the greeting procedure, with its output going to the
outfile variable and therefore to hello.txt on disk.
</para>

<para>Over the following exercises, we'll extend this simple
hello world program to demonstrate various features of Swift.</para>

</sect1>

<sect1> <title>Parameters</title>

<para>
Procedures can have parameters. Input parameters specify inputs to the
procedure and output parameters specify outputs. Our helloworld greeting
procedure already uses an output parameter, t, which indicates where the
greeting output will go. In this section, we will add an input parameter
to the greeting function.</para>

<para>
We will also encounter a new built-in data type, 'string'.
</para>

<para>Here's the next version of the program:</para>

<programlisting>
type messagefile;

(messagefile t) greeting (string s) {
    app {
        echo s stdout=@filename(t);
    }
}

messagefile outfile &lt;&quot;hello2.txt&quot;&gt;;

outfile = greeting(&quot;hello world&quot;);
</programlisting>


<para>The code for this section can be found in q2.swift. It can be
invoked using the swift command, with output appearing in hello2.txt.</para>

<programlisting>
$ swift q2.swift
</programlisting>

<para>The code changes from q1.swift are highlighted below.</para>

<para>As before, we define a type for our message files:</para>
<programlisting>
type messagefile;
</programlisting>

<para>
We define a greeting function again. It is different from before in two ways:
firstly, we have added an input parameter 's'. We will use this parameter
to pass in a message. It has type 'string', which is a built in Swift type
for representing strings.
</para>

<programlisting>
(messagefile t) greeting (string s) {
    app {
</programlisting>

<para>
We modify the call to echo to use the message parameter s instead of
the previously used hard-coded string.
</para>

<programlisting>
        echo s stdout=@filename(t);
    }
}
</programlisting>
<para>
We define an output variable, this time indicating that its contents will be
stored in "hello2.txt".
</para>

<programlisting>
messagefile outfile &lt;&quot;hello2.txt&quot;&gt;;
</programlisting>

<para>Finally, our call to greeting needs to have a parameter. We pass in the
string &quot;hello world&quot;.
</para>
<programlisting>
outfile = greeting(&quot;hello world&quot;);
</programlisting>

<para>After running this program, you should find the hello world message
inside hello2.txt
</para>

</sect1>

<sect1><title>Calling the same function with different parameters</title>
<para>Now that we can choose our greeting text, we can call the same
procedure with different parameters to generate several output files with
different greetings. The code is in q12.swift and can be run as before
using the swift command.
</para>

<para>
We keep the type and procedure definitions the same...
</para>

<programlisting>
type messagefile;

(messagefile t) greeting (string s) {
    app {
        echo s stdout=@filename(t);
    }
}
</programlisting>

<para>
The program differs here, though. We define three variables and invoke
the greeting procedure three times.
</para>

<programlisting>
messagefile english &lt;&quot;english.txt&quot;&gt;;
messagefile french &lt;&quot;francais.txt&quot;&gt;;

english = greeting(&quot;hello&quot;);
french = greeting(&quot;bonjour&quot;);

messagefile japanese &lt;&quot;nihongo.txt&quot;&gt;;
japanese = greeting(&quot;konnichiwa&quot;);
</programlisting>

<para>Note that we can intermingle definitions of variables with invocations
of procedures.</para>

<para>When this program has been run, there should be three new files in the
working directory (english.txt, francais.txt and nihongo.txt) each containing
a greeting in a different language.</para>

</sect1>

<sect1><title>Another procedure</title>
<para>
Now we'll define a new application procedure. This will take an
image in PGM format and convert it to a GIF format image file.
</para>

<para>To do this, we'll use the ImageMagick 'convert' utility.</para>

<para>First we need to tell Swift where it can find the convert utility.
</para>
<para>This information is stored in the Transformation Catalog, in
etc/tc.data. We must add a line to specify the location of convert,
like this:
</para>

<programlisting>
local    convert    /usr/bin/convert    INSTALLED INTEL32::LINUX null
</programlisting>

<para>For now, ignore all of the fields except the second and the third.
The second field 'convert' specifies a Logical Transformation name and the
third specifies the location of an executable to perform that
transformation.</para>

<para>Now that we have defined the logical transformation 'convert', we can
use it in SwiftScript:
</para>

<programlisting>
type giffile;
type pgmfile;

(giffile outgif) convert(pgmfile inpgm)
{
    app {
        convert @inpgm @outgif;
    }
}

pgmfile infile &lt;&quot;in.pgm&quot;&gt;;
giffile outfile &lt;&quot;out.gif&quot;&gt;;

outfile = convert(infile);
</programlisting>

<para>We define new data types for files containing PGM and GIF images
Then we define a 'convert' procedure which invokes the
convert utility with appropriate parameters.
Finally, we define input and output variables of the appropriate type
and invoke convert to perform the conversion.
</para>

<para>We can use the swift command to run this program (as in the previous
exercise). After running the command, there will be a file called out.gif
which contains the swift logo, converted from its pgm source.</para>
</sect1>

<sect1><title>More on datatypes</title>

<para>
As mentioned earlier, all data in Swift has a datatype. So
far, we've seen simple user-defined datatypes (messagefile, pgmfile
and giffile)
</para>

<para>It is also possible to create types with more structure, like in other
programming languages.</para>

<para>
In the FMRI workflow that we will write in this exercise, we will be dealing
with input data files that consist of a three dimensional brain volume
split into two files, the image data and the header data. So our data will
always come in pairs (such as subject1.img and subject1.hdr together, or
reference.img and reference.hdr together).
</para>

<para>We can tell Swift about this pairing of files using a complex data
type.</para>

<para>First define types for the header and image files, as before.
</para>

<programlisting>
type imagefile;
type headerfile;
</programlisting>

<para>Now we can define a volume data type that consists of an image file
and a header file.
</para>

<programlisting>
type volume {
    imagefile img;
    headerfile hdr;
};
</programlisting>

<para>Using a complex type like this, swift can ensure that files that belong
with each other are always kept together.
</para>

</sect1>

<sect1><title>Mappers</title>

<para>A significant difference between SwiftScript and other languages is
that data can be referred to on disk through variables in a very
similar fashion to data in memory.  For example, in the above
examples we have seen a variable definition like this:</para>

<programlisting>
messagefile outfile &lt;&quot;q13greeting.txt&quot;&gt;;
</programlisting>

<para>This means that the 'outfile' variable is
mapped to a file on disk called 'g13greeting.txt'. The contents of the
variable are the contents of the file q13greeting.txt.
</para>

<para>
Assigning to this variable is the same as writing to the file, and
reading from this variable is the same as reading from the file.
</para>

<para>We say that outfile is <firstterm>mapped</firstterm> to 
q13greeting.txt
</para>

<para>There are various ways of mapping in SwiftScript. The syntax above
is the simplest form. It associates a variable with an explicitly named
file. Later exercises will introduce other ways of mapping from
on-disk files to SwiftScript variables.</para>


<para>TODO this text should move / be rephrased</para>

<para>We can't use the single filename mapping technique to map into our
new 'volume' structure because a volume value consists of several files.
</para>
<para>Instead, we must use a more complicated mapper which understands how
files are laid out in relation to the structure that we have defined.
</para>
<para>There are two cases in our workflow where we need to refer to a single
volume (the reference and atlas cases) and another case where we need to
refer to an array of volumes (the subject case).
</para>
<para>END TODO</para>

</sect1>




<sect1><title>Anonymous files</title>

<para>TODO the previous exercise used to chain two procedures together
so that this would be demonstrated, but the conversion to using convert
lost that. should diddle first two exercises to put that back in,
for example by changing the first exercise to be graphics based too.</para>

<para>In the previous section, the file 'q13greeting.txt' is used only to
store an intermediate result. We don't really care about which name is used
for the file, as no matter which intermediate name is used we will still
get the same word count.</para>

<para>In this case, we can omit the filename mapping part of the variable
declaration. Instead of:</para>

<programlisting>
messagefile outfile &lt;&quot;q13greeting.txt&quot;&gt;;
</programlisting>

<para>we can instead write:</para>

<programlisting>
messagefile outfile;
</programlisting>

<para>In this case, swift will still store outfile on disk when necessary,
but will generate a new name automatically.</para>

<para>q14.swift contains the code and can be run in the usual way. After
execution, the results can be found in count14.txt</para>

<programlisting>
cat count14.txt
     3 outfile-7ad257c2-c792-4f61-a0eb-96667c62ad60
</programlisting>

<para>Observe that a generated name,
outfile-7ad257c2-c792-4f61-a0eb-96667c62ad60, was
automatically mapped to outfile.</para>

</sect1>
<sect1><title>Arrays</title>
<para>We can define arrays of values. For example, we could specify each
word in a greeting as a separate element of a string array, as seen in
q5.swift:</para>

<programlisting>
type messagefile;

(messagefile t) greeting (string s[]) {
    app {
        echo s[0] s[1] s[2] stdout=@filename(t);
    }
}

messagefile outfile &lt;&quot;q5out.txt&quot;&gt;;

string words[] = [&quot;how&quot;,&quot;are&quot;,&quot;you&quot;];

outfile = greeting(words);

</programlisting>

<para>Observe that the type of the parameter to greeting is now an
array of strings, 'string s[]', instead of a single string, 'string s',
that elements of the array can be referenced numerically, for example
s[0], and that the array is initialised using an array literal,
[&quot;how&quot;,&quot;are&quot;,&quot;you&quot;].</para>

</sect1>

<para>TODO: don't need regexp mapper - the FMRI example code I wrote
uses csv mapper and simple_mapper and single_file_mapper</para>

<sect1><title>The regexp mapper</title>
<para>In this exercise, we introduce the <firstterm>regexp mapper</firstterm>.
This mapper transforms a string expression using a regular expression,
and uses the result of that transformation as the filename to map.</para>
<para>
q16.swift demonstrates the use of this by placing output into a file that
is based on the name of the input file: our input file is mapped
to the inputfile variable using the simple named mapper, and then
we use the regular expression mapper to map the output file. Then we
use the countwords() procedure that we defined in exercise ANOTHERPROCEDURE
to count the works in the input file and store the result in the
output file.
</para>

<para>
The important bit of q16.swift is:
<programlisting>
messagefile inputfile &lt;"q16.txt"&gt;;

countfile c &lt;regexp_mapper;source=@inputfile,match="(.*)txt",transform="\1count"&gt;;
</programlisting>
</para>
</sect1>

<sect1><title>fixed_array_mapper</title>
<para>
The <firstterm>fixed array mapper</firstterm> maps a list of files into
an array - each element of the array is mapped into one file in the
specified directory. see q22.swift
</para>
<programlisting>
string inputNames = "one.txt two.txt three.txt";
string outputNames = "one.count two.count three.count";

messagefile inputfiles[] &lt;fixed_array_mapper;files=inputNames&gt;;
countfile outputfiles[] &lt;fixed_array_mapper;files=outputNames&gt;;

outputfiles[0] = countwords(inputfiles[0]);
outputfiles[1] = countwords(inputfiles[1]);
outputfiles[2] = countwords(inputfiles[2]);
</programlisting>
</sect1>

<sect1><title>foreach</title>
<para>SwiftScript provides a control structure, foreach, to operate
on each element of an array.</para>
<para>In this example, we will run the previous word counting example
over each file in an array without having to explicitly list the
array elements. The source code for this example is in q17.swift. The
three input files (one.txt, two.txt and three.txt) are supplied. After
you have run the workflow, you should see that there are three output
files (one.count, two.count and three.count) each containing the word
count for the corresponding input file. We combine the use of the
fixed_array_mapper and the regexp_mapper.</para>
<programlisting>
string inputNames = "one.txt two.txt three.txt";

messagefile inputfiles[] &lt;fixed_array_mapper;files=inputNames&gt;;


foreach f in inputfiles {
  countfile c &lt;regexp_mapper;source=@f,match="(.*)txt",transform="\1count"&gt;;
  c = countwords(f);
}
</programlisting>

</sect1>

<sect1><title>Visualising the workflow as a graph</title>

<para>
When running a workflow, its possible to generate a provenance graph at the
same time:
<programlisting>
swift -pgraph graph1.dot q1.swift
dot -ograph.png -Tpng graph1.dot
</programlisting>
which can then be viewed using your favourite image viewer.
</para>
</sect1>

<sect1><title>Running on a remote site</title>

<para>So far, all applications that we've run so far has been run on our
<firstterm>submit system</firstterm>, the place where the swift command
has been run.</para>

<para>Now, we are going to tell swift to run procedures on remote
grid systems.</para>

<para>We do not need to modify any SwiftScript code to run on another resource.
Instead, we must modify a configuration file, the 
<firstterm>site catalog</firstterm>. This catalog
provides details of the location that applications will be run. By default,
the site catalog specifies that applications will run on the local
system. There is a commented out section that give details of a different
grid system. Comment out the local definition, and uncomment the other
site definition.
</para>

<para>Now try running any of the swift commands that you've run 
earlier in this tutorial. Any of them should work, but will now
result in jobs running on the remote site instead of the local one.
The output files should be exactly the same, but now you have used a
grid resource to run the application.
</para>
</sect1>

</article>

