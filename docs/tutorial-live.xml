<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [] >

<article>
    <articleinfo>
        <title>A Swift Tutorial for Live Presentation</title>
        <abstract>
            <formalpara>
                <para>
This is an introductory tutorial on the use of Swift and its
programming language SwiftScript. It is intended for use as part of a live
tutorial with instructor-provided exercise environments, and as such probably
doesn't make much sense to attempt outside of those environments.
                </para>
                <para>
$LastChangedRevision$
                </para>
            </formalpara>
        </abstract>
    </articleinfo>

<sect1> <title>Introduction</title>
    <para>
This tutorial is intended to introduce new users to the basics of Swift.
It is structured as a series of small exercise/examples which you can
try for yourself as you read along.
    </para>
</sect1>

<sect1> <title>Hello World</title>
    <para>
The first example program uses an image processing utility to perform
a visual special effect on a supplied file.
    </para>

<para>
This simple workflow has the effect of running this command:
</para>
<programlisting>
convert -flip Gridworkshop3.jpg output.jpg
</programlisting>

<para>We can run this program like this:</para>

<programlisting>

$ ls *.jpg
Gridworkshop3.jpg

$ swift flipper.swift

Swift v0.1-dev

RunID: e1bupgygrzn12
convert started
convert completed

$ ls *.jpg
Gridworkshop3.jpg
output.jpg
</programlisting>

<para>The basic structure of this program is a type definition,
a procedure definition, a variable definition and
then a call to the procedure:</para>

<para>
All data in SwiftScript must have a type. This line defines a new type
called imagefile, which will be the type that all of our images will be.
</para>

<programlisting>
type imagefile;
</programlisting>

<para>
Next we define a procedure called flip. This procedure will use the
ImageMagick convert application to flip a picture around.
</para>

<programlisting>
(imagefile output) flip(imagefile input) {
  app {
    convert "-flip" @input @output;
  }
}
</programlisting>

<para>
To achieve this, it executes the ImageMagick utility 'convert', passing
in the appropriate commandline option and the name of the input and output
files.

<para>
In swift, the output of a program looks like a return value. 
It has a type, and also has a variable name
(unlike in other programming languages).
</para>

<para>
We define two variables, called spacegirl and flipped. These variables will
contain our input and output images, respectively.
</para>

<para>We tell swift that the contents of the variables will be stored on
disk (rather than in memory) in the files "Gridworkshop3.jpg" (which already
exists), and in "output.jpg". This is calle <firstterm>mapping</firstterm>
and will be discussed in more depth later.</para>

<programlisting>
imagefile spacegirl <"Gridworkshop3.jpg">;
imagefile flipped <"output.jpg">;
</programlisting>

<programlisting>
flipped = flip(spacegirl);
</programlisting>

<para>
Now we call the flip procedure, with 'spacegirl' as its input and its
output going into 'flipped'.
</para>

<para>Over the following exercises, we'll extend this relatively
simple SwiftScript program to demonstrate various features of Swift.</para>

</sect1>

<!-- TODO this text needs to be pushed down into the following 
exercise body
<sect1> <title>Parameters</title>

<para>
Procedures can have parameters. Input parameters specify inputs to the
procedure and output parameters specify outputs. Parameters have a name
and a type.
Our flip procedure
has one input parameter  ('input', of type imagefile) and one output
parameter ('output', of type imagefile).
</para>


<sect1><title>Arrays</title>
<para>We can define arrays of values. For example, we could specify each
word in a greeting as a separate element of a string array, as seen in
q5.swift:</para>

<programlisting>
type messagefile;

(messagefile t) greeting (string s[]) {
    app {
        echo s[0] s[1] s[2] stdout=@filename(t);
    }
}

messagefile outfile &lt;&quot;q5out.txt&quot;&gt;;

string words[] = [&quot;how&quot;,&quot;are&quot;,&quot;you&quot;];

outfile = greeting(words);

</programlisting>

<para>Observe that the type of the parameter to greeting is now an
array of strings, 'string s[]', instead of a single string, 'string s',
that elements of the array can be referenced numerically, for example
s[0], and that the array is initialised using an array literal,
[&quot;how&quot;,&quot;are&quot;,&quot;you&quot;].</para>

</sect1>


<sect1><title>The single_file_mapper</title>
<para>
This exercise introduces the <firstterm>single_file_mapper</firstterm>.
This mapper allows you to map a file based on the result of a string
expression. We can use string concatenation to assemble a filename, and
then map that filename to a variable.
</para>
<para>Previously we've used syntax like this:
</para>
<para>TODO - this example needs making coherent with rest</para>
<programlisting>
giffile outputgif <"atlas-x.gif">;
</programlisting>
<para>We can instead assemble the filename and map that, like this:
</para>
<programlisting>
string direction = "x";
giffile outputgif &lt;single_file_mapper;file=@strcat("atlas-",direction,".gif")&gt;;
</programlisting>
</sect1>


<sect1><title>foreach</title>
<para>SwiftScript provides a control structure, foreach, to operate
on each element of an array.</para>
<para>In this example, we will run the previous word counting example
over each file in an array without having to explicitly list the
array elements. The source code for this example is in q17.swift. The
three input files (one.txt, two.txt and three.txt) are supplied. After
you have run the workflow, you should see that there are three output
files (one.count, two.count and three.count) each containing the word
count for the corresponding input file. We combine the use of the
fixed_array_mapper and the regexp_mapper.</para>
<programlisting>
string inputNames = "one.txt two.txt three.txt";

messagefile inputfiles[] &lt;fixed_array_mapper;files=inputNames&gt;;


foreach f in inputfiles {
  countfile c &lt;regexp_mapper;source=@f,match="(.*)txt",transform="\1count"&gt;;
  c = countwords(f);
}
</programlisting>

</sect1>

-->

<para>
Our next example program uses some more swift syntax to produce images that are
rotated by different angles, instead of flipped over all the way.
</para>

<para>Here is the program in full. We'll go over it section by section.</para>
<programlisting>
type imagefile;

(imagefile output) rotate(imagefile input, int angle) {
  app {
    convert "-rotate" angle @input @output;
  }
}

imagefile spacegirl <"Gridworkshop3.jpg">;

int angles[] = [45, 90, 120];

foreach a in angles {
    imagefile output &lt;single_file_mapper;file=@strcat("rotated-",a,".jpg")&gt;;
    output = rotate(spacegirl, a);
}
</programlisting>

<programlisting>
type imagefile;
</programlisting>

<para>
We keep the type definition the same as in the previous program.
</para>

<programlisting>
(imagefile output) rotate(imagefile input, int angle) {
  app {
    convert "-rotate" angle @input @output;
  }
}
</programlisting>

<para>
This rotate procedure looks very much like the flip procedure 
from the previous program,
but we have added another parameter, called angle. Angle is of type 'int',
which is a built-in SwiftScript type for integers. We use that on the
commandline instead of a hard coded 180 degrees.
</para>

<programlisting>
imagefile spacegirl <"Gridworkshop3.jpg">;
</programlisting>

<para>
Our input image is the same as before.
</para>

<programlisting>
int angles[] = [45, 90, 120];
</programlisting>

<para>
Now we define an array of integers, and initialise it with three angles.
</para>

<programlisting>
foreach a in angles {
</programlisting>

<para>
Now we have a foreach loop. This loop will iterate over each of the elements
in angles. In each iteration, the element will be put in the variable 'a'.
</para>

<programlisting>
    imagefile output &lt;single_file_mapper;file=@strcat("rotated-",a,".jpg")&gt;;
</programlisting>

<para>
Inside the loop body, we have an output variable that is mapped differently
for each iteration. We use the single_file_mapper and the @strcat function
to construct a filename and then map that filename to our output variable.
</para>

<programlisting>
    output = rotate(spacegirl, a);
}
</programlisting>

<para>Now we invoke rotate, passing in our input image and the angle to
use, and 

</para>
<programlisting>
$ ls rotated*
rotated-120.jpg rotated-45.jpg  rotated-90.jpg
</programlisting>

<para>
Our third example will introduce some more concepts: complex data
types, the comma-separated values mapper, and the transformation
catalog.
</para>

<para>
Here's the complete listing:
</para>

<programlisting>

type imagefile;
type pgmfile;

type voxelfile;
type headerfile;

type volume {
    voxelfile img;
    headerfile hdr;
};


volume references[] &lt;csv_mapper;file="reference.csv"&gt;;
volume reference=references[0];

(pgmfile outslice) slicer(volume input, string axis, string position)
{
    app {
        slicer @input.img axis position @outslice;
    }
}

(imagefile output) convert(pgmfile inpgm)
{
    app {
        convert @inpgm @output;
    }
}

pgmfile slice;

imagefile slicejpeg <"slice.jpeg">;

slice = slicer(reference, "-x", ".5");

slicejpeg = convert(slice);

</programlisting>


<programlisting>
type imagefile;
type pgmfile;
type voxelfile;
type headerfile;
</programlisting>

<para>
We define some simple types - imagefile as before, as well as three new ones.
</para>

<programlisting>
type volume {
    voxelfile img;
    headerfile hdr;
};
</programlisting>

<para>
Now we define a <firstterm>complex type</firstterm> to represent a brain scan.
Our programs store brain data in two files - a .img file and a .hdr file.
This complex type defines a volume type, consisting of a voxelfile and a
headerfile.
</para>

<programlisting>
volume references[] &lt;csv_mapper;file="reference.csv"&gt;;
</programlisting>

<para>
Now that we have defined a more complex type that consists of several
elements (and hence several files on disk), we can no longer use the
same ways of mapping. Instead, we will use a new mapper, the CSV mapper.
This maps rows of a comma-separated value file into an array of complex
types. The content of reference.csv looks like this:
</para>
<programlisting>
$ cat reference.csv
img,hdr
Raw/reference.img,Raw/reference.hdr
</programlisting>
<para>Our mapped structure will be a 1 element array (because there was one
data line in the CSV file), and that element will be mapped to two
files: the img component will map to the file Raw/reference.img and the
hdr component will map to Raw/reference.hdr
</para>

<programlisting>
volume reference=references[0];
</programlisting>

<para>
We only want the single first element of the references array, so this line
makes a new volume variable and extracts the first element of references.
</para>

<programlisting>
(imagefile output) convert(pgmfile inpgm)
{
    app {
        convert @inpgm @output;
    }
}
</programlisting>

<para>
This procedure is like the previous flip and rotate procedures. It uses
convert to change a file from one file format (.pgm format) to another
format (.jpeg format)
</para>

<programlisting>
(pgmfile outslice) slicer(volume input, string axis, string position)
{
    app {
        slicer @input.img axis position @outslice;
    }
}
</programlisting>

<para>
Now we define another procedure that uses a new application called 'slicer'.
Slicer will take a slice through a supplied brain scan volume and produce
a 2d image in PGM format.
</para>

<para>
We must tell Swift how to run 'slicer' by modifying the
<firstterm>transformation catalog</firstterm>.
</para>

<programlisting>
pgmfile slice;

imagefile slicejpeg <"slice.jpeg">;

slice = slicer(reference, "-x", ".5");

slicejpeg = convert(slice);

</programlisting>


TODO integrate the following sections
<sect1><title>Another procedure</title>
<para>
Now we'll define a new application procedure. This will take an
 mage in PGM format and convert it to a GIF format image file.
</para>

<para>To do this, we'll use the ImageMagick 'convert' utility.</para>

<para>First we need to tell Swift where it can find the convert utility.
</para>
<para>This information is stored in the Transformation Catalog, in
etc/tc.data. We must add a line to specify the location of convert,
like this:
</para>

<programlisting>
local    convert    /usr/bin/convert    INSTALLED INTEL32::LINUX null
</programlisting>

<para>For now, ignore all of the fields except the second and the third.
The second field 'convert' specifies a Logical Transformation name and the
third specifies the location of an executable to perform that
transformation.</para>

<para>Now that we have defined the logical transformation 'convert', we can
use it in SwiftScript:
</para>

<programlisting>
type giffile;
type pgmfile;

(giffile outgif) convert(pgmfile inpgm)
{
    app {
        convert @inpgm @outgif;
    }
}

pgmfile infile &lt;&quot;in.pgm&quot;&gt;;
giffile outfile &lt;&quot;out.gif&quot;&gt;;

outfile = convert(infile);
</programlisting>

<para>We define new data types for files containing PGM and GIF images
Then we define a 'convert' procedure which invokes the
convert utility with appropriate parameters.
Finally, we define input and output variables of the appropriate type
and invoke convert to perform the conversion.
</para>

<para>We can use the swift command to run this program (as in the previous
exercise). After running the command, there will be a file called out.gif
which contains the swift logo, converted from its pgm source.</para>
</sect1>

<sect1><title>More on datatypes</title>

<para>
As mentioned earlier, all data in Swift has a datatype. So
far, we've seen simple user-defined datatypes (messagefile, pgmfile
and giffile)
</para>

<para>It is also possible to create types with more structure, like in other
programming languages.</para>

<para>
In the FMRI workflow that we will write in this exercise, we will be dealing
with input data files that consist of a three dimensional brain volume
split into two files, the image data and the header data. So our data will
always come in pairs (such as subject1.img and subject1.hdr together, or
reference.img and reference.hdr together).
</para>

<para>We can tell Swift about this pairing of files using a complex data
type.</para>

<para>First define types for the header and image files, as before.
</para>

<programlisting>
type imagefile;
type headerfile;
</programlisting>

<para>Now we can define a volume data type that consists of an image file
and a header file.
</para>

<programlisting>
type volume {
    imagefile img;
    headerfile hdr;
} '11;
</programlisting>

<para>Using a complex type like this, swift can ensure that files that belong
with each other are always kept together.
</para>

</sect1>

<sect1><title>Mappers</title>

<para>A significant difference between SwiftScript and other languages is
that data can be referred to on disk through variables in a very
similar fashion to data in memory.  For example, in the above
examples we have seen a variable definition like this:</para>

<programlisting>
messagefile outfile &lt;&quot;q13greeting.txt&quot;&gt;;
</programlisting>

<para>This means that the 'outfile' variable is
mapped to a file on disk called 'g13greeting.txt'. The contents of the
variable are the contents of the file q13greeting.txt.
</para>

<para>
Assigning to this variable is the same as writing to the file, and
reading from this variable is the same as reading from the file.
</para>

<para>We say that outfile is <firstterm>mapped</firstterm> to 
q13greeting.txt
</para>

<para>There are various ways of mapping in SwiftScript. The syntax above
is the simplest form. It associates a variable with an explicitly named
file. Later exercises will introduce other ways of mapping from
on-disk files to SwiftScript variables.</para>


<para>TODO this text should move / be rephrased</para>

<para>We can't use the single filename mapping technique to map into our
new 'volume' structure because a volume value consists of several files.
</para>
<para>Instead, we must use a more complicated mapper which understands how
files are laid out in relation to the structure that we have defined.
</para>
<para>There are two cases in our workflow where we need to refer to a single
volume (the reference and atlas cases) and another case where we need to
refer to an array of volumes (the subject case).
</para>
<para>END TODO</para>

</sect1>




<sect1><title>Anonymous files</title>

<para>TODO the previous exercise used to chain two procedures together
so that this would be demonstrated, but the conversion to using convert
lost that. should diddle first two exercises to put that back in,
for example by changing the first exercise to be graphics based too.</para>

<para>In the previous section, the file 'q13greeting.txt' is used only to
store an intermediate result. We don't really care about which name is used
for the file, as no matter which intermediate name is used we will still
get the same word count.</para>

<para>In this case, we can omit the filename mapping part of the variable
declaration. Instead of:</para>

<programlisting>
messagefile outfile &lt;&quot;q13greeting.txt&quot;&gt;;
</programlisting>

<para>we can instead write:</para>

<programlisting>
messagefile outfile;
</programlisting>

<para>In this case, swift will still store outfile on disk when necessary,
but will generate a new name automatically.</para>

<para>q14.swift contains the code and can be run in the usual way. After
execution, the results can be found in count14.txt</para>

<programlisting>
cat count14.txt
     3 outfile-7ad257c2-c792-4f61-a0eb-96667c62ad60
</programlisting>

<para>Observe that a generated name,
outfile-7ad257c2-c792-4f61-a0eb-96667c62ad60, was
automatically mapped to outfile.</para>

</sect1>

<sect1><title>simple_mapper</title>
<para>None of the ways of mapping that we've seen so far can be used to
map a complex structure. We have only seen ways to map from a simple-typed
variable to a single file.</para>
<para>The <firstterm>simple_mapper</firstterm> can map between a
complex structure and a set of files in a directory.
</para>
<para>Here's an example:
</para>
<programlisting>
volume a &lt;simple_mapper;prefix="atlas"&gt;;
</programlisting>
<para>
This will map members of the volume structure to files, like this:
</para>
<para>TODO formatting</para>
<para>variable -> filename</para>
<para>v.img  -> atlas.img</para>
<para>v.hdr  -> atlas.hdr</para>
<sect1>


<sect1><title>fixed_array_mapper</title>
<para>
The <firstterm>fixed array mapper</firstterm> maps a list of files into
an array - each element of the array is mapped into one file in the
specified directory. see q22.swift
</para>
<programlisting>
string inputNames = "one.txt two.txt three.txt";
string outputNames = "one.count two.count three.count";

messagefile inputfiles[] &lt;fixed_array_mapper;files=inputNames&gt;;
countfile outputfiles[] &lt;fixed_array_mapper;files=outputNames&gt;;

outputfiles[0] = countwords(inputfiles[0]);
outputfiles[1] = countwords(inputfiles[1]);
outputfiles[2] = countwords(inputfiles[2]);
</programlisting>
</sect1>
<sect1><title>Visualising the workflow as a graph</title>

<para>
When running a workflow, its possible to generate a provenance graph at the
same time:
<programlisting>
swift -pgraph graph1.dot q1.swift
dot -ograph.png -Tpng graph1.dot
</programlisting>
which can then be viewed using your favourite image viewer.
</para>
</sect1>

<sect1><title>Running on a remote site</title>

<para>So far, all applications that we've run so far has been run on our
<firstterm>submit system</firstterm>, the place where the swift command
has been run.</para>

<para>Now, we are going to tell swift to run procedures on remote
grid systems.</para>

<para>We do not need to modify any SwiftScript code to run on another resource.
Instead, we must modify a configuration file, the 
<firstterm>site catalog</firstterm>. This catalog
provides details of the location that applications will be run. By default,
the site catalog specifies that applications will run on the local
system. There is a commented out section that give details of a different
grid system. Comment out the local definition, and uncomment the other
site definition.
</para>

<para>Now try running any of the swift commands that you've run 
earlier in this tutorial. Any of them should work, but will now
result in jobs running on the remote site instead of the local one.
The output files should be exactly the same, but now you have used a
grid resource to run the application.
</para>
</sect1>

</article>

