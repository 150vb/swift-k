<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [] >

<article>
	<articleinfo revision="0.1">
		<title>The Swift User Guide</title>
		<subtitle>Source control $LastChangedRevision$</subtitle>
		<abstract>
			<formalpara>
				<title></title>
				<para>
SwiftScript is an improved version of the Virtual Data Language that
supports dataset typing and mapping, dataset iteration, conditional
branching, sub-workflow composition and other advanced features. In
this document, we give a few examples to illustrate how to write
SwiftScript programs to exploit such features. SwiftScript syntax has
two flavors; one is in a C-like format, the other in XML. For
simplification purpose, all examples in this document are written
in the C-like format, which can be automatically translated into
the XML format using one of the tools in our virtual data system.
				</para>
			</formalpara>
		</abstract>
	</articleinfo>

	<sect1>
		<title>Overview</title>
		<para>
This manual provides reference material for the SwiftScript language
and the Swift runtime system. For more introductory material, consult
the Swift tutorial.
		</para>
	</sect1>
	<sect1>
		<title>The SwiftScript Language</title>
<para>The syntax of SwiftScript has a superficial resemblance to C and
Java, for example in its use of the { and } characters to enclose
blocks of statements.
</para>
		<sect2>
			<title>Data</title>
		<para>
Data in SwiftScript is strongly typed. It may be represented in-memory
(as with conventional languages) or as an out-of-core file on disk.
For out-of-core files, a mapper (see mapper section) is used to
identify which files are used as backing store for the data. When data is
mapped externally this way, it is called a dataset.
		</para>
<para>
A dataset's physical representation is declared by a mapping descriptor, 
which defines how each element in the dataset's logical schema is 
stored in, and fetched from, physical structures such as directories,
files, and database tables
</para>

<para>
In order to permit reuse for different datasets, mapping functions may
be parameterized for such things as dataset locations. Thus, in order
to access a dataset, we need to know three things: its type schema, 
its mapping descriptor, and the value(s) of any parameter(s) associated 
with the mapping descriptor. For example, if we want to describe a dataset,
whose logical structure is defined by binaryfile, and whose physical
representation is a file called "file1.bin" located at "/home/yongzh/data/",
then the dataset might be declared as follows:
</para>

<programlisting>
binaryfile f1&lt;single_file_mapper;file="/home/yongzh/data/file1.bin"&gt;
</programlisting>

<para>
The above example declares a dataset called f1, which uses a single 
file mapper to map a file from a specific location. What the mapper does 
is merely returning the file name to the system. SwiftScript also 
has a simplified syntax for such cases since single_file_mapper 
is frequently used:

<programlisting>
binaryfile f1&lt;"/home/yongzh/data/file1.bin"&gt;
</programlisting>
</para>



The Swift data model.

Data in an abstract sense is represented in the swift script runtime by
a DSHandle object. DSHandles don't have any guaranteed to work methods.
(? is this true? they should have get paremt, and perhaps others - should
check in source code).

In swift at present DSHandles can represent data in one of three forms.

i) an in-memory value, such as a string or integer. In this case the
value is accessed through methods such as getValue and setValue.

ii) an on-disk data file, which is not exposed to the swift script language
as a value. The value is not exposed to the runtime directly, but the
filename for the file is available through getFilename. The filenames are
provided to the DSHandle implementation objects (which are instances of
the various DataNode classes).

iii) a containing structure - either an array or a defined type.
one of these DSHandles can provide, upon request, subordinate
DSHandles to member elements. However, it isn't required to generate
all of the subordinate DSHandles at once and can be used in a lazy
fashion.

In pracise at the moment the above three are mutually exclusive - for
example, a data set that is mapped to a file cannot have a value extracted
from it in to a swift script expression; and a data item that is a
value cannot be passed into a procedure
executable as a data file using the @filename function.

However the implementation makes no specific checks for the above - errors
wil occur if an attempt was made to use the same variable in two different ways,
but no explicit check is made for the multiple uses of.

In future, it may be the case that the implementation will support multiple forms of access
There is no exp specific reason why a single data object should not
be accessible through multiple accessing methods

In future it may be that mappers map into DSHandle objects, rather than providing a filename list - this woul dallow mappeds to provide their own implementations fo the DSHanlde interface customised to their own us - using own getValue/setValue/getFilename/getDescendants methods.

So there's a potential change in what mappers are here - at present, a mapper takes a 'path' which is a path from a root data item downwards to an eplicit data item, making use of explicitly listed members and listed array elements to return a filename for a file; and vice-versa. but really tthere's notreason for that
to be the specifi API between the two forms.


		</sect2>

		<sect2>
			<title>Type System</title>
			<para>
The SwiftScript type system is based on the XDTM (XML dataset typing 
and mapping) model, where a dataset's logical structure is described 
via (a subset of) XML Schema, which defines primitive scalar data types 
such as Boolean, Integer, String, Float, and Date, and also allows 
for the definition of complex types via the composition of simple 
and complex types.
			</para>
			<para>
Types can be specified in C-like syntax to represent SwiftScript types.
For instance, we can define an order as composed of an array of items,
where each item has a name and a quantity:

<programlisting>
type order {
	item[] items;
}

type item {
	string name;
	integer quantity;
}
</programlisting>

		</para>
		
		<para>
Sometimes, the inner structure of a file on disk is irrelevant and we do
not need to look at the content of the file in the SwiftScript program.
In this case, an empty type can be used, such as:

<programlisting>
type binaryfile {}
</programlisting>
		</para>
		</sect2>

		<sect2>
			<title>Statements</title>
			<para>
A SwiftScript program consists of a number of statements.
Statements may declare types, procedures and variables, assign values to
variables, and express operations over arrays.
			</para>
		</sect2>

		<sect2>
			<title>Declaration Statements</title>
			<para>
Declaration statements declare new variables and optionally assign
a value to them or map those variables to on-disk files.
SwiftScript variables are single-assignment - they may be assigned to
once, either at the time of declaration or later. Attempting to assign
a value a second or subsequent time is an error.
			</para>
<para>
Declaration statements have the general form:
<programlisting>
  typename variablename (&lt;mapping&gt; | = initialValue ) ;
</programlisting>
The format of the mapping expression is defined in the Mappers section.
initialValue may be either an expression or a procedure call that
returns a single value.
</para>
<para>Variables can also be declared in a multivalued-procedure statement,
described in another section.</para>
		</sect2>

		<sect2>
			<title>Assignment Statements</title>
			<para>
Assignment statements assign values to previously declared variables.
Assignments may only be made to variables that have already been 
assigned. Assignment statements have the general form:

<programlisting>
  variable = value;
</programlisting>

where value can be either an expression or a value 
			</para>

			<para>
Variables can also be assigned in a multivalued-procedure statement,
described in another section.
			</para>
		</sect2>

		<sect2>
			<title>Multivalued procedure invocation statements</title>
<para>
Procedures can return more than one value. In such case, the previously
mentioned declaration and assignment statements are insufficient. A
multi-valued procedure invocation can be used. This has the general
form:

<programlisting>
'(' ((type)? variableName ( '=' binding ))+ ')' = procedureinvocation
</programlisting>

Variables can be either declared (if a type is included) or assigned (if
a type is not included). If no bindings are specified, then variables
are assigned in the same order that they are specified in the
procedure declaration. If bindings are specified, then variables are
assigned to the named return parameter.
</para>

		</sect2>

		<sect2>
			<title>Procedures</title>
			<para>
Datasets are operated on by procedures, which take typed data as input,
perform computations on those data, and produce typed data as output. An
atomic procedure defines an interface to an executable program or
service, while a compound procedure composes calls to atomic
procedures, compound procedures, and/or control statements.
			</para>
			
			<para>
A procedure declaration is like a function definition, where we
specify the function name and the formal parameters. SwiftScript
procedures can take multiple inputs and produce multiple outputs.
Inputs are specified to the right of the function name where 
outputs to the left. For instance:

<programlisting>
(type3 out1, type4 out2) myproc (type1 in1, type2 in2)
</programlisting>

The above example declares a procedure called myproc, which 
has two inputs in1 (of type type1) and in2 (of type type2) 
and two outputs out1 (of type type3) and out2 (of type type4).
			</para>
	
			<para>
A procedure input parameter can have a default value, in which case
the parameter is deemed an optional parameter. When we call a
procedure, passing in the actual parameters, we allow both positional
parameter and keyword parameter passing, provided that all optional
parameters have to be declared after the required parameters and any
optional parameter has to be bound using keyword parameter passing.
So for instance if we declare a procedure myproc1:

<programlisting>
(binaryfile bf) myproc1 (int i, string s="foo")
</programlisting>

Then the procedure can be called like this

<programlisting>
binaryfile mybf = myproc1(1);
</programlisting>

or like this supplying the value for the optional parameter s:

<programlisting>
binaryfile mybf = myproc1 (1, s="bar");
</programlisting>

			</para>
			
			<para>
The body of an atomic procedure specifies how to invoke an
external executable program or Web Service, and how logical data
types are mapped to command line arguments or SOAP messages. A
complete specification for myproc1 can be:

<programlisting>
(binaryfile bf) myproc1 (int i, string s="foo") {
	app {
		myapp1 i s @filename(bf);
	}
}			
</programlisting>

Which specifies that myproc1 invokes an executable, passing the values
of i, s and the file name of bf as command line arguments. The
@filename notation serves as a mapping function denoting that the
argument should be mapped as a file name, and since the notation is
often required in invoking applications, often we can omit the
filename part and use the @ sign only.
			</para>

			<para>
A compound procedure contains a set of calls to other procedures. Shared
variables in the body of a compound procedure specify data dependencies
and thus the execution sequence of the procedure calls. For simple 
illustration, we define a compound procedure in below:

<programlisting>
(type2 b) foo_bar (type1 a) {
	type3 c;
	c = foo(a);    // c holds the result of foo
	b = bar(c);    // c is an input to bar
}
</programlisting>
		</para>
		</sect2>
		
		<sect2>
			<title>Control Constructs</title>
			<para>
Control constructs are special control entities in a workflow to 
control the direction of execution. SwiftScript provides if, switch,
foreach, and while constructs, with syntax and semantics similar
to comparable constructs in other high-level languages.
			</para>
			<sect3><title>foreach</title>
			<para>
The foreach construct is used to apply a block of statements to
each element in a dataset.
We illustrate the use of the foreach
construct in the following example:

<programlisting>
check_order (file a[]) {
	foreach file f in a {
		compute(f);
	}
}
</programlisting>

foreach statements have the general form:

<programlisting>
foreach (type) controlvariable in expression {
    statements
}
</programlisting>

The block of statements is evaluated once for each element in 'expression',
with the controlvariable set to the corresponding element.

			</para>
			</sect3>

			<sect3><title>if</title>
			<para>
The 'if' statement allows one of two blocks of statements to be
executed, based on a boolean predicate. 'if' statements generally
have the form:
<programlisting>
if(predicate) {
    statements
} else {
    statements
}
</programlisting>

where predicate is a boolean expression.
			</para>
			</sect3>

			<sect3><title>switch</title>
			<para>
Switch expressions allow one of a selection of blocks to be chosen based on
the value of a numerical control expression. Switch statements take the
general form:
<programlisting>
switch(controlExpression) {
    case n1:
        statements2
    case n2:
        statements2
    [...]
    default:
        statements
}
</programlisting>
The control expression is evaluated and the resulting numerical value used to
select a corresponding case, and the statements belonging to that case
are evaluated. If no case corresponds, then the statements belonging to
the default block are evaluated.
			</para>
			</sect3>

		</sect2>
	</sect1>
	
	<sect1>
		<title> Simple Examples </title>
		
		<sect2>
		<title>Hello World</title>
		
		<para>
The hello world example calls to the UNIX command echo to print
the text "hello world" and redirect the standard output into a
file. Note that the echo command in the procedure body is only
a logical command and needs to be mapped to an executable by means 
of a transformation catalog.

<programlisting>
type file {} //define a type for file
(file t) echo (string s) { //procedure declaration
	app {
		echo s stdout=@filename(t); //redirect stdout to a file
	}
}

file hw = echo("hello world"); //procedure call
</programlisting>

		</para>
		</sect2>	
	</sect1>

	<sect1>
		<title>Mappers</title>
		<para>
While we can define logical dataset types and procedures in SwiftScript,
we need ways to access physical data when we invoke a procedure or execute 
a workflow, and mappers help us to do that. A logical dataset can be 
physically stored in different kinds of format, for instance, in a plain 
text file, in a spreadsheet, or in a database. A mapper transforms a dataset's
logical representation from/to its physical representation.
		</para>
		<para>
Swift provides a number of mappers that are useful in common cases. This
section details those standard mappers. For more complex cases, it is
possible to write application-specific mappers in Java and
use them within a SwiftScript program. For more information on writing
an application specific mapper, see the tutorial module on mappers.
		</para>

		<sect2><title>Mapper Initialization</title>
		<para>
Since each mapper is associated with a dataset, a mapper is initialized 
together with its dataset. When a workflow is executed, each input
datasets are evaluated and initialized first, and exceptions will be
thrown if there are any problems in locating mappers or accessing physical
data storage.
		</para>
		</sect2>

		<sect2><title>The single file mapper</title>
		
	<itemizedlist>
	<listitem>Name: single_file_mapper</listitem>
	<listitem>Description:
A single file mapper maps a single physical file to a dataset.
	</listitem>
	<listitem>Parameter:
		<itemizedlist>
		<listitem>file:
			The location of the physical file including path and file name.
		</listitem>
		</itemizedlist>
	</listitem>

	<listitem> Example:
			<programlisting>
	file f &lt;single_file_mapper;file="plot_outfile_param"&gt;;
			</programlisting>

There is a simplified syntax for this mapper:


			<programlisting>
	file f &lt;"plot_outfile_param"&gt;;
			</programlisting>
    </listitem>
	</itemizedlist>
	</sect2>

	<sect2><title>The simple mapper</title>
	<itemizedlist>
	<listitem>Name: simple_mapper</listitem>
	<listitem>Description:
A mapper that maps a file or a list of files into an array
by prefix, suffix, and pattern.
If more than one file is matched, each of the file names will
be mapped as a subelement of the dataset.
	</listitem>
	<listitem>Parameter:
		<itemizedlist>
		<listitem>location:
			A directory that the files are located.
		</listitem>
		<listitem>prefix:
			The prefix of the files
		</listitem>
		<listitem>suffix:
			The suffix of the files, for instance: &quot;.txt&quot;
		</listitem>
		<listitem>pattern:
A UNIX glob style pattern, for instance: &quot;*foo*&quot; would match 
all file names that contain foo. When this mapper is used to specify
output filenames, pattern is ignored.
		</listitem>
		</itemizedlist>
	</listitem>
	<listitem> Examples:
		<programlisting>
	file f &lt;simple_mapper;prefix="foo", suffix=".txt"&gt;;
			</programlisting>
The above maps all filenames that start with <filename>foo</filename> and
have an extension <filename>.txt</filename> into file f.
	</listitem>

	<listitem>
	<programlisting>
type messagefile;

(messagefile t) greeting(string m) {.
    app {
        echo m stdout=@filename(t);
    }
}

messagefile outfile &lt;simple_mapper;prefix="foo",suffix=".txt"&gt;;

outfile = greeting("hi");
	</programlisting>

This will output the string 'hi' to the file <filename>foo.txt</filename>.
	</listitem>

	<listitem>
The simple_mapper can be used to map arrays. It will map the array index
into the filename between the prefix and suffix.

<programlisting>
type messagefile;

(messagefile t) greeting(string m) { 
    app {
        echo m stdout=@filename(t);
    }
}

messagefile outfile[] &lt;simple_mapper;prefix="baz",suffix=".txt"&gt;;

outfile[0] = greeting("hello");
outfile[1] = greeting("middle");
outfile[2] = greeting("goodbye");
</programlisting>

This will output the string &quot;hello&quot; into a file
called <filename>baz.0.txt</filename>, the string &quot;middle&quot;
into <filename>baz.1.txt</filename> and the string &quot;goodbye&quot;
into <filename>baz.2.txt</filename>.

	</listitem>

	<listitem>
simple_mapper can be used to map structures. It will map the name of the
structure member into the filename, between the prefix and the
suffix.

	<programlisting>
type messagefile;

type mystruct {
  messagefile left;
  messagefile right;
};

(messagefile t) greeting(string m) { 
    app {
        echo m stdout=@filename(t);
    }
}

mystruct out &lt;simple_mapper;prefix="qux",suffix=".txt"&gt;;

out.left = greeting("hello");
out.right = greeting("goodbye");
	</programlisting>

This will output the string &quot;hello&quot; into the file
<filename>qux.left.txt</filename> and the string &quot;goodbye&quot;
into the file <filename>qux.right.txt</filename>.

	</listitem>

	</itemizedlist>
	</sect2>

	<sect2><title>concurrent mapper</title>
	<itemizedlist>
	<listitem>Name: concurrent_mapper</listitem>
	<listitem>Description:
Concurrent mapper is almost the same as the simple mapper,
except that it is used to map an output file, and the filename
generated will contain an extract sequence that is unique.
This mapper is the default mapper for variables when no mapper is
specified.
	</listitem>
		<listitem>Parameter:
		<itemizedlist>
		<listitem>location:
			A directory that the files are located.
		</listitem>
		<listitem>prefix:
			The prefix of the files
		</listitem>
		<listitem>suffix:
			The suffix of the files, for instance: &quot;.txt&quot;
		</listitem>
		<listitem>pattern:
A UNIX glob style pattern, for instance: &quot;*foo*&quot; would
match all file names that contain foo. When this mapper is used
to specify output filenames, pattern is ignored.
		</listitem>
		</itemizedlist>
	</listitem>
	<listitem> Example:
		<programlisting>
	file f1;
	file f2 &lt;concurrent_mapper;prefix="foo", suffix=".txt"&gt;;
			</programlisting>
The above example would use concurrent mapper for f1 and f2, and 
generate f2 filename with prefix &quot;foo&quot; and extension &quot;.txt&quot;
	</listitem>
	</itemizedlist>
	</sect2>

	<sect2><title>file system mapper</title>
<para>TODO: note on difference between location as a relative vs absolute
path wrt staging to remote location - as mihael said:
It's because you specify that location in the mapper. Try location="."
instead of location="/sandbox/..."</para>
	<itemizedlist>
	<listitem>Name: filesys_mapper</listitem>
    <listitem>Description:
This mapper is similar to the simple mapper, but maps a file or 
a list of files to a dataset array. Each of the filenames would
be mapped as an element in the array.
	</listitem>
		<listitem>Parameter:
		<itemizedlist>
		<listitem>location:
			A directory that the files are located.
		</listitem>
		<listitem>prefix:
			The prefix of the files
		</listitem>
		<listitem>suffix:
			The suffix of the files, for instance: &quot;.txt&quot;
		</listitem>
	<listitem>pattern:
A UNIX glob style pattern, for instance: &quot;*foo*&quot; would
match all file names that contain foo.

		</listitem>
		</itemizedlist>
	</listitem>

	<listitem> Example:
			<programlisting>
	file texts[] &lt;filesys_mapper;prefix="foo", suffix=".txt"&gt;;
			</programlisting>
The above example would map all filenames that start with &quot;foo&quot; 
and have an extension &quot;.txt&quot; into the array texts.
	</listitem>
	</itemizedlist>
	</sect2>

	<sect2><title>fixed array mapper</title>
	<itemizedlist>
	<listitem>Name: fixed_array_mapper</listitem>
    <listitem>Description:
This mapper maps from a string that contains a list of filenames 
into a file array.
	</listitem>
	<listitem>Parameter:
		<itemizedlist>
		<listitem>files:
A string that contains a list of filenames, separated by space, comma or colon
		</listitem>
		</itemizedlist>
	</listitem>

	<listitem> Example:
			<programlisting>
	file texts[] &lt;fixed_array_mapper;files="file1.txt, file2.txt, file3.txt"&gt;;
			</programlisting>
	</listitem>
	</itemizedlist>
	</sect2>

	<sect2><title>array mapper</title>
	<itemizedlist>
	<listitem>Name: array_mapper</listitem>
	<listitem>Description: This mapper froms an array of strings into a file
array.</listitem>
	<listitem>Parameter: 
		<itemizedlist>
		<listitem>files:
An array of strings containing one filename per element</listitem>
		</itemizedlist>
	</listitem>
	</itemizedlist>
	</sect2>

	<sect2><title>regular expression mapper</title>
	<itemizedlist>
	<listitem>Name: regexp_mapper</listitem>
	<listitem>Description:
This mapper transforms one file name to another using
regular expression matching.
	</listitem>
	<listitem>Parameter:
		<itemizedlist>
		<listitem>source:
		The source file name
		</listitem>
		<listitem>match:
Regular expression pattern to match, use ( ) to match whatever regular
expression is inside the parentheses, and indicate the start and end
of a group; the contents of a group can be retrieved with the
<emphasis>\number</emphasis> special sequence
		</listitem>
		<listitem>transform:
The pattern of the file name to transform to, use
<emphasis>\number</emphasis> to reference the group matched.
		</listitem>
		</itemizedlist>
	</listitem>

	<listitem> Example:
			<programlisting>
	file f &lt;regexp_mapper;source=@f,match="(.*)gif",transform="\1jpg"&gt;;
			</programlisting>
This example transforms a file ending with &quot;gif&quot; into one 
ending with &quot;jpg&quot;, where <emphasis>\1</emphasis> refers to
the first group matched.
	</listitem>
	</itemizedlist>
	</sect2>

	<sect2><title>csv mapper</title>
	<itemizedlist>
	<listitem>Name: csv_mapper</listitem>
	<listitem>Description:
This mapper maps the content of a CSV (comma-separated value) file into 
a dataset array. The dataset type needs to be correctly defined to 
conform to the column names in the file. For instance, if the file
contains columns:
		<para>name age GPA</para>
		then the type needs to have the same member elements, say:
		<programlisting>
		type student {
			string name;
			int    age;
			float  GPA;
		}
		</programlisting>
if the file does not contain a header with column info, then the
column names are assumed as &quot;column1&quot;, &quot;column2&quot;,
	</listitem>
	<listitem>Parameter:
		<itemizedlist>
		<listitem>file:
The name of the file to read from.
		</listitem>
		<listitem>header:
whether the file has a line describing header info; default is true
		</listitem>
		<listitem>skip:
The number of lines to skip at the beginning (after header line); default is 0.
		</listitem>
		<listitem>hdelim:
Header field delimiter; default is the value of the "delim" parameter
		</listitem>
		<listitem>delim:
Content field delimiter; default is space, tab and comma.
		</listitem>
		</itemizedlist>
	</listitem>

	<listitem> Example:
			<programlisting>
	student stus[] &lt;csv_mapper;file="stu_list.txt"&gt;;
			</programlisting>
The above example would read a list of student info from file 
&quot;stu_list.txt&quot; and map them into a student array. By default, 
the file should contain a header line specifying the names of the columns.
    </listitem>
	</itemizedlist>
	</sect2>

	</sect1>
	
	<sect1 id="engineconfiguration">	
	
		<title>Swift Engine Configuration</title>
		
		<para>
		
			Various aspects of the behavior of the Swift Engine can be
			configured through properties. The Swift Engine recognizes a global,
			per installation properties file which can found in <filename
			class="file">$SWIFT_HOME/etc/swift.properties</filename> and a user
			properties file which can be created by each user in <filename
			class="file">~/.swift/swift.properties</filename>. The Swift Engine
			will first load the global properties file. It will then try to load
			the user properties file. If a user properties file is found,
			individual properties explicitly set in that file will override the
			respective properties in the global properties file. Furthermore,
			some of the properties can be overridden directly using command line
			arguments to the <link
			linkend="swiftcommand"><command>swift</command> command</link>.
		
		</para>
		
		<sect2 id="properties">
		
			<title>Swift Properties</title>
			
			<para>
			
				Swift properties are specified in the following format:
				
<programlisting>
&lt;name&gt;=&lt;value&gt;
</programlisting>
			
				The value can contain variables which will be expanded when the
				properties file is read. Expansion is performed when the name of
				the variable is used inside the "standard" shell dereference
				construct: ${<varname>name</varname>}. The following variables
				can be used in the Swift configuration file:
				
				<variablelist>
					<title>Swift Configuration Variables</title>
					
					<varlistentry>
						<term>
							<varname>swift.home</varname>
						</term>
						<listitem>
							<para>
							
								Points to the Swift installation directory
								(<filename
								class="directory"><envar>$SWIFT_HOME</envar></filename>).
							
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<varname>user.name</varname>
						</term>
						<listitem>
							<para>
							
								The name of the current logged in user.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<varname>user.home</varname>
						</term>	
						<listitem>
							<para>
							
								The user's home directory.
								
							</para>
						</listitem>
					</varlistentry>
				</variablelist>
				
				The following is a list of valid Swift properties:
				
				<variablelist>
					<title>Swift Properties</title>
					
					<varlistentry>
						<term>
							<property>sites.file</property>
						</term>
						<listitem>
							
							<para>
								Valid values: <parameter>&lt;file&gt;</parameter>
							</para>
							
							<para>
								Default value: ${<varname>swift.home</varname>}<literal>/etc/sites.xml</literal>
							</para>
						
							<para>
							
								Points to the location of the pool file (site
								catalog) which contains a list of all sites that
								Swift should use, together with information about
								the installed services. Details about the format
								of the pool file can be found <ulink
								url="http://vds.uchicago.edu/vds/doc/userguide/html/H_SiteCatalog.html">here</ulink>.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>tc.file</property>
						</term>
						<listitem>
							<para>
								Valid values: <parameter>&lt;file&gt;</parameter>
							</para>
							
							<para>
								Default value: ${<varname>swift.home</varname>}<literal>/etc/tc.data</literal>
							</para>
						
							<para>
							
								Points to the location of the transformation
								catalog file which contains information about
								installed applications. Details about the format
								of the transformation catalog can be found
								<ulink
								url="http://vds.uchicago.edu/vds/doc/userguide/html/H_TransformationCatalog.html">here</ulink>.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>ip.address</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;ipaddress&gt;</parameter>
							</para>
							
							<para>
								Default value: N/A
							</para>
						
							<para>
							
								The Globus GRAM service uses a callback
								mechanism to send notifications about the status
								of submitted jobs. The callback mechanism
								requires that the Swift client be reachable from
								the hosts the GRAM services are running on.
								Normally, Swift can detect the correct IP address
								of the client machine. However, in certain cases
								(such as the client machine having more than one
								network interface) the automatic detection
								mechanism is not reliable. In such cases, the IP
								address of the Swift client machine can be
								specified using this property. The value of this
								property must be a numeric address without quotes.
								
							</para>
						</listitem>
					</varlistentry>
					
					
					<varlistentry>
						<term>
							<property>lazy.errors</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <literal>true</literal>, <literal>false</literal>
							</para>
							
							<para>
								Default value: <literal>true</literal>
							</para>
						
							<para>
							
								Swift can report application errors in two
								modes, depending on the value of this property.
								If set to <constant>false</constant>, Swift will
								report the first error encountered and
								immediately stop execution. If set to
								<constant>true</constant>, Swift will attempt to
								run as much as possible from a workflow before
								stopping execution and reporting all errors
								encountered.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>caching.algorithm</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <literal>LRU</literal>
							</para>
							
							<para>
								Default value: <literal>LRU</literal>
							</para>
						
							<para>
							
								Swift caches files that are staged in on remote
								resources, and files that are produced remotely
								by applications, such that they can be re-used
								if needed without being transfered again.
								However, the amount of remote file system space
								to be used for caching can be limited using the
								<property>swift:storagesize</property> profile
								entry in the sites.xml file. Example:
								
<programlisting>

&lt;pool handle="example" sysinfo="INTEL32::LINUX"&gt;
	&lt;gridftp url="gsiftp://example.org" storage="/sratch/swift" major="2" minor="4" patch="3"/&gt;
	&lt;jobmanager universe="vanilla" url="example.org/jobmanager-pbs" major="2" minor="4" patch="3"/&gt;
	&lt;workdirectory&gt;/scratch/swift&lt;/workdirectory&gt;
	&lt;profile namespace="SWIFT" key="storagesize"&gt;20000000&lt;/profile&gt;
&lt;/pool&gt;

</programlisting>
								
								
								The decision of which files to keep in the cache
								and which files to remove is made considering
								the value of the
								<property>caching.algorithm</property> property. 							
								Currently, the only available value for this 							
								property is <literal>LRU</literal>, which would
								cause the least recently used files to be
								deleted first.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>pgraph</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <literal>true</literal>, <literal>false</literal>, <parameter>&lt;file&gt;</parameter>
							</para>
							
							<para>
								Default value: <literal>false</literal>
							</para>
							
							<para>
							
								Swift can generate a graphviz file representing 
								the structure of the workflow it runs. If this
								property is set to <literal>true</literal>,
								Swift will save the provenance graph in a file
								named by concatenating the workflow name and the
								instance ID (e.g. <filename
								class="file">helloworld-ht0adgi315l61.dot</filename>). 
							</para>
							<para>
								If set to <literal>false</literal>, no
								provenance  graph will be generated. If a file
								name is used, then  the provenance graph will be
								saved in the specified file.
							</para>
							<para>
								The generated dot file can be rendered
								into a graphical form using
								<ulink
								url="http://www.graphviz.org">Graphviz</ulink>,
								for example with a command-line such as:
							</para>
							<programlisting>
								swift -pgraph graph1.dot q1.swift
								dot -ograph.png -Tpng graph1.dot
							</programlisting>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>pgraph.graph.options</property>
						</term>
						<listitem>
							
							<para>
								Valid values: <parameter>&lt;string&gt;</parameter>
							</para>
							
							<para>
								Default value: <literal>splines="compound", rankdir="TB"</literal>
							</para>
						
							<para>
							
								This property specifies a <ulink
								url="http://www.graphviz.org">Graphviz</ulink>
								specific set of parameters for the graph.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>pgraph.node.options</property>
						</term>
						<listitem>
							
							<para>
								Valid values: <parameter>&lt;string&gt;</parameter>
							</para>
							
							<para>
								Default value: <literal>color="seagreen", style="filled"</literal>
							</para>
						
							<para>
							
								Used to specify a set of <ulink
								url="http://www.graphviz.org">Graphviz</ulink>
								specific properties for the nodes in the graph.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>clustering.enabled</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <literal>true</literal>, <literal>false</literal>
							</para>
							
							<para>
								Default value: <literal>true</literal>
							</para>
							
							<para>
							
								Clustering enables sending of short jobs to
								remote resources in a single request in order to
								minimize various overheads involved in launching
								jobs. Clustering works in the following way: If
								a job is clusterable (meaning that it has the
								<property>GLOBUS::maxwalltime</property> profile
								specified in <filename
								type="file">tc.data</filename> and its value is
								less than the value of the Swift
								<property>min.cluster.time</property> property -
								described below) it will be put in a clustering
								queue. The queue is processed at intervals 
								specified by the
								<property>clustering.queue.delay</property>
								property (also described below). The processing
								of the clustering queue consists of selecting
								compatible jobs and grouping them in clusters
								whose max wall time does not exceed twice the
								value of the
								<property>clustering.min.time</property>
								property. Two or more jobs are  considered
								compatible if they share the same site and do
								not have conflicting profiles (e.g. different
								values for the same environment variable). 

							</para>
							
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>clustering.queue.delay</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;int&gt;</parameter>
							</para>
							
							<para>
								Default value: <literal>4</literal>
							</para>
							
							<para>
							
								This property indicates the interval, in
								seconds, at which the clustering queue is
								processed.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>clustering.min.time</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;int&gt;</parameter>
							</para>
							
							<para>
								Default value: <literal>60</literal>
							</para>
						
							<para>
							
								Indicates the threshold wall time for
								clustering. Jobs that have a wall time smaller
								than the value of this property will be tagged
								for clustering.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>kickstart.enabled</property>
						</term>
						<listitem>
							
							<para>
								Valid values: <literal>true</literal>, <literal>false</literal>, <literal>maybe</literal>
							</para>
							
							<para>
								Default value: <literal>maybe</literal>
							</para>
								
							<para>
								
								This option allows controlling of
								when Swift uses <link linkend="kickstart">Kickstart</link>. A value of
								<literal>false</literal> disables the use of
								Kickstart, while a value of
								<literal>true</literal> enables the use of
								Kickstart, in which case sites specified in the
								<filename type="file">sites.xml</filename> file
								must have valid
								<parameter>gridlaunch</parameter> attributes.
								The <literal>maybe</literal> value will
								enable the use of Kickstart only
								on sites that have the
								<parameter>gridlaunch</parameter> attribute
								specified.

							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>kickstart.always.transfer</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <literal>true</literal>, <literal>false</literal>
							</para>
							
							<para>
								Default value: <literal>false</literal>
							</para>
							
							<para>
							
								This property controls when output from
								Kickstart is transfered back to the submit site,
								if Kickstart is enabled. When set to
								<literal>false</literal>, Kickstart output is
								only transfered for jobs that fail. If set to
								<literal>true</literal>, Kickstart output is
								transfered after every job is completed or
								failed.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>throttle.submit</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;int&gt;</parameter>, <parameter>off</parameter>
							</para>
							
							<para>
								Default value: <literal>4</literal>
							</para>
						
							<para>
							
								Limits the number of concurrent submissions for
								a workflow instance. This throttle only limits
								the number of concurrent tasks (jobs) that are
								being sent to sites, not the total number of
								concurrent jobs that can be run. The submission
								stage in GRAM is one of the most CPU expensive
								stages (due mostly to the mutual authentication
								and delegation). Having too many  concurrent
								submissions can overload either or both the
								submit host CPU and the remote host/head node
								causing degraded performance.
								
							</para>
							
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>throttle.host.submit</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;int&gt;</parameter>, <parameter>off</parameter>
							</para>
							
							<para>
								Default value: <literal>2</literal>
							</para>
							
							<para>
							
								Limits the number of concurrent submissions for
								any of the sites Swift will try to send jobs to.
								In other words it guarantees that no more than
								the  value of this throttle jobs sent to any
								site will be concurrently in a state of being
								submitted.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>throttle.transfers</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;int&gt;</parameter>, <parameter>off</parameter>
							</para>
						
							<para>
								Default value: <literal>4</literal>	
							</para>
							
							<para>
							
								Limits the total number of concurrent file
								transfers that can happen at any given time.
								File transfers consume bandwidth. Too many
								concurrent transfers can cause the network to be
								overloaded preventing various other signaling
								traffic from flowing properly.
								
							</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<property>throttle.file.operations</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;int&gt;</parameter>, <parameter>off</parameter>
							</para>
							
							<para>
								Default value: <literal>8</literal>
							</para>
							
							<para>
							
								Limits the total number of concurrent file
								operations that can happen at any given time.
								File operations (like transfers) require an
								exclusive connection to a site. These
								connections can be expensive to establish. A
								large number of concurrent file operations may
								cause Swift to attempt to establish many  such
								expensive connections to various sites. Limiting
								the number of concurrent file operations causes
								Swift to use a small number of cached
								connections and achieve better overall
								performance. 
								
							</para>
						</listitem>
					</varlistentry>
	
				
					<varlistentry>
						<term>
							<property>throttle.score.job.factor</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;int&gt;</parameter>, <parameter>off</parameter>
							</para>
							
							<para>
								Default value: <literal>4</literal>
							</para>
							
							<para>
								The Swift scheduler has the ability to limit
								the number of concurrent jobs allowed on a
								site based on the performance history of that
								site. Each site is assigned a score (initially
								1), which can increase or decrease based on
								whether the site yields successful or faulty
								job runs. The score for a site can take values
								in the (0.1, 100) interval. The number of
								allowed jobs is calculated using the
								following formula:
							</para>
							<para>
								2 + score*throttle.score.job.factor 
							</para>
							<para>
								This means a site will always be allowed
								at least two concurrent jobs and at most
								2 + 100*throttle.score.job.factor. With a
								default of 4 this means at least 2 jobs and
								at most 402. 
							</para>
						</listitem>
					</varlistentry>
										
				</variablelist>
				
				Example:
				
<programlisting>
sites.file=${vds.home}/etc/sites.xml
tc.file=${vds.home}/etc/tc.data
ip.address=192.168.0.1
</programlisting>
			
			</para>
		
		</sect2>
		
	</sect1>

	<sect1 id="swiftcommand">
	<title>The swift command</title>
	<para>
The swift command is the main command line tool for executing SwiftScript
programs.
	</para>
	<sect2><title>Syntax</title>
<para>
Command-line syntax can be seen by typing swift -help
</para>
	</sect2>
	<sect2><title>Return codes</title>
	<para>
The swift command may exit with the following return codes:
<itemizedlist>
<listitem>0 - success</listitem>
<listitem>1 - command line syntax error or missing project name</listitem>
<listitem>2 - error during workflow execution</listitem>
<listitem>3 - error during compilation of SwiftScript program</listitem>
<listitem>4 - input file does not exist</listitem>
</itemizedlist>
	</para>
	</sect2>
	</sect1>

	<sect1 id="kickstart"> <title>Kickstart</title>.
		<para>

Kickstart is a tool that can be used to gather various information 
about the remote execution environment for each job that Swift tries
to run.
		</para>

		<para>
For each job, Kickstart generates an XML <firstterm>invocation
record</firstterm>. By default this record is staged back to the submit
host if the job fails.
		</para>

		<para>
Before it can be used it must be installed on the remote site and
the sites file must be configured to point to kickstart.
		</para>

		<para>
Kickstart can be downloaded as part of the VDS 'worker package' available
from the worker packages section of <ulink url="http://www.ci.uchicago.edu/wiki/bin/view/VDS/VDSWeb/VDSDownload">the VDS download page</ulink>.
		</para>
		<para>
Untar the relevant worker package somewhere where it is visible to the
worker nodes on the remote execution machine (such as in a shared application
filesystem).
		</para>

<para>Now configure the gridlaunch attribute of the sites catalog
to point to that path, by adding a <parameter>gridlaunch</parameter>
attribute to the <function>pool</function> element in the site
catalog:

<programlisting>

&lt;pool handle="example" gridlaunch="/usr/local/bin/kickstart" sysinfo="INTEL32::LINUX"&gt;
[...]
&lt;/pool&gt;

</programlisting>

		</para>

		<para>
There are various kickstat.* properties, which have sensible default
values. These are documented in <link linkend="properties">the
properties section</link>.
		</para>



	</sect1>

	<sect1 id="restart"> <title>Workflow restart/recovery</title>
		<para>
If a workflow fails, Swift can resume that workflow from the point of
failure. If a Swift workflow fails, a restart log file will be generated
using the unique job ID, with a .rlog extension. This restart log
can then be passed to a subsequent swift invocation using the -resume
parameter. Swift will resume executing the workflow. Previously executed
tasks will not be run a second time. The SwiftScript source file should
not be modified between invocations.
		</para>
		<para>
Every execution of a workflow creates a restart
log file with a named composed of the file name of the workflow
being executed, an invocation ID, a numeric ID, and the <filename
class="file">.rlog</filename> extension. For example, <filename
class="file">example.swift</filename>, when executed, could produce
the following restart log file: <filename
class="file">example-ht0adgi315l61.0.rlog</filename>. Normally, if
the workflow completes successfully, the restart log file is
deleted. If however the workflow fails, <command>swift</command>
allows the possibility of using the restart log file to continue the
execution of the workflow from the last consistent point before the
failure occurred. In order to restart a workflow from a restart log
file, the <option>-resume <parameter><filename
class="file">logfile</filename></parameter></option> argument can be
used after the compiled workflow file name. Example:

<screen>
<prompt>&gt;</prompt> <command>swift</command> <option>-resume <filename
class="file">example-ht0adgi315l61.0.rlog</filename></option> <option><filename
class="file">example.swift</filename></option>.
</screen>

		</para>
	</sect1> 

	<sect1> <title>Invoking an application from Swift</title>.
	<para>
There are certain requirements for invoking application code from Swift,
mostly related to their treatment of input and output data.
	</para>
	</sect1>

	<sect1> <title>Technical overview of the Swift architecture</title>
	<para>
This section attempts to provide a technical overview of the Swift
architecture.
	</para>

	<sect2><title>karajan - the core execution engine</title>
	</sect2>

	<sect2><title>Execution layer</title>
	<para>
The execution layer causes an application program (in the form of a unix
executable) to be executed either locally or remotely.
	</para>
	<para>
Two main choices - local unix fork() and Globus GRAM (in various verions).
CoG provides plug-in support here [link to that] to allow other
execution layers to be plugged in. [can karajan use any cog execution
layer?]
	</para>
	<para>
Additionally, the kickstart utility can be used (in both fork and
GRAM mode) to capture environmental information at execution time
to aid in debugging and provenance capture. See the kickstart
chapter for information about using kickstart.
	</para>
	</sect2>

	<sect2><title>SwiftScript language compilation layer</title>
	<para>
Step i: text to XML intermediate form parser/processor. parser written in
ANTLR - see resources/VDL.g. The XML Schema Definition (XSD) for the
intermediate language is in resources/XDTM.xsd.
	</para>
	<para>
Step ii: XML intermediate form to Karajan workflow. Karajan.java - reads
the XML intermediate form. compiles to karajan workflow language - for
example, expressions are converted from SwiftScript syntax into Karajan
syntax, and function invocations become karajan function invocations
with various modifications to parameters to accomodate return parameters
and dataset handling.
	</para>
	</sect2>

	<sect2><title>Swift/karajan library layer</title>
	<para>
Some Swift functionality is provided in the form of Karajan libraries
that are used at runtime by the Karajan workflows that the Swift
compiler generates.
	</para>
	</sect2>

	</sect1>

	<sect1><title>Ways in which Swift can be extended</title>
<para>Swift is extensible in a number of ways. It is possible to add
mappers to accomodate different filesystem arrangements, site selectors
to change how Swift decides where to run each job, and job submission
interfaces to submit jobs through different mechanisms.
</para>
<para>A number of mappers are provided as part of the Swift release. These
are documented in the section above on mappers. New mappers can be implemented
in Java by implementing the org.griphyn.vdl.mapping.Mapper interface. The
Swift tutorial contains a simple example of this.
</para>
<para>Swift provides a default site selector, the VDS Adaptive Scheduler.
Additional site selectors can be plugged in by implementing the
org.globus.cog.karajan.scheduler.Scheduler interface and modifying
libexec/scheduler.xml and etc/karajan.properties to refer to the new
scheduler.
</para>
<para>There are two execution providers that are supported in the release,
the local provider (for local execution on the host that Swift is running
on) and the GRAM provider (for execution using GRAM2 gatekeepers).
In principle any execution provider supported by the Java CoG kit will
work.
</para>
	</sect1>

	<sect1><title>Function reference</title>
		<para>
This section details functions that are available for use in the SwiftScript
language.
		</para>
		<sect2><title>@arg</title>
			<para>
Takes a command line parameter name as a string parameter and returns the
name of that string parameter from the command line.
			</para>

			<para>For example:</para>
			<programlisting>
print(@arg("myparam"));
			</programlisting>
			<screen>
$ swift arg.swift -myparam=hello 
Swift v0.2-dev

RunID: p08an4d5yr6g2
hello
			</screen>

		</sect2>
		<sect2><title>@filename</title>
			<para>
@filename(v) will return a string containing the filename(s) for the file(s)
mapped to the variable v. When more than one filename is returned, the
filenames will be space separated inside a single string return value.
			</para>
		</sect2>
		<sect2><title>@filenames</title>
			<para>
@filenames(v) will return multiple values (!) containing the filename(s) for
the file(s) mapped to the variable v. (compare to @filename)
			</para>
		</sect2>
		<sect2><title>@strcat</title>
			<para>
@strcat(a,b,c,d,...) will return a string containing all of the strings
passed as parameters joined into a single string. There may be any number
of parameters.
			</para>
		</sect2>
		<sect2><title>@strcut</title>
			<para>
@strcut(input,pattern) will match the regular expression in the pattern
parameter against the supplied input string and return the section that
matches the first matching parenthesised group.
			</para>
			<para>
For example:
			</para>

			<programlisting>
string t = "my name is John and i like puppies.";
string name = @strcut(t, "my name is ([^ ]*) ");
string out = @strcat("Your name is ",name);
print(out);
			</programlisting>

			<para>
will output the message 'Your name is John'.
			</para>
		</sect2>
	</sect1>

	<sect1><title>Built-in procedure reference</title>
		<para>
This section details built-in procedures that are available for use in
the SwiftScript language.
		</para>
		<sect2><title>print</title>
			<para>
print will output its argument to stdout.
			</para>
		</sect2>
	</sect1>

</article>

