<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [] >

<article>
	<articleinfo revision="0.1">
		<title>Swift User Guide</title>
		<subtitle>Source control $LastChangedRevision$</subtitle>
	</articleinfo>

	<section>
		<title>Overview</title>
		<para>
This manual provides reference material for Swift: the SwiftScript language
and the Swift runtime system. For introductory material, consult
the <ulink url="http://www.ci.uchicago.edu/swift/guides/tutorial.php">Swift
tutorial</ulink>.
	</para>
	<para>
Swift is a data-oriented coarse grained scripting language that
supports dataset typing and mapping, dataset iteration,
conditional branching, and sub-workflow composition.
	</para>
	<para>
Swift programs (or <firstterm>workflows</firstterm>) are written in
a language called <firstterm>SwiftScript</firstterm>.
	</para>
	<para>
SwiftScript programs are dataflow oriented - they are primarily
concerned with processing (possibly large) data files, by invoking
programs to do that processing. Swift handles execution of such programs
on remote sites by choosing sites, handling the staging of input and output
files to and from the chosen sites and remote execution of program code.
	</para>
	</section>
	<section>
		<title>The SwiftScript Language</title>
<section><title>Data model</title>
<para>Data processed by Swift is strongly typed. It may be take the form
of values in memory or as out-of-core files on disk. Language constructs
called mappers specify how each piece of data is stored.</para>
		<section>
			<title>Data</title>
<para>
Data is represented in Swift by
<firstterm>DSHandles</firstterm> (<firstterm>Dataset handles</firstterm>).
</para>

<para>
In Swift, a DSHandle can represent data in one of three forms:
</para>
<orderedlist>
<listitem> <para>
an in-memory value, such as a string or integer.
</para> </listitem>
<listitem> <para>
a data file (on local disk or stored elsewhere on the internet). When a
DSHandle represents an on-disk data file, the name of that file is
provided by a <firstterm>mapper</firstterm>.
</para> </listitem>
<listitem> <para>
a container of other DSHandles - either an array or a defined type.
Such a DSHandles contains subordinate DSHandles; these may be nested
to arbitrary depth.
</para> </listitem>
</orderedlist>
<para>
The above three are mutually exclusive - for example, a data set
that is mapped to a file cannot have a value that can be used in a
SwiftScript expression; and a data item that is a
value cannot be passed into an application
executable as a data file using the <link linkend="function.filename">@filename</link> function.
</para>
</section>

<section><title>Mappers</title>
		<para>
When a DSHandle represents a data file (or container of datafiles), it is
associated with  a mapper. The mapper is used to
identify which files belong to that DSHandle.
		</para>
		<para>
A dataset's physical representation is declared by a mapping descriptor, 
which defines how each element in the dataset's logical schema is 
stored in, and fetched from, physical structures such as directories,
files, and remote servers.
</para>

<para>
Mappers are parameterized to take into account properties such as
varying dataset location.
In order
to access a dataset, we need to know three things: its type, 
its mapping, and the value(s) of any parameter(s) associated 
with the mapping descriptor. For example, if we want to describe a dataset,
of type imagefile, and whose physical
representation is a file called "file1.bin" located at "/home/yongzh/data/",
then the dataset might be declared as follows:
</para>

<programlisting>
imagefile f1&lt;single_file_mapper;file="/home/yongzh/data/file1.bin"&gt;
</programlisting>

<para>
The above example declares a dataset called f1, which uses a single 
file mapper to map a file from a specific location.
</para>
<para>
SwiftScript has a simplified syntax for this case, since single_file_mapper 
is frequently used:

<programlisting>
binaryfile f1&lt;"/home/yongzh/data/file1.bin"&gt;
</programlisting>
</para>

<para>
Swift comes with a number of mappers that handle common mapping patterns.
These are documented in the <link linkend="mappers">mappers section</link>
of this guide.
</para>

</section>

<section><title>Execution order based on data dependencies</title>
<para>
Procedures in swift are by default executed in parallel. If five separate
procedures are invoked, Swift will attempt to run them all at once.
</para>
<para>
The main exception to this is when one procedure produces a dataset as an
output and another procedure uses that dataset as an input. In that case,
the second procedure will be executed after the first procedure has
produced the intermediate dataset.
</para>
</section>

		<section>
			<title>Type System</title>
			<para>
The SwiftScript type system consists of a number of <firstterm>simple
types</firstterm>, <firstterm>marker types</firstterm> for files,
arrays, and <firstterm>complex types</firstterm> composed of these types.
			</para>
			<para>
The simple types are: string, float, int and boolean.
			</para>

			<para>
Complex types are specified using the <firstterm>type</firstterm>
keyword. The syntax is similar to struct in C or class in Java.
For example, the below example declares a complex type with two
members, a string called name and an integer called age.
<programlisting>
type person {
	string name;
	int age;
}
</programlisting>
		</para>
		
		<para>
When referring to files on disk, the internal structure of the
file is irrelevant; but it is still useful to declare types for those
files so that Swift can perform type-checking on SwiftScript programs.
In this case, a marker type can be declared, like this:

<programlisting>
type binaryfile;
</programlisting>
		</para>
		</section>
		</section>

		<section><title>Variables</title>
<para>Variables in SwiftScript are declared to be of a specific type.
Assignments to those variables must be data of that type.
SwiftScript variables are single-assignment - a value may be assigned
to a variable at most once. This assignment can happen at declaration time
or later on in execution. When an attempt to read from a variable
that has not yet been assigned is made, the code performing the read
is suspended until that variable has been written to. This forms the
basis for Swift's ability to parallelise execution - all code will
execute in parallel unless there are variables shared between the code
that cause sequencing.</para>

		<section>
			<title>Variable Declarations</title>
			<para>
Variable declaration statements declare new variables. They can
optionally assign a value to them or map those variables to on-disk files.
			</para>
<para>
Declaration statements have the general form:
<programlisting>
  typename variablename (&lt;mapping&gt; | = initialValue ) ;
</programlisting>
The format of the mapping expression is defined in the Mappers section.
initialValue may be either an expression or a procedure call that
returns a single value.
</para>
<para>Variables can also be declared in a multivalued-procedure statement,
described in another section.</para>
		</section>

		<section>
			<title>Assignment Statements</title>
			<para>
Assignment statements assign values to previously declared variables.
Assignments may only be made to variables that have not already been 
assigned. Assignment statements have the general form:

<programlisting>
  variable = value;
</programlisting>
where value can be either an expression or a procedure call that returns
a single value.
			</para>

			<para>
Variables can also be assigned in a multivalued-procedure statement,
described in another section.
			</para>
		</section>

		</section>
		<section>
			<title>Procedures</title>
			<para>
Datasets are operated on by procedures, which take input in the form of 
mapped variables, perform computations, and produce typed data as output
that is again mapped to variables.</para>
<para>There are two kinds of procedure: An atomic procedure, which
describes how an external program can be executed; and compound
procedures which consist of a sequence of SwiftScript statements.
</para>

			<para>
A procedure declaration defines the name of a procedure and its
input and output parameters. SwiftScript procedures can take multiple
inputs and produce multiple outputs.
Inputs are specified to the right of the function name where 
outputs to the left. For instance:

<programlisting>
(type3 out1, type4 out2) myproc (type1 in1, type2 in2)
</programlisting>

The above example declares a procedure called myproc, which 
has two inputs in1 (of type type1) and in2 (of type type2) 
and two outputs out1 (of type type3) and out2 (of type type4).
			</para>
	
			<para>
A procedure input parameter can be an <firstterm>optional
parameter</firstterm> in which case it must be declared with a default
value.  When we call a
procedure, passing in the actual parameters, we allow both positional
parameter and named parameter passing, provided that all optional
parameters have to be declared after the required parameters and any
optional parameter has to be bound using keyword parameter passing.
So for instance if we declare a procedure myproc1:

<programlisting>
(binaryfile bf) myproc1 (int i, string s="foo")
</programlisting>

Then the procedure can be called like this

<programlisting>
binaryfile mybf = myproc1(1);
</programlisting>

or like this supplying the value for the optional parameter s:

<programlisting>
binaryfile mybf = myproc1 (1, s="bar");
</programlisting>

			</para>
			
<section><title>Atomic procedures</title>
			<para>
The body of an atomic procedure specifies how to invoke an
external executable program or Web Service, and how logical data
types are mapped to command line arguments. A complete specification
for myproc1 can be:

<programlisting>
(binaryfile bf) myproc1 (int i, string s="foo") {
	app {
		myapp1 i s @filename(bf);
	}
}			
</programlisting>

which specifies that myproc1 invokes an executable called myapp1,
passing the values of i, s and the file name of bf as command line arguments.
The <link linkend="function.filename">@filename</link> notation serves as a function denoting that the
argument should be mapped as a file name, and since the notation is
often required in invoking applications, a shorter syntax is defined where
we can omit the filename part and use the @ sign only.
			</para>
</section>

<section><title>Compound procedures</title>
			<para>
A compound procedure contains a set of calls to other procedures. Shared
variables in the body of a compound procedure specify data dependencies
and thus the execution sequence of the procedure calls. For simple 
illustration, we define a compound procedure in below:

<programlisting>
(type2 b) foo_bar (type1 a) {
	type3 c;
	c = foo(a);    // c holds the result of foo
	b = bar(c);    // c is an input to bar
}
</programlisting>
		</para>
		</section>
	</section>
		<section>
			<title>Syntax, Statements</title>
<para>The syntax of SwiftScript has a superficial resemblance to C and
Java. For example, { and } characters are used to enclose blocks of
statements.
</para>
			<para>
A SwiftScript program consists of a number of statements.
Statements may declare types, procedures and variables, assign values to
variables, and express operations over arrays.
			</para>
		</section>
		<section>
			<title>Multivalued procedure invocation statements</title>
<para>
Procedures can return more than one value. In such case, the previously
mentioned declaration and assignment statements are insufficient. A
multi-valued procedure invocation can be used. This has the general
form:

<programlisting>
'(' ((type)? variableName ( '=' binding ))+ ')' = procedureinvocation
</programlisting>

Variables can be either declared (if a type is included) or assigned (if
a type is not included). If no bindings are specified, then variables
are assigned in the same order that they are specified in the
procedure declaration. If bindings are specified, then variables are
assigned to the named return parameter.
</para>

		</section>
	
		<section>
			<title>Control Constructs</title>
			<para>
SwiftScript provides if, switch, foreach, and while constructs,
with syntax and semantics similar to comparable constructs in
other high-level languages.
			</para>
			<section><title>foreach</title>
			<para>
The foreach construct is used to apply a block of statements to
each element in an array. For example:

<programlisting>
check_order (file a[]) {
	foreach f in a {
		compute(f);
	}
}
</programlisting>
</para>
<para>
foreach statements have the general form:

<programlisting>
foreach controlvariable (,index) in expression {
    statements
}
</programlisting>

The block of statements is evaluated once for each element in 'expression',
with controlvariable set to the corresponding element and index set to the
integer position in the array that is being iterated over.

			</para>
			</section>

			<section><title>if</title>
			<para>
The 'if' statement allows one of two blocks of statements to be
executed, based on a boolean predicate. 'if' statements generally
have the form:
<programlisting>
if(predicate) {
    statements
} else {
    statements
}
</programlisting>

where predicate is a boolean expression.
			</para>
			</section>

			<section><title>switch</title>
			<para>
Switch expressions allow one of a selection of blocks to be chosen based on
the value of a numerical control expression. Switch statements take the
general form:
<programlisting>
switch(controlExpression) {
    case n1:
        statements2
    case n2:
        statements2
    [...]
    default:
        statements
}
</programlisting>
The control expression is evaluated and the resulting numerical value used to
select a corresponding case, and the statements belonging to that case
are evaluated. If no case corresponds, then the statements belonging to
the default block are evaluated.
			</para>
<para>Unlike C or Java switch statements, execution does not fall through to
subsequent case blocks, and no break statement is necessary at the end
of each block.
</para>
			</section>

			<section id="construct.iterate"><title>iterate</title>
				<para>
Iterate expressions allow a block of code to be evaluated repeatedly, with an
integer parameter sweeping upwards from 0 until a termination condition
holds.
				</para>
				<para>
The general form is:
<programlisting>
iterate var {
	statements;
} until (terminationExpression);
</programlisting>
with the variable var starting at 0 and increasing each iteration. That
variable is in scope in the statements block and when evaluating the
termination expression.
				</para>
			</section>
		</section>

	</section>

		<section id="mappers">
		<title>Mappers</title>
		<para>
Mappers provide a mechanism to specify the layout of mapped datasets on
disk. This is needed when Swift must access files to transfer them to
remote sites for execution or to pass to applications.</para>
		<para>
Swift provides a number of mappers that are useful in common cases. This
section details those standard mappers. For more complex cases, it is
possible to write application-specific mappers in Java and
use them within a SwiftScript program. For more information on writing
an application specific mapper, see the tutorial module on mappers.
		</para>

		<section id="mapper.single_file_mapper"><title>The single file mapper</title>
		
	<itemizedlist>
	<listitem>Name: single_file_mapper</listitem>
	<listitem>Description:
A single file mapper maps a single physical file to a dataset.

		<screen>

    Swift variable -------------------&gt;  Filename

       f                                 myfile

       f[0]                              INVALID

       f.bar                             INVALID

		</screen>
	</listitem>
	<listitem>Parameter:
		<itemizedlist>
		<listitem>file:
			The location of the physical file including path and file name.
		</listitem>
		</itemizedlist>
	</listitem>

	<listitem> Example:
			<programlisting>
	file f &lt;single_file_mapper;file="plot_outfile_param"&gt;;
			</programlisting>

There is a simplified syntax for this mapper:


			<programlisting>
	file f &lt;"plot_outfile_param"&gt;;
			</programlisting>
    </listitem>

	</itemizedlist>
	</section>

	<section id="mapper.simple_mapper"><title>The simple mapper</title>
	<itemizedlist>
	<listitem>Name: simple_mapper</listitem>
	<listitem>Description:
A mapper that maps a file or a list of files into an array
by prefix, suffix, and pattern.
If more than one file is matched, each of the file names will
be mapped as a subelement of the dataset.
	</listitem>
	<listitem>Parameters:
		<itemizedlist>
		<listitem>location:
			A directory that the files are located.
		</listitem>
		<listitem>prefix:
			The prefix of the files
		</listitem>
		<listitem>suffix:
			The suffix of the files, for instance: &quot;.txt&quot;
		</listitem>
		<listitem>pattern:
A UNIX glob style pattern, for instance: &quot;*foo*&quot; would match 
all file names that contain foo. When this mapper is used to specify
output filenames, pattern is ignored.
		</listitem>
		</itemizedlist>
	</listitem>
	<listitem> Examples:
		<programlisting>
	type file;
	file f &lt;simple_mapper;prefix="foo", suffix=".txt"&gt;;
			</programlisting>
The above maps all filenames that start with <filename>foo</filename> and
have an extension <filename>.txt</filename> into file f.

		<screen>

    Swift variable -------------------&gt;  Filename

       f                                 foo.txt

		</screen>
	</listitem>

	<listitem>
	<programlisting>
type messagefile;

(messagefile t) greeting(string m) {.
    app {
        echo m stdout=@filename(t);
    }
}

messagefile outfile &lt;simple_mapper;prefix="foo",suffix=".txt"&gt;;

outfile = greeting("hi");
	</programlisting>

This will output the string 'hi' to the file <filename>foo.txt</filename>.
	</listitem>

	<listitem>
The simple_mapper can be used to map arrays. It will map the array index
into the filename between the prefix and suffix.

<programlisting>
type messagefile;

(messagefile t) greeting(string m) { 
    app {
        echo m stdout=@filename(t);
    }
}

messagefile outfile[] &lt;simple_mapper;prefix="baz",suffix=".txt"&gt;;

outfile[0] = greeting("hello");
outfile[1] = greeting("middle");
outfile[2] = greeting("goodbye");
</programlisting>

		<screen>

    Swift variable -------------------&gt;  Filename

       outfile[0]                        baz0000.txt
       outfile[1]                        baz0001.txt
       outfile[2]                        baz0002.txt

		</screen>

	</listitem>

	<listitem>
simple_mapper can be used to map structures. It will map the name of the
structure member into the filename, between the prefix and the
suffix.

	<programlisting>
type messagefile;

type mystruct {
  messagefile left;
  messagefile right;
};

(messagefile t) greeting(string m) { 
    app {
        echo m stdout=@filename(t);
    }
}

mystruct out &lt;simple_mapper;prefix="qux",suffix=".txt"&gt;;

out.left = greeting("hello");
out.right = greeting("goodbye");
	</programlisting>

This will output the string &quot;hello&quot; into the file
<filename>qux.left.txt</filename> and the string &quot;goodbye&quot;
into the file <filename>qux.right.txt</filename>.

		<screen>

    Swift variable -------------------&gt;  Filename

       out.left                          quxleft.txt
       out.right                         quxright.txt

		</screen>
	</listitem>

	</itemizedlist>
	</section>

	<section id="mapper.concurrent_mapper"><title>concurrent mapper</title>
	<itemizedlist>
	<listitem>Name: concurrent_mapper</listitem>
	<listitem>Description:
Concurrent mapper is almost the same as the simple mapper,
except that it is used to map an output file, and the filename
generated will contain an extract sequence that is unique.
This mapper is the default mapper for variables when no mapper is
specified.
	</listitem>
		<listitem>Parameters:
		<itemizedlist>
		<listitem>location:
			A directory that the files are located.
		</listitem>
		<listitem>prefix:
			The prefix of the files
		</listitem>
		<listitem>suffix:
			The suffix of the files, for instance: &quot;.txt&quot;
		</listitem>
		<listitem>pattern:
A UNIX glob style pattern, for instance: &quot;*foo*&quot; would
match all file names that contain foo. When this mapper is used
to specify output filenames, pattern is ignored.
		</listitem>
		</itemizedlist>
	</listitem>
	<listitem> Example:
		<programlisting>
	file f1;
	file f2 &lt;concurrent_mapper;prefix="foo", suffix=".txt"&gt;;
			</programlisting>
The above example would use concurrent mapper for f1 and f2, and 
generate f2 filename with prefix &quot;foo&quot; and extension &quot;.txt&quot;
	</listitem>
	</itemizedlist>
	</section>

	<section id="mapper.filesys_mapper"><title>file system mapper</title>
<para>TODO: note on difference between location as a relative vs absolute
path wrt staging to remote location - as mihael said:
It's because you specify that location in the mapper. Try location="."
instead of location="/sandbox/..."</para>
	<itemizedlist>
	<listitem>Name: filesys_mapper</listitem>
    <listitem>Description:
This mapper is similar to the simple mapper, but maps a file or 
a list of files to an array. Each of the filename is 
mapped as an element in the array. The order of files in the resulting
array is not defined.
	</listitem>
		<listitem>Parameters:
		<itemizedlist>
		<listitem>location:
			The directory where the files are located.
		</listitem>
		<listitem>prefix:
			The prefix of the files
		</listitem>
		<listitem>suffix:
			The suffix of the files, for instance: &quot;.txt&quot;
		</listitem>
	<listitem>pattern:
A UNIX glob style pattern, for instance: &quot;*foo*&quot; would
match all file names that contain foo.

		</listitem>
		</itemizedlist>
	</listitem>

	<listitem> Example:
			<programlisting>
	file texts[] &lt;filesys_mapper;prefix="foo", suffix=".txt"&gt;;
			</programlisting>
The above example would map all filenames that start with &quot;foo&quot; 
and have an extension &quot;.txt&quot; into the array texts.
For example, if the specified directory contains files: foo1.txt, footest.txt,
foo__1.txt, then the mapping might be:
		<screen>

    Swift variable -------------------&gt;  Filename

       texts[0]                          footest.txt
       texts[1]                          foo1.txt
       texts[2]                          foo__1.txt

		</screen>
	</listitem>
	</itemizedlist>
	</section>

	<section id="mapper.fixed_array_mapper"><title>fixed array mapper</title>
	<itemizedlist>
	<listitem>Name: fixed_array_mapper</listitem>
    <listitem>Description:
This mapper maps from a string that contains a list of filenames 
into a file array.
	</listitem>
	<listitem>Parameter:
		<itemizedlist>
		<listitem>files:
A string that contains a list of filenames, separated by space, comma or colon
		</listitem>
		</itemizedlist>
	</listitem>

	<listitem> Example:
			<programlisting>
	file texts[] &lt;fixed_array_mapper;files="file1.txt, fileB.txt, file3.txt"&gt;;
			</programlisting>
would cause a mapping like this:
		<screen>

    Swift variable -------------------&gt;  Filename

       texts[0]                          file1.txt
       texts[1]                          fileB.txt
       texts[2]                          file3.txt

		</screen>
	</listitem>
	</itemizedlist>
	</section>

	<section id="mapper.array_mapper"><title>array mapper</title>
	<itemizedlist>
	<listitem>Name: array_mapper</listitem>
	<listitem>Description: This mapper froms an array of strings into a file
array.</listitem>
	<listitem>Parameter: 
		<itemizedlist>
		<listitem>files:
An array of strings containing one filename per element</listitem>
		</itemizedlist>
	</listitem>
	<listitem> Example:
		<programlisting>
string s[] = [ "a.txt", "b.txt", "c.txt" ];

file f[] &lt;array_mapper;files=s&gt;;
		</programlisting>
This will establish the mapping:
		<screen>

    Swift variable -------------------&gt;  Filename

       f[0]                              a.txt
       f[1]                              b.txt
       f[2]                              c.txt

		</screen>

	</listitem>
	</itemizedlist>
	</section>

	<section id="mapper.regexp_mapper"><title>regular expression mapper</title>
	<itemizedlist>
	<listitem>Name: regexp_mapper</listitem>
	<listitem>Description:
This mapper transforms one file name to another using
regular expression matching.
	</listitem>
	<listitem>Parameters:
		<itemizedlist>
		<listitem>source:
		The source file name
		</listitem>
		<listitem>match:
Regular expression pattern to match, use ( ) to match whatever regular
expression is inside the parentheses, and indicate the start and end
of a group; the contents of a group can be retrieved with the
<emphasis>\number</emphasis> special sequence
		</listitem>
		<listitem>transform:
The pattern of the file name to transform to, use
<emphasis>\number</emphasis> to reference the group matched.
		</listitem>
		</itemizedlist>
	</listitem>

	<listitem> Example:
			<programlisting>
	string s = "picture.gif";
	file f &lt;regexp_mapper;source=s,match="(.*)gif",transform="\1jpg"&gt;;
			</programlisting>
This example transforms a string &quot;gif&quot; into one 
ending with &quot;jpg&quot; and maps that to a file.
		<screen>

    Swift variable -------------------&gt;  Filename

       f                                 picture.jpg

		</screen>
	</listitem>
	</itemizedlist>
	</section>

	<section id="mapper.csv_mapper"><title>csv mapper</title>
	<itemizedlist>
	<listitem>Name: csv_mapper</listitem>
	<listitem>Description:
This mapper maps the content of a CSV (comma-separated value) file into 
an array of structures. The dataset type needs to be correctly defined to 
conform to the column names in the file. For instance, if the file
contains columns:
		<para>name age GPA</para>
		then the type needs to have the same member elements, say:
		<programlisting>
		type student {
			File  name;
			File  age;
			File  GPA;
		}
		</programlisting>
If the file does not contain a header with column info, then the
column names are assumed as &quot;column1&quot;, &quot;column2&quot;, etc.
	</listitem>
	<listitem>Parameters:
		<itemizedlist>
		<listitem>file:
The name of the CSV file to read mappings from.
		</listitem>
		<listitem>header:
Whether the file has a line describing header info; default is true
		</listitem>
		<listitem>skip:
The number of lines to skip at the beginning (after header line); default is 0.
		</listitem>
		<listitem>hdelim:
Header field delimiter; default is the value of the "delim" parameter
		</listitem>
		<listitem>delim:
Content field delimiters; defaults are space, tab and comma.
		</listitem>
		</itemizedlist>
	</listitem>

	<listitem> Example:
			<programlisting>
	student stus[] &lt;csv_mapper;file="stu_list.txt"&gt;;
			</programlisting>
The above example would read a list of student info from file 
&quot;stu_list.txt&quot; and map them into a student array. By default, 
the file should contain a header line specifying the names of the columns.

If <filename>stu_list.txt</filename> contains the following:
<screen>
name,age,gpa
101-name.txt, 101-age.txt, 101-gpa.txt
name55.txt, age55.txt, age55.txt
q, r, s
</screen>
then some of the mappings produced by this example would be:
		<screen>

    Swift variable -------------------&gt;  Filename

       stus[0].name                         101-name.txt
       stus[0].age                          101-age.txt
       stus[0].gpa                          101-gpa.txt
       stus[1].name                         name55.txt
       stus[1].age                          age55.txt
       stus[1].gpa                          gpa55.txt
       stus[2].name                         q
       stus[2].age                          r
       stus[2].gpa                          s

		</screen>

    </listitem>
	</itemizedlist>
	</section>
	</section>
	<section id="engineconfiguration">	
	
		<title>Swift Engine Configuration</title>
		
		<para>
		
			Various aspects of the behavior of the Swift Engine can be
			configured through properties. The Swift Engine recognizes a global,
			per installation properties file which can found in <filename
			class="file">$SWIFT_HOME/etc/swift.properties</filename> and a user
			properties file which can be created by each user in <filename
			class="file">~/.swift/swift.properties</filename>. The Swift Engine
			will first load the global properties file. It will then try to load
			the user properties file. If a user properties file is found,
			individual properties explicitly set in that file will override the
			respective properties in the global properties file. Furthermore,
			some of the properties can be overridden directly using command line
			arguments to the <link
			linkend="swiftcommand"><command>swift</command> command</link>.
		
		</para>
		
		<section id="properties">
		
			<title>Swift Properties</title>
			
			<para>
			
				Swift properties are specified in the following format:
				
<programlisting>
&lt;name&gt;=&lt;value&gt;
</programlisting>
			
				The value can contain variables which will be expanded when the
				properties file is read. Expansion is performed when the name of
				the variable is used inside the "standard" shell dereference
				construct: ${<varname>name</varname>}. The following variables
				can be used in the Swift configuration file:
				
				<variablelist>
					<title>Swift Configuration Variables</title>
					
					<varlistentry>
						<term>
							<varname>swift.home</varname>
						</term>
						<listitem>
							<para>
							
								Points to the Swift installation directory
								(<filename
								class="directory"><envar>$SWIFT_HOME</envar></filename>).
							
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<varname>user.name</varname>
						</term>
						<listitem>
							<para>
							
								The name of the current logged in user.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<varname>user.home</varname>
						</term>	
						<listitem>
							<para>
							
								The user's home directory.
								
							</para>
						</listitem>
					</varlistentry>
				</variablelist>
				
				The following is a list of valid Swift properties:
				
				<variablelist>
					<title>Swift Properties</title>
					
					<varlistentry>
						<term>
							<property>sites.file</property>
						</term>
						<listitem>
							
							<para>
								Valid values: <parameter>&lt;file&gt;</parameter>
							</para>
							
							<para>
								Default value: ${<varname>swift.home</varname>}<literal>/etc/sites.xml</literal>
							</para>
						
							<para>
							
								Points to the location of the pool file (site
								catalog) which contains a list of all sites that
								Swift should use, together with information about
								the installed services. Details about the format
								of the pool file can be found <ulink
								url="http://vds.uchicago.edu/vds/doc/userguide/html/H_SiteCatalog.html">here</ulink>.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>tc.file</property>
						</term>
						<listitem>
							<para>
								Valid values: <parameter>&lt;file&gt;</parameter>
							</para>
							
							<para>
								Default value: ${<varname>swift.home</varname>}<literal>/etc/tc.data</literal>
							</para>
						
							<para>
							
								Points to the location of the transformation
								catalog file which contains information about
								installed applications. Details about the format
								of the transformation catalog can be found
								<ulink
								url="http://vds.uchicago.edu/vds/doc/userguide/html/H_TransformationCatalog.html">here</ulink>.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>ip.address</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;ipaddress&gt;</parameter>
							</para>
							
							<para>
								Default value: N/A
							</para>
						
							<para>
							
								The Globus GRAM service uses a callback
								mechanism to send notifications about the status
								of submitted jobs. The callback mechanism
								requires that the Swift client be reachable from
								the hosts the GRAM services are running on.
								Normally, Swift can detect the correct IP address
								of the client machine. However, in certain cases
								(such as the client machine having more than one
								network interface) the automatic detection
								mechanism is not reliable. In such cases, the IP
								address of the Swift client machine can be
								specified using this property. The value of this
								property must be a numeric address without quotes.
								
							</para>
						</listitem>
					</varlistentry>
					
					
					<varlistentry>
						<term>
							<property>lazy.errors</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <literal>true</literal>, <literal>false</literal>
							</para>
							
							<para>
								Default value: <literal>false</literal>
							</para>
						
							<para>
							
								Swift can report application errors in two
								modes, depending on the value of this property.
								If set to <constant>false</constant>, Swift will
								report the first error encountered and
								immediately stop execution. If set to
								<constant>true</constant>, Swift will attempt to
								run as much as possible from a workflow before
								stopping execution and reporting all errors
								encountered.
							</para>
							<para>When deveoping workflows, using the
								default value of <constant>false</constant> can
								make the workflow easier to debug. However
								in production runs, using <constant>true</constant>
								will allow more of a workflow to be run before
								Swift aborts execution.
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry id="property.caching.algorithm">
						<term>
							<property>caching.algorithm</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <literal>LRU</literal>
							</para>
							
							<para>
								Default value: <literal>LRU</literal>
							</para>
						
							<para>
							
								Swift caches files that are staged in on remote
								resources, and files that are produced remotely
								by applications, such that they can be re-used
								if needed without being transfered again.
								However, the amount of remote file system space
								to be used for caching can be limited using the
								<link linkend="profile.swift.storagesize"><property>swift:storagesize</property></link> profile
								entry in the sites.xml file. Example:
								
<programlisting>

&lt;pool handle="example" sysinfo="INTEL32::LINUX"&gt;
	&lt;gridftp url="gsiftp://example.org" storage="/scratch/swift" major="2" minor="4" patch="3"/&gt;
	&lt;jobmanager universe="vanilla" url="example.org/jobmanager-pbs" major="2" minor="4" patch="3"/&gt;
	&lt;workdirectory&gt;/scratch/swift&lt;/workdirectory&gt;
	&lt;profile namespace="SWIFT" key="storagesize"&gt;20000000&lt;/profile&gt;
&lt;/pool&gt;

</programlisting>
								
								
								The decision of which files to keep in the cache
								and which files to remove is made considering
								the value of the
								<property>caching.algorithm</property> property. 							
								Currently, the only available value for this 							
								property is <literal>LRU</literal>, which would
								cause the least recently used files to be
								deleted first.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>pgraph</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <literal>true</literal>, <literal>false</literal>, <parameter>&lt;file&gt;</parameter>
							</para>
							
							<para>
								Default value: <literal>false</literal>
							</para>
							
							<para>
							
								Swift can generate a 
<ulink url="http://www.graphviz.org/">Graphviz</ulink> file representing 
								the structure of the workflow it runs. If this
								property is set to <literal>true</literal>,
								Swift will save the provenance graph in a file
								named by concatenating the workflow name and the
								instance ID (e.g. <filename
								class="file">helloworld-ht0adgi315l61.dot</filename>). 
							</para>
							<para>
								If set to <literal>false</literal>, no
								provenance  graph will be generated. If a file
								name is used, then  the provenance graph will be
								saved in the specified file.
							</para>
							<para>
								The generated dot file can be rendered
								into a graphical form using
								<ulink
								url="http://www.graphviz.org">Graphviz</ulink>,
								for example with a command-line such as:
							</para>
							<programlisting>
								swift -pgraph graph1.dot q1.swift
								dot -ograph.png -Tpng graph1.dot
							</programlisting>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>pgraph.graph.options</property>
						</term>
						<listitem>
							
							<para>
								Valid values: <parameter>&lt;string&gt;</parameter>
							</para>
							
							<para>
								Default value: <literal>splines="compound", rankdir="TB"</literal>
							</para>
						
							<para>
							
								This property specifies a <ulink
								url="http://www.graphviz.org">Graphviz</ulink>
								specific set of parameters for the graph.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>pgraph.node.options</property>
						</term>
						<listitem>
							
							<para>
								Valid values: <parameter>&lt;string&gt;</parameter>
							</para>
							
							<para>
								Default value: <literal>color="seagreen", style="filled"</literal>
							</para>
						
							<para>
							
								Used to specify a set of <ulink
								url="http://www.graphviz.org">Graphviz</ulink>
								specific properties for the nodes in the graph.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry id="property.clustering.enabled">
						<term>
							<property>clustering.enabled</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <literal>true</literal>, <literal>false</literal>
							</para>
							
							<para>
								Default value: <literal>false</literal>
							</para>
							
							<para>
								Enables <link linkend="clustering">clustering</link>.
							</para>
							
						</listitem>
					</varlistentry>
					
					<varlistentry id="property.clustering.queue.delay">
						<term>
							<property>clustering.queue.delay</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;int&gt;</parameter>
							</para>
							
							<para>
								Default value: <literal>4</literal>
							</para>
							
							<para>
							
								This property indicates the interval, in
								seconds, at which the clustering queue is
								processed.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry id="property.clustering.min.time">
						<term>
							<property>clustering.min.time</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;int&gt;</parameter>
							</para>
							
							<para>
								Default value: <literal>60</literal>
							</para>
						
							<para>
							
								Indicates the threshold wall time for
								clustering, in seconds. Jobs that have a 
								wall time smaller than the value of this
								property will be considered for clustering.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>kickstart.enabled</property>
						</term>
						<listitem>
							
							<para>
								Valid values: <literal>true</literal>, <literal>false</literal>, <literal>maybe</literal>
							</para>
							
							<para>
								Default value: <literal>maybe</literal>
							</para>
								
							<para>
								
								This option allows controlling of
								when Swift uses <link linkend="kickstart">Kickstart</link>. A value of
								<literal>false</literal> disables the use of
								Kickstart, while a value of
								<literal>true</literal> enables the use of
								Kickstart, in which case sites specified in the
								<filename type="file">sites.xml</filename> file
								must have valid
								<parameter>gridlaunch</parameter> attributes.
								The <literal>maybe</literal> value will
								enable the use of Kickstart only
								on sites that have the
								<parameter>gridlaunch</parameter> attribute
								specified.

							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>kickstart.always.transfer</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <literal>true</literal>, <literal>false</literal>
							</para>
							
							<para>
								Default value: <literal>false</literal>
							</para>
							
							<para>
							
								This property controls when output from
								Kickstart is transfered back to the submit site,
								if Kickstart is enabled. When set to
								<literal>false</literal>, Kickstart output is
								only transfered for jobs that fail. If set to
								<literal>true</literal>, Kickstart output is
								transfered after every job is completed or
								failed.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>throttle.submit</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;int&gt;</parameter>, <parameter>off</parameter>
							</para>
							
							<para>
								Default value: <literal>4</literal>
							</para>
						
							<para>
							
								Limits the number of concurrent submissions for
								a workflow instance. This throttle only limits
								the number of concurrent tasks (jobs) that are
								being sent to sites, not the total number of
								concurrent jobs that can be run. The submission
								stage in GRAM is one of the most CPU expensive
								stages (due mostly to the mutual authentication
								and delegation). Having too many  concurrent
								submissions can overload either or both the
								submit host CPU and the remote host/head node
								causing degraded performance.
								
							</para>
							
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>throttle.host.submit</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;int&gt;</parameter>, <parameter>off</parameter>
							</para>
							
							<para>
								Default value: <literal>2</literal>
							</para>
							
							<para>
							
								Limits the number of concurrent submissions for
								any of the sites Swift will try to send jobs to.
								In other words it guarantees that no more than
								the  value of this throttle jobs sent to any
								site will be concurrently in a state of being
								submitted.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>throttle.transfers</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;int&gt;</parameter>, <parameter>off</parameter>
							</para>
						
							<para>
								Default value: <literal>4</literal>	
							</para>
							
							<para>
							
								Limits the total number of concurrent file
								transfers that can happen at any given time.
								File transfers consume bandwidth. Too many
								concurrent transfers can cause the network to be
								overloaded preventing various other signaling
								traffic from flowing properly.
								
							</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<property>throttle.file.operations</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;int&gt;</parameter>, <parameter>off</parameter>
							</para>
							
							<para>
								Default value: <literal>8</literal>
							</para>
							
							<para>
							
								Limits the total number of concurrent file
								operations that can happen at any given time.
								File operations (like transfers) require an
								exclusive connection to a site. These
								connections can be expensive to establish. A
								large number of concurrent file operations may
								cause Swift to attempt to establish many  such
								expensive connections to various sites. Limiting
								the number of concurrent file operations causes
								Swift to use a small number of cached
								connections and achieve better overall
								performance. 
								
							</para>
						</listitem>
					</varlistentry>
	
				
					<varlistentry>
						<term>
							<property>throttle.score.job.factor</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;int&gt;</parameter>, <parameter>off</parameter>
							</para>
							
							<para>
								Default value: <literal>4</literal>
							</para>
							
							<para>
								The Swift scheduler has the ability to limit
								the number of concurrent jobs allowed on a
								site based on the performance history of that
								site. Each site is assigned a score (initially
								1), which can increase or decrease based on
								whether the site yields successful or faulty
								job runs. The score for a site can take values
								in the (0.1, 100) interval. The number of
								allowed jobs is calculated using the
								following formula:
							</para>
							<para>
								2 + score*throttle.score.job.factor 
							</para>
							<para>
								This means a site will always be allowed
								at least two concurrent jobs and at most
								2 + 100*throttle.score.job.factor. With a
								default of 4 this means at least 2 jobs and
								at most 402. 
							</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<property>sitedir.keep</property>
						</term>
						<listitem>
							<para>
								Valid values: <parameter>true</parameter>, <parameter>false</parameter>
							</para>

							<para>
								Default value: <literal>false</literal>
							</para>

							<para>
Indicates whether the working directory on the remote site should be
left intact even when the workflow completes successfully. This can be
used to inspect the site working directory for debugging purposes.
							</para>
						</listitem>
					</varlistentry>

										
				</variablelist>
				
				Example:
				
<programlisting>
sites.file=${vds.home}/etc/sites.xml
tc.file=${vds.home}/etc/tc.data
ip.address=192.168.0.1
</programlisting>
			
			</para>
		
		</section>
		
	</section>

	<section id="swiftcommand">
	<title>The swift command</title>
	<para>
The <command>swift</command> command is the main command line tool
for executing SwiftScript programs.
	</para>
	<section><title>Command-line Syntax</title>
<para>The <command>swift</command> command is invoked as follows:
<command>swift [options] SwiftScript-program [SwiftScript-arguments]</command>
with options taken from the following list, and SwiftScript-arguments
made available to the SwiftScript program through the
<link linkend="function.arg">@arg</link> function.
</para>
  <variablelist><title>Swift command-line options</title>
  <varlistentry><term>-help or -h</term>
    <listitem><para>
      Display usage information </para></listitem>
  </varlistentry>
  <varlistentry><term>-typecheck</term>
    <listitem><para>
      Does a typecheck instead of executing the workflow </para></listitem>
  </varlistentry>

  <varlistentry><term>-dryrun</term>
    <listitem><para>
      Runs the workflow without submitting any jobs (can be used to get
      a graph)
    </para></listitem>
  </varlistentry>

  <varlistentry><term>-monitor</term>
    <listitem><para>
      Shows a graphical resource monitor 
    </para></listitem>
  </varlistentry>

  <varlistentry><term>-resume <literal>file</literal></term>
    <listitem><para>
      Resumes the execution using a log file 
    </para></listitem>
  </varlistentry>

  <varlistentry><term>-config <literal>file</literal></term>
    <listitem><para>
      Indicates the Swift configuration file to be used for this run. 
      Properties in this configuration file will override the default 
      properties. If individual command line arguments are used for 
      properties, they will override the contents of this file. 
    </para></listitem>
  </varlistentry>

  <varlistentry><term>-verbose | -v</term>
    <listitem><para>
      Increases the level of output that Swift produces on the console 
      to include more detail about the execution 
    </para></listitem>
  </varlistentry>

  <varlistentry><term>-debug | -d</term>
    <listitem><para>
      Increases the level of output that Swift produces on the console 
      to include lots of detail about the execution 
    </para></listitem>
  </varlistentry>

  <varlistentry><term>-logfile <literal>file</literal></term>
    <listitem><para>
      Specifies a file where log messages should go to. By default 
      Swift uses the name of the workflow being run and a numeric index
      (e.g. myworkflow.1.log) 
    </para></listitem>
  </varlistentry>

  <varlistentry><term>-runid <literal>file</literal></term>
    <listitem><para>
Specifies the run identifier. This must be unique for every invocation of a workflow and is used in several places to keep files from different executions cleanly separated. By default, a datestamp and random number are used to generate a run identifier. When using this parameter, care should be taken to ensure
that the run ID remains unique with respect to all other run IDs that might
be used, irrespective of (at least) expected run location, workflow or user.
    </listitem></para>
  </varlistentry>

  <varlistentry><term>-tcp.port.range <literal>start,end</literal></term>
    <listitem><para>
      A TCP port range can be specified to restrict the ports on which 
      GRAM callback services are started. This is likely needed if your
      submit host is behind a firewall, in which case the firewall 
      should be configured to allow incoming connections on ports in 
      the range. 
    </para></listitem>
  </varlistentry>

</variablelist>

<para>In addition, the following Swift properties can be set on the
command line:

<itemizedlist>
<listitem>caching.algorithm</listitem>
<listitem>clustering.enabled</listitem>
<listitem>clustering.enabled</listitem>
<listitem>clustering.min.time</listitem>
<listitem>clustering.queue.delay</listitem>
<listitem>ip.address</listitem>
<listitem>kickstart.always.transfer</listitem>
<listitem>kickstart.enabled</listitem>
<listitem>lazy.errors</listitem>
<listitem>pgraph</listitem>
<listitem>pgraph.graph.options</listitem>
<listitem>pgraph.node.options</listitem>
<listitem>sitedir.keep</listitem>
<listitem>sites.file</listitem>
<listitem>tc.file</listitem>
</itemizedlist>
</para>

	</section>
	<section><title>Return codes</title>
	<para>
The swift command may exit with the following return codes:
<itemizedlist>
<listitem>0 - success</listitem>
<listitem>1 - command line syntax error or missing project name</listitem>
<listitem>2 - error during workflow execution</listitem>
<listitem>3 - error during compilation of SwiftScript program</listitem>
<listitem>4 - input file does not exist</listitem>
</itemizedlist>
	</para>
	</section>
	</section>

	<section id="kickstart"> <title>Kickstart</title>
		<para>

Kickstart is a tool that can be used to gather various information 
about the remote execution environment for each job that Swift tries
to run.
		</para>

		<para>
For each job, Kickstart generates an XML <firstterm>invocation
record</firstterm>. By default this record is staged back to the submit
host if the job fails.
		</para>

		<para>
Before it can be used it must be installed on the remote site and
the sites file must be configured to point to kickstart.
		</para>

		<para>
Kickstart can be downloaded as part of the Pegasus 'worker package' available
from the worker packages section of <ulink url="http://pegasus.isi.edu/code.php">the Pegasus download page</ulink>.
		</para>
		<para>
Untar the relevant worker package somewhere where it is visible to all of the
worker nodes on the remote execution machine (such as in a shared application
filesystem).
		</para>

<para>Now configure the gridlaunch attribute of the sites catalog
to point to that path, by adding a <parameter>gridlaunch</parameter>
attribute to the <function>pool</function> element in the site
catalog:

<programlisting>

&lt;pool handle="example" gridlaunch="/usr/local/bin/kickstart" sysinfo="INTEL32::LINUX"&gt;
[...]
&lt;/pool&gt;

</programlisting>

		</para>

		<para>
There are various kickstat.* properties, which have sensible default
values. These are documented in <link linkend="properties">the
properties section</link>.
		</para>



	</section>

	<section id="restart"> <title>Workflow restart/recovery</title>
		<para>
If a workflow fails, Swift can resume that workflow from the point of
failure. If a Swift workflow fails, a restart log file will be generated
using the unique job ID, with a .rlog extension. This restart log
can then be passed to a subsequent Swift invocation using the -resume
parameter. Swift will resume executing the workflow. Previously executed
tasks will not be run a second time. The SwiftScript source file should
not be modified between invocations.
		</para>
		<para>
Every execution of a workflow creates a restart
log file with a named composed of the file name of the workflow
being executed, an invocation ID, a numeric ID, and the <filename
class="file">.rlog</filename> extension. For example, <filename
class="file">example.swift</filename>, when executed, could produce
the following restart log file: <filename
class="file">example-ht0adgi315l61.0.rlog</filename>. Normally, if
the workflow completes successfully, the restart log file is
deleted. If however the workflow fails, <command>swift</command>
can use the restart log file to continue the
execution of the workflow from a point before the
failure occurred. In order to restart a workflow from a restart log
file, the <option>-resume <parameter><filename
class="file">logfile</filename></parameter></option> argument can be
used after the compiled workflow file name. Example:

<screen>
<prompt>&gt;</prompt> <command>swift</command> <option>-resume <filename
class="file">example-ht0adgi315l61.0.rlog</filename></option> <option><filename
class="file">example.swift</filename></option>.
</screen>

		</para>
	</section> 

	<section> <title>Invoking an application from Swift</title>
	<para>
There are certain requirements on the behaviour of application programs
used in SwiftScript programs. These requirements are primarily to ensure
that the Swift can run your application in different places.
	</para>
<para>
Swift must know about all of your data files - when Swift has decided where
to run your application, it will transfer the necessary input files there
before execution and transfer the output files back to the submitting
system afterwards. If Swift does not know about your files, then it cannot
do this. The way to tell Swift about files is by mapping them to variables
and using those variables as parameters to your application.
</para>
<para>
Applications should take the name of input and output files on the
command line - Sometimes Swift will decide on the name of your input
and output files automatically (for example, if you do not specify a mapping
explicitly for an input or output variable). Swift must be able to
tell your application which filename it has chosen, and the commandline
is the way it does that. Use the
<link linkend="function.filename">@filename</link> function to determine
the filename of a variable.
</para>
<para>
Applications should not assume that they are running in a particular
location or on a particular host - Swift will decide which site to run
a job on automatically (based on the sites that it knows have the
application installed, by looking at the transformation catalog). On that
site, it will create a unique working directory every time that it runs
your jobs. Your job should expect to be run in an arbitrary working directory
on any of the available hosts.
</para>
<para>
Running your application on the same input files multiple times should
always give equivalent output files. Swift expects to be able to run a job
multiple times, perhaps on the same site, perhaps on different sites, in
order to deal with error conditions. For example, applications should not
make modifications to external databases that causes their output to
differ if they are run more than once.
</para>
	</section>

	<section> <title>Technical overview of the Swift architecture</title>
	<para>
This section attempts to provide a technical overview of the Swift
architecture.
	</para>

	<section><title>karajan - the core execution engine</title>
	</section>

	<section><title>Execution layer</title>
	<para>
The execution layer causes an application program (in the form of a unix
executable) to be executed either locally or remotely.
	</para>
	<para>
The two main choices are local unix execution and execution through GRAM.
Other options are available, and user provided code can also be plugged in.
	</para>
	<para>
The <link linkend="kickstart">kickstart</link> utility can
be used to capture environmental information at execution time
to aid in debugging and provenance capture. 
	</para>
	</section>

	<section><title>SwiftScript language compilation layer</title>
	<para>
Step i: text to XML intermediate form parser/processor. parser written in
ANTLR - see resources/VDL.g. The XML Schema Definition (XSD) for the
intermediate language is in resources/XDTM.xsd.
	</para>
	<para>
Step ii: XML intermediate form to Karajan workflow. Karajan.java - reads
the XML intermediate form. compiles to karajan workflow language - for
example, expressions are converted from SwiftScript syntax into Karajan
syntax, and function invocations become karajan function invocations
with various modifications to parameters to accomodate return parameters
and dataset handling.
	</para>
	</section>

	<section><title>Swift/karajan library layer</title>
	<para>
Some Swift functionality is provided in the form of Karajan libraries
that are used at runtime by the Karajan workflows that the Swift
compiler generates.
	</para>
	</section>

	</section>

	<section id="extending"><title>Ways in which Swift can be extended</title>
<para>Swift is extensible in a number of ways. It is possible to add
mappers to accomodate different filesystem arrangements, site selectors
to change how Swift decides where to run each job, and job submission
interfaces to submit jobs through different mechanisms.
</para>
<para>A number of mappers are provided as part of the Swift release and
documented in the <link ref="mappers">mappers</link> section.
New mappers can be implemented
in Java by implementing the org.griphyn.vdl.mapping.Mapper interface. The
<ulink url="http://www.ci.uchicago.edu/swift/guides/tutorial.php">Swift
tutorial</ulink> contains a simple example of this.
</para>
<para>Swift provides a default site selector, the Adaptive Scheduler.
New site selectors can be plugged in by implementing the
org.globus.cog.karajan.scheduler.Scheduler interface and modifying
libexec/scheduler.xml and etc/karajan.properties to refer to the new
scheduler.
</para>
<para>Execution providers, which allow to Swift to execute jobs through
specific mechanisms (such as local fork or through GRAM) can be
implemented as Java CoG kit providers.
</para>
	</section>

	<section><title>Function reference</title>
		<para>
This section details functions that are available for use in the SwiftScript
language.
		</para>
		<section id="function.arg"><title>@arg</title>
			<para>
Takes a command line parameter name as a string parameter and returns the
name of that string parameter from the command line.
			</para>

			<para>For example:</para>
			<programlisting>
print(@arg("myparam"));
			</programlisting>
			<screen>
$ swift arg.swift -myparam=hello 
Swift v0.2-dev

RunID: p08an4d5yr6g2
hello
			</screen>

		</section>

		<section id="function.extractint"><title>@extractint</title>
			<para>
@extractint(file) will read the specified file, parse an integer from the
file contents and return that integer.
			</para>
		</section>

		<section id="function.filename"><title>@filename</title>
			<para>
@filename(v) will return a string containing the filename(s) for the file(s)
mapped to the variable v. When more than one filename is returned, the
filenames will be space separated inside a single string return value.
			</para>
		</section>
		<section id="function.filenames"><title>@filenames</title>
			<para>
@filenames(v) will return multiple values (!) containing the filename(s) for
the file(s) mapped to the variable v. (compare to
<link linkend="function.filename">@filename</link>)
			</para>
		</section>
		<section id="function.regexp"><title>@regexp</title>
			<para>
@regexp(input,pattern,replacement) will apply regular expression
substitution using the Java java.util.regexp API. For example:
<programlisting>
string v =  @regexp("abcdefghi", "c(def)g","monkey");
</programlisting>
will assing the value "abmonkeyhi" to the variable v.
			</para>
		</section>
		<section id="function.strcat"><title>@strcat</title>
			<para>
@strcat(a,b,c,d,...) will return a string containing all of the strings
passed as parameters joined into a single string. There may be any number
of parameters.
			</para>
		</section>
		<section id="function.strcut"><title>@strcut</title>
			<para>
@strcut(input,pattern) will match the regular expression in the pattern
parameter against the supplied input string and return the section that
matches the first matching parenthesised group.
			</para>
			<para>
For example:
			</para>

			<programlisting>
string t = "my name is John and i like puppies.";
string name = @strcut(t, "my name is ([^ ]*) ");
string out = @strcat("Your name is ",name);
print(out);
			</programlisting>

			<para>
will output the message 'Your name is John'.
			</para>
		</section>
	</section>

	<section><title>Built-in procedure reference</title>
		<para>
This section details built-in procedures that are available for use in
the SwiftScript language.
		</para>

		<section id="procedure.readdata"><title>readData</title>
			<para>
readData will read data from a specified file.
			</para>
			<para>
The format of the input file is controlled by the type of the return
value.
			</para>

			<para>
For scalar return types, such as int, the specified file should contain
a single value of that type.
			</para>
			<para>
For arrays of scalars, the specified file should contain one value
per line.
			</para>
			<para>
For structs of scalars, the file should contain two rows.
The first row should be structure member names separated by whitespace.
The second row should be the corresponding values for each structure
member, separated by whitespace, in the same order as the header row.
			</para>
			<para>
For arrays of structs, the file should contain a heading row listing
structure member names separated by whitespace. There should be one row
for each element of the array, with structure member elements listed in
the same order as the header row and separated by whitespace.
			</para>

			<para>
This procedure is new in 0.4.
			</para>
		</section>
		<section id="procedure.print"><title>print</title>
			<para>
Deprecated - use <link linkend="procedure.trace">trace</link> instead.
			</para>
			<para>
print will print its parameters to stdout; but will do this at a point
in execution that is undefined. Specifically, it will not necessarily
wait for its parameters to be properly set.
			</para>
		</section>
		<section id="procedure.trace"><title>trace</title>
			<para>
Trace will log its parameters. By default these will appear on both stdout
and in the run log file. Some formatting occurs to produce the log message.
The particular output format should not be relied upon. (new in 0.4)
			</para>
		</section>

	</section>

	<section id="profiles"><title>Profiles</title>
		<section id="porfile.karajan"><title>Karajan namespace</title>
			<para id="profile.karajan.maxsubmitrate">maxSubmitRate - limits the maximum rate of job submission, in jobs per second.
For example:
<screen>
&lt;profile namespace="karajan" key="maxSubmitRate"&gt;0.2&lt;/profile&gt;
</screen>
will limit job submission to 0.2 jobs per second (or equivalently,
one job every five seconds).
			</para>
		</section>
		<section id="profile.swift"><title>swift namespace</title>
			<para id="profile.swift.storagesize">storagesize limits the
amount of space that will be used on the remote site for temporary files.
When more than that amount of space is used, the remote temporary file
cache will be cleared using the algorithm specified in the
<link linkend="property.caching.algorithm"><property>caching.algorithm</property></link> property.
			</para>
		</section>
		<section id="profile.globus"><title>Globus namespace</title>
			<para id="profile.globus.maxwalltime"><property>maxwalltime</property> specifies a walltime limit for each job, in minutes. This profile setting also interacts
with the <link linkend="clustering">clustering mechanism</link>.
			</para>
			<para>
The following formats are recognized:
				<itemizedlist>
					<listitem>Minutes</listitem>
					<listitem>Hours:Minutes</listitem>
					<listitem>Hours:Minutes:Seconds</listitem>
				</itemizedlist>
			</para>
		</section>
	</section>
	<section id="providers"><title>Alternative providers</title>
		<para>
Some of the actions Swift takes - executing jobs and transferring files - 
take place through <firstterm>cog providers</firstterm>. Swift comes with
some default providers, but others can be used (both as supplied with Swift
and of your own making).
		</para>
		<section id="provider.pbs"><title>PBS execution provider</title>
			<para>
The PBS execution provider allows jobs to be executed through a local
PBS installation. To use, edit the localhost specification in sites.xml
to specify provider="pbs" instead of provider="local". Execution jobs
from Swift will then be submitted to the PBS queue instead of forked locally.
When using PBS, you must run Swift on the PBS submit node
and have your workdirectory point to a directory shared between
all worker nodes and the submit node.
			</para>
		</section>
	</section>

	<section id="clustering"><title>Clustering</title>
		<para>
Swift can group a number of short job submissions into a single larger
job submission to minimize overhead involved in launching jobs (for example,
caused by security negotiation and remote queuing delay).
		</para>

		<para>
By default, clustering is disabled. It can be activated by setting the
<link linkend="property.clustering.enabled">clustering.enabled</link>
property to true.
		</para>

		<para>
A job is eligible for clustering if
the <link linkend="profile.globus.maxwalltime"><property>GLOBUS::maxwalltime</property></link> profile is specified in the <filename
type="file">tc.data</filename> entry for that job, and its value is
less than the value of the
<link linkend="property.clustering.min.time"><property>clustering.min.time</property></link>
property.
		</para>

		<para>
Two or more jobs are considered compatible if they share the same site
and do not have conflicting profiles (e.g. different values for the same
environment variable). 
		</para>

		<para>
When a submitted job is eligible for clustering, 
it will be put in a clustering queue rather than being submitted to
a remote site. The clustering queue is processed at intervals 
specified by the
<link linkend="property.clustering.queue.delay"><property>clustering.queue.delay</property></link>
property. The processing of the clustering queue consists of selecting
compatible jobs and grouping them into clusters whose maximum wall time does
not exceed twice the value of the <property>clustering.min.time</property>
property.
		</para>

		
	</section>

	<section id="localhowtos"><title>How-To Tips for Specific User Communities</title>
		<section id="savinglogs"><title>Saving Logs - for UChicago CI Users</title>
			<para>
If you have a UChicago Computation Institute account, run this command in your 
submit directory after each run. It will copy all your logs and kickstart 
records into a directory at the CI for reporting, usage tracking, support and debugging.
			</para>
			<para>
rsync --ignore-existing *.log *-kickstart.xml login.ci.uchicago.edu:/home/benc/swift-logs/ --verbose
			</para>
		</section>
	</section>

</article>

