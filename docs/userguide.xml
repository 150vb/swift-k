<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [] >

<article>
	<articleinfo revision="0.1">
		<title>The SwiftScript User Guide</title>
        <subtitle>Source control $LastChangedRevision$</subtitle>
		<author>
			<firstname>Yong</firstname>
			<surname>Zhao</surname>
		</author>
		<abstract>
			<formalpara>
				<title></title>
				<para>
SwiftScript is an improved version of the Virtual Data Language that
supports dataset typing and mapping, dataset iteration, conditional
branching, sub-workflow composition and other advanced features. In
this document, we give a few examples to illustrate how to write
SwiftScript programs to exploit such features. SwiftScript syntax has
two flavors; one is in a C-like format, the other in XML. For
simplification purpose, all examples in this document are written
in the C-like format, which can be automatically translated into
the XML format using one of the tools in our virtual data system.
				</para>
			</formalpara>
		</abstract>
	</articleinfo>

	<sect1>
		<title>Overview</title>
		<para>
This manual provides reference material for the SwiftScript language
and the swift runtime system. For more introductory material, consult
the Swift tutorial.
		</para>
	</sect1>
	<sect1>
		<title>The SwiftScript Language</title>
<para>The syntax of SwiftScript has a superficial resemblence to C and
Java, for example in its use of the { and } characters to enclose
blocks of statements.
</para>
		<sect2>
			<title>Data</title>
		<para>
Data in SwiftScript is strongly typed. It may be represented in-memory
(as with conventional languages) or as an out-of-core file on disk.
For out-of-core files, a mapper (see mapper section) is used to
identify which files are used as backing store for the data. When data is
mapped externally this way, it is called a dataset.
		</para>
<para>
A dataset's physical representation is declared by a mapping descriptor, 
which defines how each element in the dataset's logical schema is 
stored in, and fetched from, physical structures such as directories,
files, and database tables
</para>

<para>
In order to permit reuse for different datasets, mapping functions may
be parameterized for such things as dataset locations. Thus, in order
to access a dataset, we need to know three things: its type schema, 
its mapping descriptor, and the value(s) of any parameter(s) associated 
with the mapping descriptor. For example, if we want to describe a dataset,
whose logical structure is defined by binaryfile, and whose physical
reprentation is a file called "file1.bin" located at "/home/yongzh/data/",
then the dataset might be declared as follows:
</para>

<programlisting>
binaryfile f1&lt;single_file_mapper;file="/home/yongzh/data/file1.bin"&gt;
</programlisting>

<para>
The above example declares a dataset called f1, which uses a single 
file mapper to map a file from a specific location. What the mapper does 
is merely returning the file name to the system. SwiftScript also 
has a simplified syntax for such cases since single_file_mapper 
is frequently used:

<programlisting>
binaryfile f1&lt;"/home/yongzh/data/file1.bin"&gt;
</programlisting>
</para>

		</sect2>

		<sect2>
			<title>Type System</title>
			<para>
The SwiftScript type system is based on the XDTM (XML dataset typing 
and mapping) model, where a dataset's logical structure is described 
via (a subset of) XML Schema, which defines primitive scalar data types 
such as Boolean, Integer, String, Float, and Date, and also allows 
for the definition of complex types via the composition of simple 
and complex types.
			</para>
			<para>
Types can be specified in C-like syntax to represent SwiftScript types.
For instance, we can define an order as composed of an array of items,
where each item has a name and a quantity:

<programlisting>
type order {
	item[] items;
}

type item {
	string name;
	integer quantity;
}
</programlisting>

		</para>
		
		<para>
Sometimes, the inner structure of a file on disk is irrelevant and we do
not need ot look at the content of the file in the SwiftScript program.
In this case, an empty type can be used, such as:

<programlisting>
type binaryfile {}
</programlisting>
		</para>
		</sect2>

		<sect2>
			<title>Statements</title>
			<para>
A SwiftScript program consists of a number of statements.
Statements may declare types, procedures and variables, assign values to
variables, and express operations over arrays.
			</para>
		</sect2>

		<sect2>
			<title>Declaration Statements</title>
			<para>
Declaration statements declare new variables and optionally assign
a value to them or map those variables to on-disk files.
SwiftScript variables are single-assignment - they may be assigned to
once, either at the time of declaration or later. Attempting to assign
a value a second or subsequent time is an error.
			</para>
<para>
Declaration statements have the general form:
<programlisting>
  typename variablename (&lt;mapping&gt; | = initialValue ) ;
</programlisting>
The format of the mapping expression is defined in the Mappers section.
initialValue may be either an expression or a procedure call that
returns a single value.
</para>
<para>Variables can also be declared in a multivalued-procedure statement,
described in another section.</para>
		</sect2>

		<sect2>
			<title>Assignment Statements</title>
			<para>
Assignment statements assign values to previously declared variables.
Assignments may only be made to variables that have already been 
assigned. Assignment statements have the general form:

<programlisting>
  variable = value;
</programlisting>

where value can be either an expression or a value 
			</para>

			<para>
Variables can also be assigned in a multivalued-procedure statement,
described in another section.
			</para>
		</sect2>

		<sect2>
			<title>Multivalued procedure invocation statements</title>
<para>
Procedures can return more than one value. In such case, the previously
mentioned declaration and assignent statements are insufficient. A
multi-valued procedure invocation can be used. This has the general
form:

<programlisting>
'(' ((type)? variableName ( '=' binding ))+ ')' = procedureinvocation
</programlisting>

Variables can be either declared (if a type is included) or assigned (if
a type is not included). If no bindings are specified, then variables
are assigned in the same order that they are specified in the
procedure declaration. If bindings are specified, then variables are
assigned to the named return parameter.
</para>

		</sect2>

		<sect2>
			<title>Procedures</title>
			<para>
Datasets are operated on by procedures, which take typed data as input,
perform computations on those data, and produce typed data as output. An
atomic procedure defines an interface to an executable program or
service, while a compound procedure composes calls to atomic
procedures, compound procedures, and/or control statements.
			</para>
			
			<para>
A procedure declaration is like a function definition, where we
specify the function name and the formal parameters. SwiftScript
procedures can take multiple inputs and produce multiple outputs.
Inputs are specified to the right of the function name where 
outputs to the left. For instance:

<programlisting>
(type3 out1, type4 out2) myproc (type1 in1, type2 in2)
</programlisting>

The above example declares a procedure called myproc, which 
has two inputs in1 (of type type1) and in2 (of type type2) 
and two outputs out1 (of type type3) and out2 (of type type4).
			</para>
	
			<para>
A procedure input parameter can have a default value, in which case
the parameter is deemed an optional parameter. When we call a
procedure, passing in the actual parameters, we allow both positional
parameter and keyword parameter passing, provided that all optional
parameters have to be declared after the required parameters and any
optional parameter has to be bound using keyword parameter passing.
So for instance if we declare a procedure myproc1:

<programlisting>
(binaryfile bf) myproc1 (int i, string s="foo")
</programlisting>

Then the procedure can be called like this

<programlisting>
binaryfile mybf = myproc1(1);
</programlisting>

or like this supplying the value for the optional parameter s:

<programlisting>
binaryfile mybf = myproc1 (1, s="bar");
</programlisting>

			</para>
			
			<para>
The body of an atomic procedure specifies how to invoke an
external executable program or Web Service, and how logical data
types are mapped to command line arguments or SOAP messages. A
complete specification for myproc1 can be:

<programlisting>
(binaryfile bf) myproc1 (int i, string s="foo") {
	app {
		myapp1 i s @filename(bf);
	}
}			
</programlisting>

Which specifies that myproc1 invokes an executable, passing the values
of i, s and the file name of bf as command line arguments. The
@filename notation serves as a mapping function denoting that the
argument should be mapped as a file name, and since the notation is
often required in invoking applications, often we can omit the
filename part and use the @ sign only.
			</para>

			<para>
A compound procedure contains a set of calls to other procedures. Shared
variables in the body of a compound procedure specify data dependencies
and thus the execution sequence of the procedure calls. For simple 
illustration, we define a compound procedure in below:

<programlisting>
(type2 b) foo_bar (type1 a) {
	type3 c;
	c = foo(a);    // c holds the result of foo
	b = bar(c);    // c is an input to bar
}
</programlisting>
		</para>
		</sect2>
		
		<sect2>
			<title>Control Constructs</title>
			<para>
Control constructs are special control entities in a workflow to 
control the direction of execution. SwiftScript provides if, switch,
foreach, and while constructs, with syntax and semantics similar
to comparable constructs in other high-level languages.
			</para>
			<sect3><title>foreach</title>
			<para>
The foreach construct is used to apply a block of statements to
each element in a dataset.
We illustrate the use of the foreach
construct in the following example:

<programlisting>
check_order (file a[]) {
	foreach file f in a {
		compute(f);
	}
}
</programlisting>

foreach statements have the general form:

<programlisting>
foreach (type) controlvariable in expression {
    statements
}
</programlisting>

The block of statements is evaluated once for each element in 'expression',
with the controlvariable set to the corresponding element.

			</para>
			</sect3>

			<sect3><title>if</title>
			<para>
The 'if' statement allows one of two blocks of statements to be
executed, based on a boolean predicate. 'if' statements generally
have the form:
<programlisting>
if(predicate) {
    statements
} else {
    statements
}
</programlisting>

where predicate is a boolean expression.
			</para>
			</sect3>

			<sect3><title>switch</title>
			<para>
Switch expressions allow one of a selection of blocks to be chosen based on
the value of a numerical control expression. Switch statements take the
general form:
<programlisting>
switch(controlExpression) {
    case n1:
        statements2
    case n2:
        statements2
    [...]
    default:
        statements
}
</programlisting>
The control expression is evaluated and the resulting numerical value used to
select a corresponding case, and the statements belonging to that case
are evaluated. If no case corresponds, then the statements belonging to
the default block are evaluated.
			</para>
			</sect3>

		</sect2>
	</sect1>
	
	<sect1>
		<title> Simple Examples </title>
		
		<sect2>
		<title>Hello World</title>
		
		<para>
The hello world example calls to the UNIX command echo to print
the text "hello world" and redirect the standard output into a
file. Note that the echo command in the procedure body is only
a logical command and needs to be mapped to an executable by means 
of a transformation catalog.

<programlisting>
type file {} //define a type for file
(file t) echo (string s) { //procedure declaration
	app {
		echo s stdout=@filename(t); //redirect stdout to a file
	}
}

file hw = echo("hello world"); //procedure call
</programlisting>

		</para>
		</sect2>	
	</sect1>

	<sect1>
		<title>Mappers</title>
		<para>
While we can define logical dataset types and procedures in SwiftScript,
we need ways to access physical data when we invoke a procedure or execute 
a workflow, and mappers help us to do that. A logical dataset can be 
physically stored in different kinds of format, for instance, in a plain 
text file, in a spreadsheet, or in a database. A mapper transforms a dataset's
logical representation from/to its physical representation.
		</para>
		<para>
Swift provides a number of mappers that are useful in common cases. This
section details those standard mappers. For more complex cases, it is
possible to write application-specific mappers in another language and
use them within a SwiftScript program.
		</para>

		<sect2><title>Mapper Initialization</title>
		<para>
Since each mapper is associated with a dataset, a mapper is initialized 
together with its dataset. When a workflow is executed, each input
datasets are evaluated and initialized first, and exceptions will be
thrown if there are any problems in locating mappers or accessing physical
data storage.
		</para>
		</sect2>

		<sect2><title>The single file mapper</title>
		
	<itemizedlist>
	<listitem>Name: single_file_mapper</listitem>
    <listitem>Description:
A single file mapper maps a single physical file to a dataset.
    </listitem>
    <listitem>Parameter:
        <itemizedlist>
        <listitem>file:
          The location of the physical file including path and file name.
        </listitem>
        </itemizedlist>
    </listitem>

    <listitem> Example:
			<programlisting>
	file f &lt;single_file_mapper;file="plot_outfile_param"&gt;;
			</programlisting>
			
There is a simplified syntax for this mapper:
			

			<programlisting>
	file f &lt;"plot_outfile_param"&gt;;
			</programlisting>
    </listitem>
	</itemizedlist>
	</sect2>

	<sect2><title>The simple mapper</title>
	<itemizedlist>
	<listitem>Name: simple_mapper</listitem>
    <listitem>Description:
A mapper that maps a file or a list of files into an array.
by prefix, suffix, and pattern.
if there are more than one file matched, each of the file names would
be mapped as a subelement of the dataset.
    </listitem>
    <listitem>Parameter:
        <itemizedlist>
        <listitem>location:
          A directory that the files are located.
        </listitem>
        <listitem>prefix:
          The prefix of the files
        </listitem>
        <listitem>suffix:
          The suffix of the files, for instance: &quot;.txt&quot;
        </listitem>
        <listitem>pattern:
A UNIX glob style pattern, for instance: &quot;*foo*&quot; would match 
all file names that contain foo. When this mapper is used to specify
output filenames, pattern is ignored.
        </listitem>
        </itemizedlist>
    </listitem>
    <listitem> Example:
		<programlisting>
	file f &lt;simple_mapper;prefix="foo", suffix=".txt"&gt;;
			</programlisting>
The above example would map all filenames that start 
with &quot;foo&quot; and have an extension &quot;.txt&quot; into file f.
    </listitem>
	</itemizedlist>
	</sect2>

	<sect2><title>concurrent mapper</title>
	<itemizedlist>
	<listitem>Name: concurrent_mapper</listitem>
    <listitem>Description:
Concurrent mapper is almost the same as the simple mapper,
except that it is used to map an output file, and the filename
generated will contain an extract sequence that is unique.
This mapper is the default mapper for variables when no mapper is
specified.
    </listitem>
    <listitem>Parameter:
        <itemizedlist>
        <listitem>location:
          A directory that the files are located.
        </listitem>
        <listitem>prefix:
          The prefix of the files
        </listitem>
        <listitem>suffix:
          The suffix of the files, for instance: &quot;.txt&quot;
        </listitem>
        <listitem>pattern:
A UNIX glob style pattern, for instance: &quot;*foo*&quot; would
match all file names that contain foo. When this mapper is used
to specify output filenames, pattern is ignored.
        </listitem>
        </itemizedlist>
    </listitem>
    <listitem> Example:
		<programlisting>
	file f1;
	file f2 &lt;concurrent_mapper;prefix="foo", suffix=".txt"&gt;;
			</programlisting>
The above example would use concurrent mapper for f1 and f2, and 
generate f2 filename with prefix &quot;foo&quot; and extension &quot;.txt&quot;
    </listitem>
	</itemizedlist>
	</sect2>

	<sect2><title>file system mapper</title>
<para>TODO: note on difference between location as a relative vs absolute
path wrt staging to remote location - as mihael said:
It's because you specify that location in the mapper. Try location="."          
instead of location="/sandbox/..."</para>
	<itemizedlist>
	<listitem>Name: filesys_mapper</listitem>
    <listitem>Description:
This mapper is similar to the simple mapper, but maps a file or 
a list of files to a dataset array. Each of the filenames would
be mapped as an element in the array.
    </listitem>
    <listitem>Parameter:
        <itemizedlist>
        <listitem>location:
          A directory that the files are located.
        </listitem>
        <listitem>prefix:
          The prefix of the files
        </listitem>
        <listitem>suffix:
          The suffix of the files, for instance: &quot;.txt&quot;
        </listitem>
        <listitem>pattern:
A UNIX glob style pattern, for instance: &quot;*foo*&quot; would
match all file names that contain foo.
		
        </listitem>
        </itemizedlist>
    </listitem>

    <listitem> Example:
			<programlisting>
	file texts[] &lt;filesys_mapper;prefix="foo", suffix=".txt"&gt;;
			</programlisting>
The above example would map all filenames that start with &quot;foo&quot; 
and have an extension &quot;.txt&quot; into the array texts.
    </listitem>
	</itemizedlist>
	</sect2>

	<sect2><title>fixed array mapper</title>
	<itemizedlist>
	<listitem>Name: fixed_array_mapper</listitem>
    <listitem>Description:
This mapper maps from a string that contains a list of filenames 
into a file array.
    </listitem>
    <listitem>Parameter:
        <itemizedlist>
        <listitem>files:
A string that contains a list of filenames, seprated by space, comma or colon
        </listitem>
        </itemizedlist>
    </listitem>

    <listitem> Example:
			<programlisting>
	file texts[] &lt;fixed_array_mapper;files="file1.txt, file2.txt, file3.txt"&gt;;
			</programlisting>
    </listitem>
	</itemizedlist>
	</sect2>

    <sect2><title>regular expression mapper</title>
	<itemizedlist>
	<listitem>Name: regexp_mapper</listitem>
    <listitem>Description:
This mapper transforms one file name to another using
regular exression matching.
    </listitem>
    <listitem>Parameter:
        <itemizedlist>
        <listitem>source:
          The source file name
        </listitem>
        <listitem>match:
Regular expression pattern to match, use ( ) to match whatever regular
expression is inside the parentheses, and indicate the start and end
of a group; the contents of a group can be retrieved with the
<emphasis>\number</emphasis> special sequence
        </listitem>
        <listitem>transform:
The pattern of the file name to transform to, use
<emphasis>\number</emphasis> to reference the group matched.
        </listitem>
        </itemizedlist>
    </listitem>

    <listitem> Example:
			<programlisting>
	file f &lt;regexp_mapper;source=@f,match="(.*)gif",transform="\1jpg"&gt;;
			</programlisting>
This example transforms a file ending with &quot;gif&quot; into one 
ending with &quot;jpg&quot;, where <emphasis>\1</emphasis> refers to
the first group matched.
    </listitem>
	</itemizedlist>
	</sect2>

	<sect2><title>csv mapper</title>
    <itemizedlist>
	<listitem>Name: csv_mapper</listitem>
    <listitem>Description:
This mapper maps the content of a CSV (comma-separated value) file into 
a dataset array. The dataset type needs to be correctly defined to 
conform to the column names in the file. For instance, if the file
contains columns:
        <para>	name	age		GPA</para>
        then the type needs to have the same member elements, say:
        <programlisting>
        type student {
        	string name;
        	int    age;
        	float  GPA;
        }
        </programlisting>
if the file does not contain a header with column info, then the
column names are assumed as &quot;column1&quot;, &quot;column2&quot;,
    </listitem>
    <listitem>Parameter:
        <itemizedlist>
        <listitem>file:
The name of the file to read from.
        </listitem>
        <listitem>header:
whether the file has a line describing header info, default is true
        </listitem>
        <listitem>skip:
The number of lines to skip at the beginning (after header line)
        </listitem>
        <listitem>hdelim:
Header delimiter, default is white space
        </listitem>
        <listitem>delim:
Content delimiter, default is white space
        </listitem>
        </itemizedlist>
    </listitem>

    <listitem> Example:
			<programlisting>
	student stus[] &lt;csv_mapper;name="stu_list.txt"&gt;;
			</programlisting>
The above example would read a list of student info from file 
&quot;stu_list.txt&quot; and map them into a student array. By default, 
the file should contain a header line specifying the names of the columns.
    </listitem>
	</itemizedlist>
	</sect2>

	</sect1>

	<sect1>
	<title>The swift command</title>
	<para>
The swift command is the main commandline tool for executing SwiftScript
programs.
	</para>
	<sect2><title>Syntax</title>
<para>
Command-line syntax can be seen by typing swift -help
</para>
	</sect2>
	<sect2><title>Return codes</title>
	<para>
The swift command may exit with the following return codes:
<itemizedlist>
<listitem>0 - success</listitem>
<listitem>1 - commandline syntax error or missing project name</listitem>
<listitem>2 - error during workflow execution</listitem>
<listitem>3 - error during compilation of SwiftScript program</listitem>
<listitem>4 - input file does not exist</listitem>
</itemizedlist>
	</para>
	</sect2>
	</sect1>

	<sect1> <title>Kickstart</title>.
		<para>
Kickstart provides information about the execution of remote jobs, in the
form of an XML invocation record collected on the remote system. By default,
it is not used but configuration options allow it to be enabled.
		</para>
	</sect1>

	<sect1> <title>Invoking an application from Swift</title>.
	<para>
There are certain requirements for invoking application code from Swift,
mostly related to their treatment of input and output data.
	</para>
	</sect1>
</article>

