<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [] >

<article>
	<articleinfo revision="0.1">
		<title>The SwiftScript User Guide</title>
        <subtitle>Source control $LastChangedRevision$</subtitle>
		<author>
			<firstname>Yong</firstname>
			<surname>Zhao</surname>
		</author>
		<abstract>
			<formalpara>
				<title></title>
				<para>
SwiftScript is an improved version of the Virtual Data Language that supports dataset typing and mapping, dataset iteration, conditional branching, sub-workflow composition and other advanced features. In this document, we give a few examples to illustrate how to write SwiftScript programs to exploit such features. SwiftScript syntax has two flavors; one is in a C-like format, the other in XML. For simplification purpose, all examples in this document are written in the C-like format, which can be automatically translated into the XML format using one of the tools in our virtual data system. 				
				</para>
			</formalpara>
		</abstract>
	</articleinfo>

	<sect1>
		<title>Overview</title>
		<para>
This manual provides reference material for the SwiftScript language
and the swift runtime system. For more introductory material, consult
the Swift tutorial.
		</para>
	</sect1>
	<sect1>
		<title>The SwiftScript Language</title>
<para>The syntax of SwiftScript has a superficial resemblence to C and
Java, for example in its use of the { and } characters to enclose
blocks of statements.
</para>
		<sect2>
			<title>Data</title>
		<para>
Data in SwiftScript is strongly typed. It may be represented in-memory
(as with conventional languages) or as an out-of-core file on disk.
For out-of-core files, a mapper (see mapper section) is used to
identify which files are used as backing store for the data.
		</para>
		</sect2>
		<sect2>
			<title>Type System</title>
			<para>
The SwiftScript type system is based on the XDTM (XML dataset typing 
and mapping) model, where a dataset's logical structure is described 
via (a subset of) XML Schema, which defines primitive scalar data types 
such as Boolean, Integer, String, Float, and Date, and also allows 
for the definition of complex types via the composition of simple 
and complex types.
			</para>
			<para>
Types can be specified in C-like syntax to represent SwiftScript types.
For instance, we can define an order as composed of an array of items,
where each item has a name and a quantity:

<programlisting>
type order {
	item[] items;
}

type item {
	string name;
	integer quantity;
}
</programlisting>

		</para>
		
		<para>
Sometimes, the inner structure of a file on disk is irrelevant and we do
not need ot look at the content of the file in the SwiftScript program.
In this case, an empty type can be used, such as:

<programlisting>
type binaryfile {}
</programlisting>
		</para>
		</sect2>

		<sect2>
			<title>Statements</title>
			<para>
A SwiftScript program consists of a number of statements.
Statements may declare types, procedures and variables, assign values to
variables, and express operations over arrays.
			</para>
		</sect2>

		<sect2>
			<title>Declaration Statements</title>
			<para>
Declaration statements declare new variables and optionally assign
a value to them or map those variables to on-disk files.
			</para>
		</sect2>

		<sect2>
			<title>Assignment Statements</title>
			<para>
Assignment statements assign values to previously declared variables.
SwiftScript variables have single assignment semantics.
			</para>
		</sect2>

		<sect2>
			<title>Procedures</title>
			<para>
Datasets are operated on by procedures, which take typed data as input,
perform computations on those data, and produce typed data as output. An atomic procedure defines an interface to an executable program or service, while a compound procedure composes calls to atomic procedures, compound procedures, and/or control statements. 
			</para>
			
			<para>
			A procedure declaration is like a function definition, where we specify the function name and the formal parameters. SwiftScript procedures can take multiple inputs and produce multiple outputs, and inputs are organized to the right of the function name where outputs to the left. For instance:

<programlisting>
(type3 out1, type4 out2) myproc (type1 in1, type2 in2)
</programlisting>

			The above example declares a procedure called myproc, which has two inputs in1 (of type type1) and in2 (of type type2) and two outputs out1 (of type type3) and out2 (of type type4).
			</para>
	
			<para>
	A formal parameter can have a default value, in which case this parameter is also deemed an optional parameter. When we call a procedure, passing in the actual parameters, we allow both positional parameter and keyword parameter passing, provided that all optional parameters have to be declared after the required parameters and any optional parameter has to be bound using keyword parameter passing. So for instance if we declare a procedure myproc1:

<programlisting>
(binaryfile bf) myproc1 (int i, string s="foo")
</programlisting>

			Then the procedure can be called like this

<programlisting>
binaryfile mybf = myproc1(1);
</programlisting>

			or like this supplying the value for the optional parameter s:

<programlisting>
binaryfile mybf = myproc1 (1, s="bar");
</programlisting>

			</para>
			
			<para>
			The body of an atomic procedure specifies how to invoke an external executable program or Web Service, and how logical data types are mapped to command line arguments or SOAP messages. A complete specification for myproc1 can be:

<programlisting>
(binaryfile bf) myproc1 (int i, string s="foo") {
	app {
		myapp1 i s @filename(bf);
	}
}			
</programlisting>

Which specifies that myproc1 invokes an executable, passing the values of i, s and the file name of bf as command line arguments. The @filename notation serves as a mapping function denoting that the argument should be mapped as a file name, and since the notation is often required in invoking applications, often we can omit the filename part and use the @ sign only.			
			</para>
			A compound procedure contains a set of calls to other procedures. Shared variables in the body of a compound procedure specify data dependencies and thus the execution sequence of the procedure calls. For simple illustration, we define a compound procedure in below:

<programlisting>
(type2 b) foo_bar (type1 a) {
	type3 c;
	c = foo(a);    // c holds the result of foo
	b = bar(c);    // c is an input to bar
}
</programlisting>

		</sect2>
		
		
		<sect2>
			<title>"Control Constructs"</title>
			<para>
			Control constructs are special control entities in a workflow to control the direction of execution. SwiftScript provides if, switch, foreach, and while constructs, with syntax and semantics similar to comparable constructs in high-level languages. 
			</para>
			
			<para>
			The foreach construct is used for dataset iteration. It iterates over each of the items in a composite dataset, and applies some operations to that item. We illustrate the use of the foreach construct in the following example using the type order defined above:

<programlisting>
check_order (order o) {
	foreach item it in o.items {
		check_item(it);
	}
}
</programlisting>

			</para>
		</sect2>
	</sect1>
	
	
	<sect1>
		<title> Simple Examples </title>
		
		<sect2>
		<title>Hello World</title>
		
		<para>
		The hello world example calls to the UNIX command echo to print the text “hello world” and redirect the standard output into a file. Please note that the echo command in the procedure body is only a logical command, it needs to be mapped to an executable by means of a transformation catalog.

<programlisting>
type file {} //define a type for file
(file t) echo (string s) { //procedure declaration
	app {
		echo s stdout=@filename(t); //redirect stdout to a file
	}
}

file hw = echo("hello world"); //procedure call
</programlisting>

		</para>
		</sect2>	
	</sect1>
	
	<sect1>
		<title>Mapper Specification</title>
		<para>
While we can define logical dataset types and procedures in SwiftScript,
we need ways to access physical data when we invoke a procedure or execute 
a workflow, and mappers help us to do that. A logical dataset can be 
physically stored in different kinds of format, for instance, in a plain 
text file, in a spreadsheet, or in a database. A mapper transforms a dataset's
logical representation from/to its physical representation. In this section,
we provide the detailed specifications of a few standard mappers.  
		</para>
		
		<sect2><title>Mapper Initialization</title>
		<para>
Since each mapper is associated with a dataset, a mapper is initialized 
together with its dataset. When a workflow is executed, all of its input
datasets are evaluated and initialized first, and exceptions will be 
thrown if there are any problems in locating mappers or accessing physical
data storage.
		</para>
		</sect2>

		<sect2><title>single file mapper</title>
		
	<itemizedlist>
	<listitem>Name: single_file_mapper</listitem>
    <listitem>Description:
        A single file mapper provides the physical file location of a dataset.
    </listitem>
    <listitem>Parameter:
        <itemizedlist>
        <listitem>file:
          The location including path and file name.
        </listitem>
        </itemizedlist>
    </listitem>

    <listitem> Example:
			<programlisting>
	file f &lt;single_file_mapper;file="plot_outfile_param"&gt;;
			</programlisting>
			
As mentioned before, there is a simplified syntax for this mapper.
			

			<programlisting>
	file f &lt;"plot_outfile_param"&gt;;
			</programlisting>
    </listitem>
	</itemizedlist>
	</sect2>

	<sect2><title>simple mapper</title>
	<itemizedlist>
	<listitem>Name: simple_mapper</listitem>
    <listitem>Description:
        A mapper that maps a file or a list of files by prefix, suffix, and pattern.
        if there are more than one file matched, each of the file names would be mapped as 
        a subelement of the dataset. 
        
    </listitem>
    <listitem>Parameter:
        <itemizedlist>
        <listitem>location:
          A directory that the files are located.
        </listitem>
        <listitem>prefix:
          The prefix of the files
        </listitem>
        <listitem>suffix:
          The suffix of the files, for instance: &quot;.txt&quot;
        </listitem>
        <listitem>pattern:
          A UNIX glob style pattern, for instance: &quot;*foo*&quot; would match all file names 
		that contain foo. When this mapper is used to specify output filenames, pattern is ignored.
		
        </listitem>
        </itemizedlist>
    </listitem>
    <listitem> Example:
		<programlisting>
	file f &lt;simple_mapper;prefix="foo", suffix=".txt"&gt;;
			</programlisting>
			The above example would map all filenames that start with &quot;foo&quot; and have 
			an extension &quot;.txt&quot; into file f.
    </listitem>
	</itemizedlist>
	</sect2>

	<sect2><title>concurrent mapper</title>
	<itemizedlist>
	<listitem>Name: concurrent_mapper</listitem>
    <listitem>Description:
        Concurrent mapper is almost the same as the simple mapper, except that it is used 
        to map an output file, and the file name generated will contain an extract sequence that 
        is unique across threads. This mapper is the default mapper for intermediate variables.
        
    </listitem>
    <listitem>Parameter:
        <itemizedlist>
        <listitem>location:
          A directory that the files are located.
        </listitem>
        <listitem>prefix:
          The prefix of the files
        </listitem>
        <listitem>suffix:
          The suffix of the files, for instance: &quot;.txt&quot;
        </listitem>
        <listitem>pattern:
          A UNIX glob style pattern, for instance: &quot;*foo*&quot; would match all file names 
		that contain foo. When this mapper is used to specify output filenames, pattern is ignored.
		
        </listitem>
        </itemizedlist>
    </listitem>
    <listitem> Example:
		<programlisting>
	file f1;
	file f2 &lt;concurrent_mapper;prefix="foo", suffix=".txt"&gt;;
			</programlisting>
			The above example would use concurrent mapper for f1 and f2, and generate f2 file 
			name with prefix &quot;foo&quot; and extension &quot;.txt&quot;
    </listitem>
	</itemizedlist>
	</sect2>

	<sect2><title>file system mapper</title>
	<itemizedlist>
	<listitem>Name: filesys_mapper</listitem>
    <listitem>Description:
        This mapper is similar to the simple mapper. But it maps a file or a list of files 
        to a dataset array. Each of the file names would be mapped as an element in the array. 
        
    </listitem>
    <listitem>Parameter:
        <itemizedlist>
        <listitem>location:
          A directory that the files are located.
        </listitem>
        <listitem>prefix:
          The prefix of the files
        </listitem>
        <listitem>suffix:
          The suffix of the files, for instance: &quot;.txt&quot;
        </listitem>
        <listitem>pattern:
          A UNIX glob style pattern, for instance: &quot;*foo*&quot; would match all file names 
		that contain foo.
		
        </listitem>
        </itemizedlist>
    </listitem>

    <listitem> Example:
			<programlisting>
	file texts[] &lt;filesys_mapper;prefix="foo", suffix=".txt"&gt;;
			</programlisting>
			The above example would map all filenames that start with &quot;foo&quot; and have 
			an extension &quot;.txt&quot; into the array texts.
    </listitem>
	</itemizedlist>
	</sect2>

	<sect2><title>fixed array mapper</title>
	<itemizedlist>
	<listitem>Name: fixed_array_mapper</listitem>
    <listitem>Description:
        This mapper maps from a string that contains a list of filenames into a file array. 
        
    </listitem>
    <listitem>Parameter:
        <itemizedlist>
        <listitem>files:
          A string that contains a list of filenames, seprated by space, comma or colon
        </listitem>
        </itemizedlist>
    </listitem>

    <listitem> Example:
			<programlisting>
	file texts[] &lt;fixed_array_mapper;files="file1.txt, file2.txt, file3.txt"&gt;;
			</programlisting>
    </listitem>
	</itemizedlist>
	</sect2>

    <sect2><title>regular expression mapper</title>
	<itemizedlist>
	<listitem>Name: regexp_mapper</listitem>
    <listitem>Description:
        This mapper transforms one file name to another using regular exression matching. 
        
    </listitem>
    <listitem>Parameter:
        <itemizedlist>
        <listitem>source:
          The source file name
        </listitem>
        <listitem>match:
          Regular expression pattern to match, use ( ) to match whatever regular expression is 
          inside the parentheses, and indicate the start and end of a group; the contents of a group 
          can be retrieved with the <emphasis>\number</emphasis> special sequence
        </listitem>
        <listitem>tranform:
          The pattern of the file name to transform to, use <emphasis>\number</emphasis> to 
          reference the group matched
        </listitem>
        </itemizedlist>
    </listitem>

    <listitem> Example:
			<programlisting>
	file f &lt;regexp_mapper;source=@f,match="(.*)gif",transform="\1jpg"&gt;;
			</programlisting>
		This example transforms a file ending with &quot;gif&quot; into one ending with 
		&quot;jpg&quot;, where <emphasis>\1</emphasis> refers to the first group matched.
    </listitem>
	</itemizedlist>
	</sect2>

	<sect2><title>csv mapper</title>
    <itemizedlist>
	<listitem>Name: csv_mapper</listitem>
    <listitem>Description:
        This mapper maps the content of a CSV (comma-separated value) file into a dataset 
        array. The dataset type needs to be correctly defined to conform to the column names in
        the file. For instance, if the file contains columns:
        <para>	name	age		GPA</para>
        then the type needs to have the same member elements, say:
        <programlisting>
        type student {
        	string name;
        	int    age;
        	float  GPA;
        }
        </programlisting>
        if the file does not contain a header with column info, then the column names are 
        assumed as &quot;column1&quot;, &quot;column2&quot;, ...
    </listitem>
    <listitem>Parameter:
        <itemizedlist>
        <listitem>file:
          The name of the file to read from.
        </listitem>
        <listitem>header:
          whether the file has a line describing header info, default is true
        </listitem>
        <listitem>skip:
          The number of lines to skip at the beginning (after header line)
        </listitem>
        <listitem>hdelim:
          Header delimiter, default is white space
        </listitem>
        <listitem>delim:
          Content delimiter, default is white space
        </listitem>
        </itemizedlist>
    </listitem>

    <listitem> Example:
			<programlisting>
	student stus[] &lt;csv_mapper;name="stu_list.txt"&gt;;
			</programlisting>
		The above example would read a list of student info from file 
			&quot;stu_list.txt&quot; and map them into a student array. By default, the file
			should contain a header line specifying the names of the columns.
    </listitem>
	</itemizedlist>
	</sect2>

	</sect1>

	<sect1>
	<title>The swift command</title>
	<para>
The swift command is the main commandline tool for executing SwiftScript
programs.
	</para>
	<sect2><title>Syntax</title>
<para>
Command-line syntax can be seen by typing swift -help
</para>
	</sect2>
	<sect2><title>Return codes</title>
	<para>
The swift command may exit with the following return codes:
<itemizedlist>
<listitem>0 - success</listitem>
<listitem>1 - commandline syntax error or missing project name</listitem>
<listitem>2 - error during workflow execution</listitem>
<listitem>3 - error during compilation of SwiftScript program</listitem>
<listitem>4 - input file does not exist</listitem>
</itemizedlist>
	</para>
	</sect2>
	</sect1>

</article>
