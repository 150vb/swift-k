<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [] >

<article>
	<articleinfo revision="0.1">
		<title>Swift User Guide</title>
		<subtitle>Source control $LastChangedRevision$</subtitle>
	</articleinfo>

	<section id="overview">
		<title>Overview</title>
		<para>
This manual provides reference material for Swift: the SwiftScript language
and the Swift runtime system. For introductory material, consult
the <ulink url="http://www.ci.uchicago.edu/swift/guides/tutorial.php">Swift
tutorial</ulink>.
	</para>
	<para>
Swift is a data-oriented coarse grained scripting language that
supports dataset typing and mapping, dataset iteration,
conditional branching, and procedural composition.
	</para>
	<para>
Swift programs (or <firstterm>workflows</firstterm>) are written in
a language called <firstterm>SwiftScript</firstterm>.
	</para>
	<para>
SwiftScript programs are dataflow oriented - they are primarily
concerned with processing (possibly large) data files, by invoking
programs to do that processing. Swift handles execution of such programs
on remote sites by choosing sites, handling the staging of input and output
files to and from the chosen sites and remote execution of program code.
	</para>
	</section>
	<section id="language">
		<title>The SwiftScript Language</title>
<section><title>Language basics</title>
<para>
A Swift script describes data, application components, invocations
of applications components, and the inter-relations (data flow) 
between those invocations.
</para>
<para>
Data is represented in a script by strongly-typed single-assignment
variables, using a C-like syntax.
</para>
<para>
Types in Swift can be <firstterm>atomic</firstterm> or
<firstterm>composite</firstterm>. An atomic type can be either a
<firstterm>primitive type</firstterm> or a <firstterm>mapped type</firstterm>.
Swift provides a fixed set of primitive types, such as
<firstterm>integer</firstterm> and <firstterm>string</firstterm>. A mapped
type indicates that the actual data does not reside in CPU addressable
memory (as it would in conventional programming languages), but in
POSIX-like files. Composite types are further subdivided into
<firstterm>structures</firstterm> and <firstterm>arrays</firstterm>.
Structures are similar in most respects to structure types in other languages.
Arrays use numeric indices, but are sparse. They can contain elements of
any type, including other array types, but all elements in an array must be
of the same type.  We often refer to instances of composites of mapped types
as <firstterm>datasets</firstterm>.
</para>
<imagedata fileref="type-hierarchy.png" />
<para>
Mapped type and composite type variable declarations can be annotated with a
<firstterm>mapping descriptor</firstterm> indicating the file(s) that make up
that dataset.  For example, the following line declares a variable named
<literal>photo</literal> with type <literal>image</literal>. It additionally
declares that the data for this variable is stored in a single file named
<filename>shane.jpeg</filename>.
</para>

<programlisting>
  image photo &lt;"shane.jpeg"&gt;;
</programlisting>

<para>
Conceptually, a parallel can be drawn between Swift mapped variables
and Java reference types. In both cases there is no syntactic distinction
between primitive types and mapped types or reference types respectively.
Additionally, the semantic distinction is also kept to a minimum.
</para>

<para>
Component programs of scripts are declared in an <firstterm>app
declaration</firstterm>, with the description of the command line syntax
for that program and a list of input and output data. An <literal>app</literal>
block describes a functional/dataflow style interface to imperative
components.
</para>

<para>
For example, the following example lists a procedure which makes use  of
the <ulink url="http://www.imagemagick.org/"> ImageMagick</ulink>
<command>convert</command> command to rotate a supplied
image by a specified angle:
</para>

<programlisting>
  app (image output) rotate(image input) {
    convert "-rotate" angle @input @output;
  }
</programlisting>

<para>
A procedure is invoked using the familiar syntax:
</para>

<programlisting>
  rotated = rotate(photo, 180);
</programlisting>

<para>
While this looks like an assignment, the actual unix level execution
consists of invoking the command line specified in the <literal>app</literal>
declaration, with variables on the left of the assignment bound to the
output parameters, and variables to the right of the procedure
invocation passed as inputs.
</para>

<para>
The examples above have used the type <literal>image</literal> with out any
definition of that type. We can declare it as a <firstterm>marker type</firstterm>
which has no structure exposed to SwiftScript:
</para>

<programlisting>
  type image;
</programlisting>

<para>
This does not indicate that the data is unstructured; but it indicates
that the structure of the data is not exposed to SwiftScript. Instead,
SwiftScript will treat variables of this type as individual opaque
files.
</para>

<para>
With mechanisms to declare types, map variables to data files, and
declare and invoke procedures, we can build a complete (albeit simple)
script:
</para>

<programlisting>
 type image;
 image photo &lt;"shane.jpeg"&gt;;
 image rotated &lt;"rotated.jpeg"&gt;;

 app (image output) rotate(image input, int angle) {
    convert "-rotate" angle @input @output;
 }

 rotated = rotate(photo, 180);
</programlisting>

<para>
This script can be invoked from the command line:
</para>

<screen>
  $ <userinput>ls *.jpeg</userinput>
  shane.jpeg
  $ <userinput>swift example.swift</userinput>
  ...
  $ <userinput>ls *.jpeg</userinput>
  shane.jpeg rotated.jpeg
</screen>

<para>
This executes a single <literal>convert</literal> command, hiding from the
user features such as remote multisite execution and fault tolerance that
will be discussed in a later section.
</para>
<figure> <title>shane.jpeg</title>
<imagedata fileref="userguide-shane.jpeg" />
</figure>
<figure> <title>rotated.jpeg</title>
<imagedata fileref="userguide-rotated.jpeg" />
</figure>
</section>

<section><title>Arrays and Parallel Execution</title>
<para>
Arrays of values can be declared using the <literal>[]</literal> suffix. An
array be mapped to a collection of files, one element per file, by using
a different form of mapping expression.  For example, the
<link linkend="mapper.filesys_mapper"><literal>filesys_mapper</literal></link>
maps all files matching a particular unix glob pattern into an array:
</para>

<programlisting>
  file frames[] &lt;filesys_mapper; pattern="*.jpeg"&gt;;
</programlisting>

<para>
The <firstterm><literal>foreach</literal></firstterm> construct can be used
to apply the same block of code to each element of an array:
</para>

<programlisting>
   foreach f,ix in frames {
     output[ix] = rotate(frames, 180);
   }
</programlisting>

<para>
Sequential iteration can be expressed using the <literal>iterate</literal>
construct:
</para>

<programlisting>
   step[0] = initialCondition();
   iterate ix {
     step[ix] = simulate(step[ix-1]);
   }
</programlisting>

<para>
This fragment will initialise the 0-th element of the <literal>step</literal>
array to some initial condition, and then repeatedly run the 
<literal>simulate</literal> procedure, using each execution's outputs as
input to the next step.
</para>

</section>

<section><title>Ordering of execution</title>

<para>
Non-array variables are <firstterm>single-assignment</firstterm>, which
means that they must be assigned to exactly one value during execution.
A procedure or expression will be executed when all of its input parameters
have been assigned values. As a result of such execution, more variables may
become assigned, possibly allowing further parts of the script to
execute.
</para>

<para>
In this way, scripts are implicitly parallel. Aside from serialisation
implied by these dataflow dependencies, execution of component programs
can proceed in parallel.
</para>

<para>
In this fragment, execution of procedures <literal>p</literal> and
<literal>q</literal> can happen in parallel:
</para>

<programlisting>
  y=p(x);
  z=q(x);
</programlisting>

<para>while in this fragment, execution is serialised by the variable
<literal>y</literal>, with procedure <literal>p</literal> executing
before <literal>q</literal>:</para>

<programlisting>
 y=p(x);
 z=q(y);
</programlisting>

<para>
Arrays in SwiftScript are more generally
<firstterm>monotonic</firstterm>; that is, knowledge about the
content of an array increases during execution, but cannot otherwise
change. Each element of the array is single assignment.
Eventually, all values for an array are known, and that array
is regarded as <firstterm>closed</firstterm>.
</para>

<para>
Statements which deal with the array as a whole will often wait for the array
to be closed before executing (thus, a closed array is the equivalent
of a non-array type being assigned). However, a <literal>foreach</literal>
statement will apply its body to elements of an array as they become
known. It will not wait until the array is closed.
</para>

<para>
Consider this script:
</para>

<programlisting>
 file a[];
 file b[];
 foreach v,i in a {
   b[i] = p(v);
 }
 a[0] = r();
 a[1] = s();
</programlisting>

<para>
Initially, the <literal>foreach</literal> statement will have nothing to
execute, as the array <literal>a</literal> has not been assigned any values.
The procedures <literal>r</literal> and <literal>s</literal> will execute.
As soon as either of them is finished, the corresponding invocation of
procedure <literal>p</literal> will occur. After both <literal>r</literal>
and <literal>s</literal> have completed, the array <literal>a</literal> will
be closed since no other statements in the script make an assignment to
<literal>a</literal>.
</para>

</section>

<section><title>Compound procedures</title>
<para>
As with many other programming languages, procedures consisting of SwiftScript
code can be defined. These differ from the previously mentioned procedures
declared with the <literal>app</literal> keyword, as they invoke other
SwiftScript procedures rather than a component program.
</para>

<programlisting>
 (file output) process (file input) {
   file intermediate;
   intermediate = first(input);
   output = second(intermediate);
 }

 file x &lt;"x.txt"&gt;;
 file y &lt;"y.txt"&gt;;
 y = process(x);
</programlisting>

<para>
This will invoke two procedures, with an intermediate data file named
anonymously connecting the <literal>first</literal> and
<literal>second</literal> procedures.
</para>

<para>
Ordering of execution is generally determined by execution of
<literal>app</literal> procedures, not by any containing compound procedures.
In this code block:
</para>

<programlisting>
 (file a, file b) A() {
   a = A1();
   b = A2();
 }
 file x, y, s, t;
 (x,y) = A();
 s = S(x);
 t = S(y);
</programlisting>

<para>
then a valid execution order is: <literal>A1 S(x) A2 S(y)</literal>. The
compound procedure <literal>A</literal> does not have to have fully completed
for its return values to be used by subsequent statements.
</para>

</section>

<section><title>More about types</title>
<para>
Each variable and procedure parameter in SwiftScript is strongly typed.
Types are used to structure data, to aid in debugging and checking program
correctness and to influence how Swift interacts with data.
</para>

<para>
The <literal>image</literal> type declared in previous examples is a
<firstterm>marker type</firstterm>. Marker types indicate that data for a
variable is stored in a single file with no further structure exposed at
the SwiftScript level.
</para>

<para>
Arrays have been mentioned above, in the arrays section. A code block
may be applied to each element of an array using <literal>foreach</literal>;
or individual elements may be references using <literal>[]</literal> notation.
</para>

<para>There are a number of primitive types:</para>

<table frame="all">
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
  <thead><row><entry>type</entry><entry>contains</entry></row></thead>
  <tbody>
   <row><entry>int</entry><entry>integers</entry></row>
   <row><entry>string</entry><entry>strings of text</entry></row>
   <row><entry>float</entry><entry>floating point numbers, that behave the same as Java <literal>double</literal>s</entry></row>
   <row><entry>boolean</entry><entry>true/false</entry></row>
  </tbody>
 </tgroup>
</table>

<para>
Complex types may be defined using the <literal>type</literal> keyword:
</para>
<programlisting>
  type headerfile;
  type voxelfile;
  type volume {
    headerfile h;
    voxelfile v;
  }
</programlisting>

<para>
Members of a complex type can be accessed using the <literal>.</literal>
operator:
</para>

<programlisting>
  volume brain;
  o = p(brain.h);
</programlisting>

<para>
Sometimes data may be stored in a form that does not fit with Swift's
file-and-site model; for example, data might be stored in an RDBMS on some
database server. In that case, a variable can be declared to have
<firstterm><literal>external</literal></firstterm> type. This indicates that
Swift should use the variable to determine execution dependency, but should
not attempt other data management; for example, it will not perform any form
of data stage-in or stage-out it will not manage local data caches on sites;
and it will not enforce component program atomicity on data output. This can
add substantial responsibility to component programs, in exchange for allowing
arbitrary data storage and access methods to be plugged in to scripts.
</para>

<programlisting>
  type file;

  app (external o) populateDatabase() {
    populationProgram;
  }

  app (file o) analyseDatabase(external i) {
    analysisProgram @o;
  }

  external database;
  file result &lt;"results.txt"&gt;;

  database = populateDatabase();
  result = analyseDatabase(database);
</programlisting>

<para>
Some external database is represented by the <literal>database</literal>
variable. The <literal>populateDatabase</literal> procedure populates the
database with some data, and the <literal>analyseDatabase</literal> procedure
performs some subsequent analysis on that database. The declaration of
<literal>database</literal> contains no mapping; and the procedures which
use <literal>database</literal> do not reference them in any way; the
description of <literal>database</literal> is entirely outside of the script.
The single assignment and execution ordering rules will still apply though;
<literal>populateDatabase</literal> will always be run before
<literal>analyseDatabase</literal>.
</para>

</section>

<section><title>Data model</title>
<para>Data processed by Swift is strongly typed. It may be take the form
of values in memory or as out-of-core files on disk. Language constructs
called mappers specify how each piece of data is stored.</para>

<section><title>Mappers</title>
		<para>
When a DSHandle represents a data file (or container of datafiles), it is
associated with a mapper. The mapper is used to
identify which files belong to that DSHandle.
		</para>
		<para>
A dataset's physical representation is declared by a mapping descriptor, 
which defines how each element in the dataset's logical schema is 
stored in, and fetched from, physical structures such as directories,
files, and remote servers.
</para>

<para>
Mappers are parameterized to take into account properties such as
varying dataset location.
In order
to access a dataset, we need to know three things: its type, 
its mapping, and the value(s) of any parameter(s) associated 
with the mapping descriptor. For example, if we want to describe a dataset,
of type imagefile, and whose physical
representation is a file called "file1.bin" located at "/home/yongzh/data/",
then the dataset might be declared as follows:
</para>

<programlisting>
imagefile f1&lt;single_file_mapper;file="/home/yongzh/data/file1.bin"&gt;
</programlisting>

<para>
The above example declares a dataset called f1, which uses a single 
file mapper to map a file from a specific location.
</para>
<para>
SwiftScript has a simplified syntax for this case, since single_file_mapper 
is frequently used:

<programlisting>
binaryfile f1&lt;"/home/yongzh/data/file1.bin"&gt;
</programlisting>
</para>

<para>
Swift comes with a number of mappers that handle common mapping patterns.
These are documented in the <link linkend="mappers">mappers section</link>
of this guide.
</para>

</section>

		</section>
		<section>
			<title>Syntax</title>
<para>The syntax of SwiftScript has a superficial resemblance to C and
Java. For example, { and } characters are used to enclose blocks of
statements.
</para>
			<para>
A SwiftScript program consists of a number of statements.
Statements may declare types, procedures and variables, assign values to
variables, and express operations over arrays.
			</para>


		<section><title>Variables</title>
<para>Variables in SwiftScript are declared to be of a specific type.
Assignments to those variables must be data of that type.
SwiftScript variables are single-assignment - a value may be assigned
to a variable at most once. This assignment can happen at declaration time
or later on in execution. When an attempt to read from a variable
that has not yet been assigned is made, the code performing the read
is suspended until that variable has been written to. This forms the
basis for Swift's ability to parallelise execution - all code will
execute in parallel unless there are variables shared between the code
that cause sequencing.</para>

		<section>
			<title>Variable Declarations</title>
			<para>
Variable declaration statements declare new variables. They can
optionally assign a value to them or map those variables to on-disk files.
			</para>
<para>
Declaration statements have the general form:
<programlisting>
  typename variablename (&lt;mapping&gt; | = initialValue ) ;
</programlisting>
The format of the mapping expression is defined in the Mappers section.
initialValue may be either an expression or a procedure call that
returns a single value.
</para>
<para>Variables can also be declared in a multivalued-procedure statement,
described in another section.</para>
		</section>

		<section>
			<title>Assignment Statements</title>
			<para>
Assignment statements assign values to previously declared variables.
Assignments may only be made to variables that have not already been 
assigned. Assignment statements have the general form:

<programlisting>
  variable = value;
</programlisting>
where value can be either an expression or a procedure call that returns
a single value.
			</para>

			<para>
Variables can also be assigned in a multivalued-procedure statement,
described in another section.
			</para>
		</section>
</section>

<section><title>Procedures</title>

<para>There are two kinds of procedure: An atomic procedure, which
describes how an external program can be executed; and compound
procedures which consist of a sequence of SwiftScript statements.
</para>

			<para>
A procedure declaration defines the name of a procedure and its
input and output parameters. SwiftScript procedures can take multiple
inputs and produce multiple outputs.  Inputs are specified to the right
of the function name, and outputs are specified to the left. For example:

<programlisting>
(type3 out1, type4 out2) myproc (type1 in1, type2 in2)
</programlisting>

The above example declares a procedure called <literal>myproc</literal>, which 
has two inputs <literal>in1</literal> (of type <literal>type1</literal>)
and <literal>in2</literal> (of type <literal>type2</literal>) 
and two outputs <literal>out1</literal> (of type <literal>type3</literal>)
and <literal>out2</literal> (of type <literal>type4</literal>).
			</para>
	
			<para>
A procedure input parameter can be an <firstterm>optional
parameter</firstterm> in which case it must be declared with a default
value.  When calling a procedure, both positional parameter and named
parameter passings can be passed, provided that all optional
parameters are declared after the required parameters and any
optional parameter is bound using keyword parameter passing.
For example, if <literal>myproc1</literal> is defined as:

<programlisting>
(binaryfile bf) myproc1 (int i, string s="foo")
</programlisting>

Then that procedure can be called like this, omitting the optional
parameter <literal>s</literal>:

<programlisting>
binaryfile mybf = myproc1(1);
</programlisting>

or like this supplying a value for the optional parameter
<literal>s</literal>:

<programlisting>
binaryfile mybf = myproc1 (1, s="bar");
</programlisting>

			</para>
			
<section id="procedures.atomic"><title>Atomic procedures</title>
			<para>
An atomic procedure specifies how to invoke an
external executable program, and how logical data
types are mapped to command line arguments.
			</para>

			<para>
Atomic procedures are defined with the <literal>app</literal> keyword:
<programlisting>
app (binaryfile bf) myproc (int i, string s="foo") {
	myapp i s @filename(bf);
}			
</programlisting>

which specifies that <literal>myproc</literal> invokes an executable
called <literal>myapp</literal>,
passing the values of <literal>i</literal>, <literal>s</literal>
and the filename of <literal>bf</literal> as command line arguments.
			</para>
</section>

<section id="procedures.compound"><title>Compound procedures</title>
			<para>
A compound procedure contains a set of SwiftScript statements:

<programlisting>
(type2 b) foo_bar (type1 a) {
	type3 c;
	c = foo(a);    // c holds the result of foo
	b = bar(c);    // c is an input to bar
}
</programlisting>
		</para>

		</section>
</section>	
		<section>
			<title>Control Constructs</title>
			<para>
SwiftScript provides <literal>if</literal>, <literal>switch</literal>,
<literal>foreach</literal>, and <literal>iterate</literal> constructs,
with syntax and semantics similar to comparable constructs in
other high-level languages.
			</para>
			<section><title>foreach</title>
			<para>
The <literal>foreach</literal> construct is used to apply a block of statements to
each element in an array. For example:

<programlisting>
check_order (file a[]) {
	foreach f in a {
		compute(f);
	}
}
</programlisting>
</para>
<para>
<literal>foreach</literal> statements have the general form:

<programlisting>
foreach controlvariable (,index) in expression {
    statements
}
</programlisting>

The block of statements is evaluated once for each element in
<literal>expression</literal> which must be an array,
with <literal>controlvariable</literal> set to the corresponding element
and <literal>index</literal> (if specified) set to the
integer position in the array that is being iterated over.

			</para>
			</section>

			<section><title>if</title>
			<para>
The <literal>if</literal> statement allows one of two blocks of statements to be
executed, based on a boolean predicate. <literal>if</literal> statements generally
have the form:
<programlisting>
if(predicate) {
    statements
} else {
    statements
}
</programlisting>

where <literal>predicate</literal> is a boolean expression.
			</para>
			</section>

			<section><title>switch</title>
			<para>
<literal>switch</literal> expressions allow one of a selection of blocks to be chosen based on
the value of a numerical control expression. <literal>switch</literal> statements take the
general form:
<programlisting>
switch(controlExpression) {
    case n1:
        statements2
    case n2:
        statements2
    [...]
    default:
        statements
}
</programlisting>
The control expression is evaluated, the resulting numerical value used to
select a corresponding <literal>case</literal>, and the statements belonging to that
<literal>case</literal> block
are evaluated. If no case corresponds, then the statements belonging to
the <literal>default</literal> block are evaluated.
			</para>
<para>Unlike C or Java switch statements, execution does not fall through to
subsequent <literal>case</literal> blocks, and no <literal>break</literal>
statement is necessary at the end of each block.
</para>
			</section>

			<section id="construct.iterate"><title>iterate</title>
				<para>
<literal>iterate</literal> expressions allow a block of code to be evaluated repeatedly, with an
integer parameter sweeping upwards from 0 until a termination condition
holds.
				</para>
				<para>
The general form is:
<programlisting>
iterate var {
	statements;
} until (terminationExpression);
</programlisting>
with the variable <literal>var</literal> starting at 0 and increasing
by one in each iteration. That
variable is in scope in the statements block and when evaluating the
termination expression.
				</para>
			</section>
		</section>
	</section>

	<section><title>Operators</title>

<para>The following infix operators are available for use in
SwiftScript expressions.
</para>
<table frame="all">
<tgroup cols="2" align="left" colsep="1" rowsep="1">
 <thead><row><entry>operator</entry><entry>purpose</entry></row></thead>
 <tbody>
  <row><entry>+</entry><entry>numeric addition; string concatenation</entry></row>
  <row><entry>-</entry><entry>numeric subtraction</entry></row>
  <row><entry>*</entry><entry>numeric multiplication</entry></row>
  <row><entry>/</entry><entry>floating point division</entry></row>
  <row><entry>%/</entry><entry>integer division</entry></row>
  <row><entry>%%</entry><entry>integer remainder of division</entry></row>
  <row><entry>== !=</entry><entry>comparison and not-equal-to</entry></row>
  <row><entry> &lt; &gt; &lt;= &gt;=</entry><entry>numerical ordering</entry></row>
  <row><entry>&amp;&amp; ||</entry><entry>boolean and, or</entry></row>
  <row><entry>!</entry><entry>boolean not</entry></row>
 </tbody>
</tgroup>
</table>
	</section>

</section>
		<section id="mappers">
		<title>Mappers</title>
		<para>
Mappers provide a mechanism to specify the layout of mapped datasets on
disk. This is needed when Swift must access files to transfer them to
remote sites for execution or to pass to applications.</para>
		<para>
Swift provides a number of mappers that are useful in common cases. This
section details those standard mappers. For more complex cases, it is
possible to write application-specific mappers in Java and
use them within a SwiftScript program. For more information on writing
an application specific mapper, see the tutorial module on mappers.
		</para>

		<section id="mapper.single_file_mapper"><title>The single file mapper</title>

			<para>
The <literal>single_file_mapper</literal> maps a single physical file to a dataset.
			</para>		
<para>
		<screen>

    Swift variable -------------------&gt;  Filename

       f                                 myfile

       f[0]                              INVALID

       f.bar                             INVALID

		</screen>
</para>

<table frame="all">
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
 <thead>
  <row>
   <entry>parameter</entry>
   <entry>meaning</entry>
  </row>
 </thead>
 <tbody>
  <row><entry>file</entry><entry>The location of the physical file including path and file name.</entry></row>
 </tbody>
</tgroup>
</table> 

<para>Example:
			<programlisting>
	file f &lt;single_file_mapper;file="plot_outfile_param"&gt;;</programlisting>

There is a simplified syntax for this mapper:


			<programlisting>
	file f &lt;"plot_outfile_param"&gt;;</programlisting>
</para>
	</section>

	<section id="mapper.simple_mapper"><title>The simple mapper</title>
<para>The <literal>simple_mapper</literal> maps a file or a list of files
into an array by prefix, suffix, and pattern.  If more than one file is
matched, each of the file names will be mapped as a subelement of the dataset.
</para>

<table frame="all">
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
 <thead>
  <row>
   <entry>parameter</entry>
   <entry>meaning</entry>
  </row>
 </thead>
 <tbody>
  <row><entry>location</entry><entry>A directory that the files are located.</entry></row>
  <row><entry>prefix</entry><entry>The prefix of the files</entry></row>
  <row><entry>suffix</entry><entry>The suffix of the files, for instance: <literal>&quot;.txt&quot;</literal></entry></row>
  <row><entry>pattern</entry><entry>A UNIX glob style pattern, for instance:
<literal>&quot;*foo*&quot;</literal> would match all file names that
contain <literal>foo</literal>. When this mapper is used to specify output
filenames, <literal>pattern</literal> is ignored.</entry></row>
 </tbody>
</tgroup>
</table> 



<para>Examples:</para>

<para>
		<programlisting>
	type file;
	file f &lt;simple_mapper;prefix="foo", suffix=".txt"&gt;;
			</programlisting>
The above maps all filenames that start with <filename>foo</filename> and
have an extension <filename>.txt</filename> into file f.

		<screen>

    Swift variable -------------------&gt;  Filename

       f                                 foo.txt

		</screen>
</para>

<para>
	<programlisting>
type messagefile;

(messagefile t) greeting(string m) {.
    app {
        echo m stdout=@filename(t);
    }
}

messagefile outfile &lt;simple_mapper;prefix="foo",suffix=".txt"&gt;;

outfile = greeting("hi");
	</programlisting>

This will output the string 'hi' to the file <filename>foo.txt</filename>.
	</para>

	<para>
The <literal>simple_mapper</literal> can be used to map arrays. It will map the array index
into the filename between the prefix and suffix.

<programlisting>
type messagefile;

(messagefile t) greeting(string m) { 
    app {
        echo m stdout=@filename(t);
    }
}

messagefile outfile[] &lt;simple_mapper;prefix="baz",suffix=".txt"&gt;;

outfile[0] = greeting("hello");
outfile[1] = greeting("middle");
outfile[2] = greeting("goodbye");
</programlisting>

		<screen>

    Swift variable -------------------&gt;  Filename

       outfile[0]                        baz0000.txt
       outfile[1]                        baz0001.txt
       outfile[2]                        baz0002.txt

		</screen>

	</para>

	<para>
<literal>simple_mapper</literal> can be used to map structures. It will map the name of the
structure member into the filename, between the prefix and the
suffix.

	<programlisting>
type messagefile;

type mystruct {
  messagefile left;
  messagefile right;
};

(messagefile t) greeting(string m) { 
    app {
        echo m stdout=@filename(t);
    }
}

mystruct out &lt;simple_mapper;prefix="qux",suffix=".txt"&gt;;

out.left = greeting("hello");
out.right = greeting("goodbye");
	</programlisting>

This will output the string &quot;hello&quot; into the file
<filename>qux.left.txt</filename> and the string &quot;goodbye&quot;
into the file <filename>qux.right.txt</filename>.

		<screen>

    Swift variable -------------------&gt;  Filename

       out.left                          quxleft.txt
       out.right                         quxright.txt

		</screen>
	</para>

	</section>

	<section id="mapper.concurrent_mapper"><title>concurrent mapper</title>
<para>
<literal>concurrent_mapper</literal> is almost the same as the simple mapper,
except that it is used to map an output file, and the filename
generated will contain an extract sequence that is unique.
This mapper is the default mapper for variables when no mapper is
specified.
</para>

<table frame="all">
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
 <thead>
  <row>
   <entry>parameter</entry>
   <entry>meaning</entry>
  </row>
 </thead>
 <tbody>
  <row><entry>location</entry><entry>A directory that the files are located.</entry></row>
  <row><entry>prefix</entry><entry>The prefix of the files</entry></row>
  <row><entry>suffix</entry><entry>The suffix of the files, for instance: <literal>&quot;.txt&quot;</literal></entry></row>
  <row><entry>pattern</entry><entry>A UNIX glob style pattern, for instance:
<literal>&quot;*foo*&quot;</literal> would match all file names that
contain <literal>foo</literal>. When this mapper is used to specify output
filenames, <literal>pattern</literal> is ignored.</entry></row>
 </tbody>
</tgroup>
</table>
  

	<para>Example:
		<programlisting>
	file f1;
	file f2 &lt;concurrent_mapper;prefix="foo", suffix=".txt"&gt;;
			</programlisting>
The above example would use concurrent mapper for <literal>f1</literal> and
<literal>f2</literal>, and 
generate <literal>f2</literal> filename with prefix <filename>&quot;foo&quot;</filename> and extension <filename>&quot;.txt&quot;</filename>
	</para>
	</section>

	<section id="mapper.filesys_mapper"><title>file system mapper</title>

<para><literal>filesys_mapper</literal> is similar to the simple mapper,
but maps a file or 
a list of files to an array. Each of the filename is 
mapped as an element in the array. The order of files in the resulting
array is not defined.
	</para>

<para>TODO: note on difference between location as a relative vs absolute
path wrt staging to remote location - as mihael said:
It's because you specify that location in the mapper. Try location="."
instead of location="/sandbox/..."</para>
 
<table frame="all">
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
 <thead>
  <row>
   <entry>parameter</entry>
   <entry>meaning</entry>
  </row>
 </thead>
 <tbody>
  <row><entry>location</entry><entry>The directory where the files are located.</entry></row>
  <row><entry>prefix</entry><entry>The prefix of the files</entry></row>
  <row><entry>suffix</entry><entry>The suffix of the files, for instance: <literal>&quot;.txt&quot;</literal></entry></row>
  <row><entry>pattern</entry><entry>A UNIX glob style pattern, for instance:
<literal>&quot;*foo*&quot;</literal> would match all file names that
contain <literal>foo</literal>.
</entry></row>
 </tbody>
</tgroup>
</table>
  
	<para>Example:
			<programlisting>
	file texts[] &lt;filesys_mapper;prefix="foo", suffix=".txt"&gt;;
			</programlisting>
The above example would map all filenames that start with <filename>&quot;foo&quot;</filename> 
and have an extension <filename>&quot;.txt&quot;</filename> into the array <literal>texts</literal>.
For example, if the specified directory contains files: <filename>foo1.txt</filename>, <filename>footest.txt</filename>,
<filename>foo__1.txt</filename>, then the mapping might be:
		<screen>

    Swift variable -------------------&gt;  Filename

       texts[0]                          footest.txt
       texts[1]                          foo1.txt
       texts[2]                          foo__1.txt

		</screen>
</para>
	</section>

	<section id="mapper.fixed_array_mapper"><title>fixed array mapper</title>
<para>The <literal>fixed_array_mapper</literal> maps from a string that
contains a list of filenames into a file array.</para>

<table frame="all">
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
 <thead>
  <row>
   <entry>parameter</entry>
   <entry>meaning</entry>
  </row>
 </thead>
 <tbody>
  <row><entry>files</entry><entry>A string that contains a list of filenames, separated by space, comma or colon</entry></row>
  </tbody>
 </tgroup>
</table>

	<para>Example:
			<programlisting>
	file texts[] &lt;fixed_array_mapper;files="file1.txt, fileB.txt, file3.txt"&gt;;
			</programlisting>
would cause a mapping like this:
		<screen>

    Swift variable -------------------&gt;  Filename

       texts[0]                          file1.txt
       texts[1]                          fileB.txt
       texts[2]                          file3.txt

		</screen>
</para>
	</section>

	<section id="mapper.array_mapper"><title>array mapper</title>
	<para>The <literal>array_mapper</literal> maps from an array of strings
into a file</para>

<table frame="all">
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
 <thead>
  <row>
   <entry>parameter</entry>
   <entry>meaning</entry>
  </row>
 </thead>
 <tbody>
  <row><entry>files</entry><entry>An array of strings containing one filename per element</entry></row>
  </tbody>
</tgroup>
</table>

	<para> Example:
		<programlisting>
string s[] = [ "a.txt", "b.txt", "c.txt" ];

file f[] &lt;array_mapper;files=s&gt;;
		</programlisting>
This will establish the mapping:
		<screen>

    Swift variable -------------------&gt;  Filename

       f[0]                              a.txt
       f[1]                              b.txt
       f[2]                              c.txt

		</screen>

	</para>
	</section>

	<section id="mapper.regexp_mapper"><title>regular expression mapper</title>
<para>The <literal>regexp_mapper</literal> transforms one file name to
another using regular expression matching.</para>


<table frame="all">
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
 <thead>
  <row>
   <entry>parameter</entry>
   <entry>meaning</entry>
  </row>
 </thead>
 <tbody>
    <row><entry>source</entry><entry>The source file name</entry></row>
    <row><entry>match</entry><entry>Regular expression pattern to match, use
<literal>()</literal> to match whatever regular expression is inside the
parentheses, and indicate the start and end of a group; the contents of a
group can be retrieved with the <literal>\number</literal> special
sequence</entry></row>
    <row><entry>transform</entry><entry>The pattern of the file name to
transform to, use <literal>\number</literal> to reference the
group matched.</entry></row>
 </tbody>
</tgroup>
</table>

<para>Example:
	<programlisting>
  string s = "picture.gif";
  file f &lt;regexp_mapper;
    source=s,
    match=&quot;(.*)gif&quot;,
    transform=&quot;\1jpg&quot;>; </programlisting>

This example transforms a string ending <literal>gif</literal> into one
ending <literal>jpg</literal> and maps that to a file.

		<screen>
    Swift variable -------------------&gt;  Filename

       f                                    picture.jpg
		</screen>

</para>

</section>

<section><title>csv mapper</title>

<para>
The <literal>csv_mapper</literal> maps the content of a CSV (comma-separated
value) file into an array of structures. The dataset type needs to be
correctly defined to conform to the column names in the
file. For instance, if the file contains columns:
<literal>name age GPA</literal> then the type needs to have member elements
like this:
<programlisting>
  type student {
    file name;
    file age;
    file GPA;
  }
</programlisting>

If the file does not contain a header with column info, then the column
names are assumed as <literal>column1</literal>, <literal>column2</literal>,
etc.
</para>

<table frame="all">
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
 <thead>
  <row>
   <entry>parameter</entry>
   <entry>meaning</entry>
  </row>
 </thead>
 <tbody>
    <row><entry>file</entry><entry>The name of the CSV file to read mappings from.</entry></row>
    <row><entry>header</entry><entry>Whether the file has a line describing header info; default is <literal>true</literal></entry></row>
    <row><entry>skip</entry><entry>The number of lines to skip at the beginning (after header line); default is <literal>0</literal>.</entry></row>
    <row><entry>hdelim</entry><entry>Header field delimiter; default is the value of the <literal>delim</literal> parameter</entry></row>
    <row><entry>delim</entry><entry>Content field delimiters; defaults are space, tab and comma</entry></row>
 </tbody>
</tgroup>
</table>
 
	<para>Example:
			<programlisting>
	student stus[] &lt;csv_mapper;file="stu_list.txt"&gt;;
			</programlisting>
The above example would read a list of student info from file 
<filename>&quot;stu_list.txt&quot;</filename> and map them into a student array. By default, the file should contain a header line specifying the names of the columns.
If <filename>stu_list.txt</filename> contains the following:
<screen>
name,age,gpa
101-name.txt, 101-age.txt, 101-gpa.txt
name55.txt, age55.txt, age55.txt
q, r, s
</screen>
then some of the mappings produced by this example would be:
		<screen>

    Swift variable -------------------&gt;  Filename

       stus[0].name                         101-name.txt
       stus[0].age                          101-age.txt
       stus[0].gpa                          101-gpa.txt
       stus[1].name                         name55.txt
       stus[1].age                          age55.txt
       stus[1].gpa                          gpa55.txt
       stus[2].name                         q
       stus[2].age                          r
       stus[2].gpa                          s

		</screen>
</para>
	</section>

	<section id="mapper.ext_mapper"><title>external mapper</title>
		<para>
The external mapper, <literal>ext</literal> maps based on the output of a
supplied Unix executable.
		</para>

<table frame="all">
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
 <thead>
  <row>
   <entry>parameter</entry>
   <entry>meaning</entry>
  </row>
 </thead>
 <tbody>
    <row><entry>exec</entry><entry>The name of the executable
(relative to the current directory, if an absolute path is not
specified)</entry></row>
    <row><entry>*</entry><entry>Other parameters are passed to the
executable prefixed with a <literal>-</literal> symbol</entry></row>
 </tbody>
</tgroup>
</table>

	<para>   
The output of the executable should consist of two columns of data, separated
by a space. The first column should be the path of the mapped variable,
in SwiftScript syntax (for example <literal>[2]</literal> means the 2nd element of an
array) or the symbol <literal>$</literal> to represent the root of the mapped variable.
	</para>

	<para> Example:
With the following in <filename>mapper.sh</filename>,
			<screen>
#!/bin/bash
echo "[2] qux"
echo "[0] foo"
echo "[1] bar"
			</screen>

then a mapping statement:

			<programlisting>
	student stus[] &lt;ext;exec="mapper.sh"&gt;;
			</programlisting>

would map

		<screen>

    Swift variable -------------------&gt;  Filename

       stus[0]                              foo
       stus[1]                              bar
       stus[2]                              qux

		</screen>

		</para>

	</section>

	</section>
	<section id="swiftcommand">
	<title>The swift command</title>
	<para>
The <command>swift</command> command is the main command line tool
for executing SwiftScript programs.
	</para>
	<section><title>Command-line Syntax</title>
<para>The <command>swift</command> command is invoked as follows:
<command>swift [options] SwiftScript-program [SwiftScript-arguments]</command>
with options taken from the following list, and SwiftScript-arguments
made available to the SwiftScript program through the
<link linkend="function.arg">@arg</link> function.
</para>
  <variablelist><title>Swift command-line options</title>
  <varlistentry><term>-help or -h</term>
    <listitem><para>
      Display usage information </para></listitem>
  </varlistentry>
  <varlistentry><term>-typecheck</term>
    <listitem><para>
      Does a typecheck of a SwiftScript program, instead of executing it.</para></listitem>
  </varlistentry>

  <varlistentry><term>-dryrun</term>
    <listitem><para>
      Runs the SwiftScript program without submitting any jobs (can be used to get
      a graph)
    </para></listitem>
  </varlistentry>

  <varlistentry><term>-monitor</term>
    <listitem><para>
      Shows a graphical resource monitor 
    </para></listitem>
  </varlistentry>

  <varlistentry><term>-resume <literal>file</literal></term>
    <listitem><para>
      Resumes the execution using a log file 
    </para></listitem>
  </varlistentry>

  <varlistentry><term>-config <literal>file</literal></term>
    <listitem><para>
      Indicates the Swift configuration file to be used for this run. 
      Properties in this configuration file will override the default 
      properties. If individual command line arguments are used for 
      properties, they will override the contents of this file. 
    </para></listitem>
  </varlistentry>

  <varlistentry><term>-verbose | -v</term>
    <listitem><para>
      Increases the level of output that Swift produces on the console 
      to include more detail about the execution 
    </para></listitem>
  </varlistentry>

  <varlistentry><term>-debug | -d</term>
    <listitem><para>
      Increases the level of output that Swift produces on the console 
      to include lots of detail about the execution 
    </para></listitem>
  </varlistentry>

  <varlistentry><term>-logfile <literal>file</literal></term>
    <listitem><para>
      Specifies a file where log messages should go to. By default 
      Swift uses the name of the program being run and a numeric index
      (e.g. myworkflow.1.log) 
    </para></listitem>
  </varlistentry>

  <varlistentry><term>-runid <literal>identifier</literal></term>
    <listitem><para>
      Specifies the run identifier. This must be unique for every invocation
      and is used in several places to keep files from different executions
      cleanly separated. By default, a datestamp and random number are used
      to generate a run identifier. When using this parameter, care should be
      taken to ensure that the run ID remains unique with respect to all
      other run IDs that might be used, irrespective of (at least) expected
      execution sites, program or user.
    </para></listitem>
  </varlistentry>

  <varlistentry><term>-tui</term>
    <listitem>
      Displays an interactive text mode monitor during a run. (since Swift 0.9)
    </listitem>
  </varlistentry>

</variablelist>

<para>In addition, the following Swift properties can be set on the
command line:

<itemizedlist>
<listitem>caching.algorithm</listitem>
<listitem>clustering.enabled</listitem>
<listitem>clustering.min.time</listitem>
<listitem>clustering.queue.delay</listitem>
<listitem>ip.address</listitem>
<listitem>kickstart.always.transfer</listitem>
<listitem>kickstart.enabled</listitem>
<listitem>lazy.errors</listitem>
<listitem>pgraph</listitem>
<listitem>pgraph.graph.options</listitem>
<listitem>pgraph.node.options</listitem>
<listitem>sitedir.keep</listitem>
<listitem>sites.file</listitem>
<listitem>tc.file</listitem>
<listitem>tcp.port.range</listitem>
</itemizedlist>
</para>

	</section>
	<section><title>Return codes</title>
	<para>
The <command>swift</command> command may exit with the following return codes:
<table frame="all">
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
 <thead>
  <row>
   <entry>value</entry>
   <entry>meaning</entry>
  </row>
 </thead>
 <tbody>
  <row><entry>0</entry><entry>success</entry></row>
  <row><entry>1</entry><entry>command line syntax error or missing project name</entry></row>
  <row><entry>2</entry><entry>error during execution</entry></row>
  <row><entry>3</entry><entry>error during compilation</entry></row>
  <row><entry>4</entry><entry>input file does not exist</entry></row>
 </tbody>
 </tgroup>
</table>
	</para>
	</section>
	</section>
	<section id="appmodel"> <title>Executing <literal>app</literal> procedures</title>
	<para>
This section describes how Swift executes <literal>app</literal> procedures,
and requirements on the behaviour of application programs used in
<literal>app</literal> procedures.
These requirements are primarily to ensure
that the Swift can run your application in different places and with the
various fault tolerance mechanisms in place.
	</para>

<section><title>Mapping of <literal>app</literal> semantics into unix
process execution semantics</title>

<para>This section describes how an <literal>app</literal> procedure
invocation is translated into a (remote) unix process execution. It does not
describe the mechanisms by which Swift performs that translation; that
is described in the next section.</para>

<para>In this section, this example SwiftScript program is used
for reference:</para>

<programlisting>
 type file;

 app (file o) count(file i) {
   wc @i stdout=@o;
 }

 file q &lt;"input.txt">;
 file r &lt;"output.txt">;
</programlisting>

<para>
The executable for wc will be looked up in tc.data.
</para>

<para>
This unix executable will then be executed in some <firstterm>application
procedure workspace</firstterm>. This means:
</para>

<para>
Each application procedure workspace will have an application workspace 
directory.  (TODO: can collapse terms //application procedure workspace// 
and //application workspace directory// ?
</para>

<para>
This application workspace directory will not be shared with any other 
<firstterm>application procedure execution attempt</firstterm>; all
application procedure 
execution attempts will run with distinct application procedure 
workspaces. (for the avoidance of doubt:
 If a <firstterm>SwiftScript procedure invocation</firstterm> is subject
to multiple application procedure execution attempts (due to Swift-level
restarts, retries or replication) then each of those application procedure
execution attempts will be made in a different application procedure workspace.
)</para>

<para>
The application workspace directory will be a directory on a POSIX 
filesystem accessible throughout the application execution by the 
application executable.
</para>

<para>
Before the <firstterm>application executable</firstterm> is executed:
</para>

<itemizedlist>

<listitem><para>
The application workspace directory will exist.
</para></listitem>

<listitem><para>
The <firstterm>input files</firstterm> will exist inside the application workspace 
directory (but not necessarily as direct children; there may be 
subdirectories within the application workspace directory).
</para></listitem>

<listitem><para>
The input files will be those files <firstterm>mapped</firstterm>
to <firstterm>input parameters</firstterm> of the application procedure
invocation. (In the example, this means that the file
<filename>input.txt</filename> will exist in the application workspace
directory)
</para></listitem>

<listitem><para>
For each input file dataset, it will be the case that
<literal>@filename</literal> or 
<literal>@filenames</literal> invoked with that dataset as a parameter
will return the path 
relative to the application workspace directory for the file(s) that are 
associated with that dataset. (In the example, that means that <literal>@i</literal> will 
evaluate to the path <filename>input.txt</filename>)
</para></listitem>

<listitem><para>
For each <firstterm>file-bound</firstterm> parameter of the Swift procedure invocation, the 
associated files (determined by data type?) will always exist.
</para></listitem>

<listitem><para>
The input files must be treated as read only files. This may or may not 
be enforced by unix file system permissions. They may or may not be copies
of the source file (conversely, they may be links to the actual source file).
</para></listitem>

</itemizedlist>

<para>
During/after the <firstterm>application executable execution</firstterm>,
the following must be true:
</para>

<itemizedlist>
<listitem><para>
If the application executable execution was successful (in the opinion 
of the application executable), then the application executable should 
exit with <firstterm>unix return code</firstterm> <literal>0</literal>;
if the application executable execution 
was unsuccessful (in the opinion of the application executable), then the 
application executable should exit with unix return code not equal to 
<literal>0</literal>.
</para></listitem>

<listitem><para>
Each file mapped from an output parameter of the SwiftScript procedure 
call must exist. Files will be mapped in the same way as for input files.
</para>
<para>
(? Is it defined that output subdirectories will be precreated before 
execution or should app executables expect to make them? That's probably 
determined by the present behaviour of wrapper.sh)
</para></listitem>

<listitem><para>
Output produced by running the application executable on some inputs should
be the same no matter how many times, when or where that application
executable is run. 'The same' can vary depending on application (for example,
in an application it might be acceptable for a PNG->JPEG conversion to
produce different, similar looking, output jpegs depending on the
environment)
</para></listitem>

</itemizedlist>

<para>
Things to not assume:
</para>

<itemizedlist>

<listitem><para>
anything about the path of the application workspace directory
</para></listitem>

<listitem><para>
that either the application workspace directory will be deleted or will 
continue to exist or will remain unmodified after execution has finished
</para></listitem>

<listitem><para>
that files can be passed(?def) between application procedure invocations 
through any mechanism except through files known to Swift through the 
mapping mechanism (there is some exception here for <literal>external</literal>
datasets - there are a separate set of assertions that hold for 
<literal>external</literal> datasets)
</para></listitem>

<listitem><para>
that application executables will run on any particular site of those
available, or than any combination of applications will run on the same or
different sites.
</para></listitem>

</itemizedlist>

</section>

<section><title>
notes on how swift implements file input and output
</title>

<para>
This section describes the implementation of the semantics described
in the previous section.
</para>

<para>
Swift executes application procedures on one or more <firstterm>sites</firstterm>.
</para>

<para>
Each site consists of:
</para>

<itemizedlist>
<listitem><para>
worker nodes. There is some <firstterm>execution mechanism</firstterm>
through which the Swift client side executable can execute its
<firstterm>wrapper script</firstterm> on those 
worker nodes. This is commonly GRAM or Falkon or coasters.
</para></listitem>

<listitem><para>
a site-shared file system. This site shared filesystem is accessible 
through some <firstterm>file transfer mechanism</firstterm> from the
Swift client side 
executable. This is commonly GridFTP or coasters. This site shared 
filesystem is also accessible through the posix file system on all worker 
nodes, mounted at the same location as seen through the file transfer 
mechanism. Swift is configured with the location of some <firstterm>site working 
directory</firstterm> on that site-shared file system.
</para></listitem>
</itemizedlist>

<para>
There is no assumption that the site shared file system for one site is 
accessible from another site.
</para>

<para>
For each workflow run, on each site that is used by that run, a <firstterm>run 
directory</firstterm> is created in the site working directory, by the Swift client 
side.
</para>

<para>
In that run directory are placed several subdirectories:
</para>

<itemizedlist>
<listitem><para>
<filename>shared/</filename> - site shared files cache
</para></listitem>

<listitem><para>
<filename>kickstart/</filename> - when kickstart is used, kickstart record files 
for each job that has generated a kickstart record.
</para></listitem>


<listitem><para>
<filename>info/</filename> - wrapper script log files
</para></listitem>

<listitem><para>
<filename>status/</filename> - job status files
</para></listitem>

<listitem><para>
<filename>jobs/</filename>  //application workspace directories// (optionally placed here - 
see below)
</para></listitem>
</itemizedlist>

<para>
Application execution looks like this:
</para>

<para>
For each application procedure call:
</para>

<para>
The Swift client side selects a site; copies the input files for that 
procedure call to the site shared file cache if they are not already in 
the cache, using the file transfer mechanism; and then invokes the wrapper 
script on that site using the execution mechanism.
</para>

<para>
The wrapper script creates the application workspace directory; places the 
input files for that job into the application workspace directory using 
either <literal>cp</literal> or <literal>ln -s</literal> (depending on a configuration option); executes the 
application unix executable; copies output files from the application 
workspace directory to the site shared directory using <literal>cp</literal>; creates a 
status file under the <filename>status/</filename> directory; and exits, returning control to
the Swift client side. Logs created during the execution of the wrapper 
script are stored under the <filename>info/</filename> directory.
</para>

<para>
The Swift client side then checks for the presence of and deletes a status 
file indicating success; copies files from the site shared directory to 
the appropriate client side location.
</para>

<para>
The job directory is created (in the default mode) under the <filename>jobs/</filename> 
directory. However, it can be created under an arbitrary other path, which 
allows it to be created on a different file system (such as a worker node 
local file system in the case that the worker node has a local file 
system).
</para>

</section>
<imagedata fileref="swift-site-model.png" />
	</section>

	<section id="techoverview">
	<title>Technical overview of the Swift architecture</title>
	<para>
This section attempts to provide a technical overview of the Swift
architecture.
	</para>

	<section><title>karajan - the core execution engine</title>
	</section>

	<section><title>Execution layer</title>
	<para>
The execution layer causes an application program (in the form of a unix
executable) to be executed either locally or remotely.
	</para>
	<para>
The two main choices are local unix execution and execution through GRAM.
Other options are available, and user provided code can also be plugged in.
	</para>
	<para>
The <link linkend="kickstart">kickstart</link> utility can
be used to capture environmental information at execution time
to aid in debugging and provenance capture. 
	</para>
	</section>

	<section><title>SwiftScript language compilation layer</title>
	<para>
Step i: text to XML intermediate form parser/processor. parser written in
ANTLR - see resources/VDL.g. The XML Schema Definition (XSD) for the
intermediate language is in resources/XDTM.xsd.
	</para>
	<para>
Step ii: XML intermediate form to Karajan workflow. Karajan.java - reads
the XML intermediate form. compiles to karajan workflow language - for
example, expressions are converted from SwiftScript syntax into Karajan
syntax, and function invocations become karajan function invocations
with various modifications to parameters to accomodate return parameters
and dataset handling.
	</para>
	</section>

	<section><title>Swift/karajan library layer</title>
	<para>
Some Swift functionality is provided in the form of Karajan libraries
that are used at runtime by the Karajan workflows that the Swift
compiler generates.
	</para>
	</section>

	</section>

	<section id="extending"><title>Ways in which Swift can be extended</title>
<para>Swift is extensible in a number of ways. It is possible to add
mappers to accomodate different filesystem arrangements, site selectors
to change how Swift decides where to run each job, and job submission
interfaces to submit jobs through different mechanisms.
</para>
<para>A number of mappers are provided as part of the Swift release and
documented in the <link linkend="mappers">mappers</link> section.
New mappers can be implemented
in Java by implementing the org.griphyn.vdl.mapping.Mapper interface. The
<ulink url="http://www.ci.uchicago.edu/swift/guides/tutorial.php">Swift
tutorial</ulink> contains a simple example of this.
</para>
<para>Swift provides a default site selector, the Adaptive Scheduler.
New site selectors can be plugged in by implementing the
org.globus.cog.karajan.scheduler.Scheduler interface and modifying
libexec/scheduler.xml and etc/karajan.properties to refer to the new
scheduler.
</para>
<para>Execution providers and filesystem providers, which allow to Swift
to execute jobs and to stage files in and out through mechanisms such
as GRAM and GridFTP can be implemented as Java CoG kit providers.
</para>
	</section>

	<section id="functions"><title>Function reference</title>
		<para>
This section details functions that are available for use in the SwiftScript
language.
		</para>
		<section id="function.arg"><title>@arg</title>
			<para>
Takes a command line parameter name as a string parameter and an optional 
default value and returns the value of that string parameter from the 
command line. If no default value is specified and the command line parameter
is missing, an error is generated. If a default value is specified and the
command line parameter is missing, <literal>@arg</literal> will return the default value.
			</para>
			<para>
Command line parameters recognized by <literal>@arg</literal> begin with exactly one hyphen
and need to be positioned after the script name.
			</para>

			<para>For example:</para>
			<programlisting>
trace(@arg("myparam"));
trace(@arg("optionalparam", "defaultvalue"));
			</programlisting>
			<screen>
$ <userinput>swift arg.swift -myparam=hello</userinput>
Swift v0.3-dev r1674 (modified locally)

RunID: 20080220-1548-ylc4pmda
SwiftScript trace: defaultvalue
SwiftScript trace: hello
			</screen>

		</section>

		<section id="function.extractint"><title>@extractint</title>
			<para>
<literal>@extractint(file)</literal> will read the specified file, parse an integer from the
file contents and return that integer.
			</para>
		</section>

		<section id="function.filename"><title>@filename</title>
			<para>
<literal>@filename(v)</literal> will return a string containing the filename(s) for the file(s)
mapped to the variable <literal>v</literal>. When more than one filename is returned, the
filenames will be space separated inside a single string return value.
			</para>
		</section>
		<section id="function.filenames"><title>@filenames</title>
			<para>
<literal>@filenames(v)</literal> will return multiple values (!) containing the filename(s) for
the file(s) mapped to the variable <literal>v</literal>. (compare to
<link linkend="function.filename">@filename</link>)
			</para>
		</section>
		<section id="function.regexp"><title>@regexp</title>
			<para>
<literal>@regexp(input,pattern,replacement)</literal> will apply regular expression
substitution using the <ulink url="http://java.sun.com/j2se/1.4.2/docs/api/java/util/regex/Pattern.html">Java java.util.regexp API</ulink>. For example:
<programlisting>
string v =  @regexp("abcdefghi", "c(def)g","monkey");
</programlisting>
will assign the value <literal>"abmonkeyhi"</literal> to the variable <literal>v</literal>.
			</para>
		</section>
		<section id="function.strcat"><title>@strcat</title>
			<para>
<literal>@strcat(a,b,c,d,...)</literal> will return a string containing all of the strings
passed as parameters joined into a single string. There may be any number
of parameters.
			</para>
			<para>
The <literal>+</literal> operator concatenates two strings: <literal>@strcat(a,b)</literal> is the same as <literal>a + b</literal>
			</para>
		</section>
		<section id="function.strcut"><title>@strcut</title>
			<para>
<literal>@strcut(input,pattern)</literal> will match the regular expression in the pattern
parameter against the supplied input string and return the section that
matches the first matching parenthesised group.
			</para>
			<para>
For example:
			</para>

			<programlisting>
string t = "my name is John and i like puppies.";
string name = @strcut(t, "my name is ([^ ]*) ");
string out = @strcat("Your name is ",name);
print(out);
			</programlisting>

			<para>
will output the message: <literal>Your name is John</literal>.
			</para>
		</section>
		
		<section id="function.strsplit"><title>@strsplit</title>
			<para>
<literal>@strsplit(input,pattern)</literal> will split the input string based on separators
that match the given pattern and return a string array. (since Swift 0.9)
			</para>
			<para>
Example:
			</para>

			<programlisting>
string t = "my name is John and i like puppies.";
string words[] = @strsplit(t, "\\s");
foreach word in words {
	print(word);
}
			</programlisting>

			<para>
will output one word of the sentence on each line (though
not necessarily in order, due to the fact that foreach 
iterations execute in parallel).
			</para>
		</section>

		
		<section id="function.toint"><title>@toint</title>
			<para>
<literal>@toint(input)</literal> will parse its input string into an integer. This can be
used with <literal>@arg</literal> to pass input parameters to a SwiftScript program as
integers.
			</para>
		</section>
	</section>

	<section id="procedures"><title>Built-in procedure reference</title>
		<para>
This section details built-in procedures that are available for use in
the SwiftScript language.
		</para>

		<section id="procedure.readdata"><title>readData</title>
			<para>
<literal>readData</literal> will read data from a specified file.
			</para>
			<para>
The format of the input file is controlled by the type of the return
value.
			</para>

			<para>
For scalar return types, such as int, the specified file should contain
a single value of that type.
			</para>
			<para>
For arrays of scalars, the specified file should contain one value
per line.
			</para>
			<para>
For structs of scalars, the file should contain two rows.
The first row should be structure member names separated by whitespace.
The second row should be the corresponding values for each structure
member, separated by whitespace, in the same order as the header row.
			</para>
			<para>
For arrays of structs, the file should contain a heading row listing
structure member names separated by whitespace. There should be one row
for each element of the array, with structure member elements listed in
the same order as the header row and separated by whitespace. (since Swift 0.4)
			</para>

		</section>
		<section id="procedure.readdata2"><title>readdata2</title>
			<para>
<literal>readdata2</literal> will read data from a specified file, like <literal>readdata</literal>, but using
a different file format more closely related to that used by the
ext mapper.
			</para>
			<para>
Input files should list, one per line, a path into a Swift structure, and
the value for that position in the structure:
				<screen>
rows[0].columns[0] = 0                                                          
rows[0].columns[1] = 2                                                          
rows[0].columns[2] = 4                                                          
rows[1].columns[0] = 1                                                          
rows[1].columns[1] = 3                                                          
rows[1].columns[2] = 5 
				</screen>
which can be read into a structure defined like this:
				<programlisting>
type vector {                                                                   
        int columns[];                                                          
}                                                                               
                                                                                
type matrix {                                                                   
        vector rows[];                                                          
}                                                                               
                                                                                
matrix m;                                                                       
                                                                                
m = readData2("readData2.in");    
				</programlisting>
			</para>
			
			<para>
(since Swift 0.7)
			</para>
		</section>
		<section id="procedure.print"><title>print</title>
			<para>
Deprecated - use <literal><link linkend="procedure.trace">trace</link></literal> instead.
			</para>
			<para>
print will print its parameters to stdout; but will do this at a point
in execution that is undefined. Specifically, it will not necessarily
wait for its parameters to be properly set.
			</para>
		</section>
		<section id="procedure.trace"><title>trace</title>
			<para>
<literal>trace</literal> will log its parameters. By default these will appear on both stdout
and in the run log file. Some formatting occurs to produce the log message.
The particular output format should not be relied upon. (new in 0.4)
			</para>
		</section>

	</section>

	<section id="engineconfiguration">	
	
		<title>Swift configuration properties</title>
		
		<para>
		
			Various aspects of the behavior of the Swift Engine can be
			configured through properties. The Swift Engine recognizes a global,
			per installation properties file which can found in <filename
			class="file">etc/swift.properties</filename> in the Swift installation directory and a user
			properties file which can be created by each user in <filename
			class="file">~/.swift/swift.properties</filename>. The Swift Engine
			will first load the global properties file. It will then try to load
			the user properties file. If a user properties file is found,
			individual properties explicitly set in that file will override the
			respective properties in the global properties file. Furthermore,
			some of the properties can be overridden directly using command line
			arguments to the <link
			linkend="swiftcommand"><command>swift</command> command</link>.
		
		</para>
		
			<para>
			
				Swift properties are specified in the following format:
				
<screen>
&lt;name&gt;=&lt;value&gt;
</screen>
			
				The value can contain variables which will be expanded when the
				properties file is read. Expansion is performed when the name of
				the variable is used inside the standard shell dereference
				construct: <literal>${<varname>name</varname>}</literal>. The following variables
				can be used in the Swift configuration file:
				
				<variablelist>
					<title>Swift Configuration Variables</title>
					
					<varlistentry>
						<term>
							<varname>swift.home</varname>
						</term>
						<listitem>
							<para>
							
								Points to the Swift installation directory
								(<filename
								class="directory"><envar>$SWIFT_HOME</envar></filename>). In general, this should not be set
as Swift can find its own installation directory, and incorrectly setting it
may impair the correct functionality of Swift.
							
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<varname>user.name</varname>
						</term>
						<listitem>
							<para>
							
								The name of the current logged in user.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<varname>user.home</varname>
						</term>	
						<listitem>
							<para>
							
								The user's home directory.
								
							</para>
						</listitem>
					</varlistentry>
				</variablelist>
				
				The following is a list of valid Swift properties:
				
				<variablelist>
					<title>Swift Properties</title>
		
					<varlistentry id="property.caching.algorithm">
						<term>
							<property>caching.algorithm</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <literal>LRU</literal>
							</para>
							
							<para>
								Default value: <literal>LRU</literal>
							</para>
						
							<para>
							
								Swift caches files that are staged in on remote
								resources, and files that are produced remotely
								by applications, such that they can be re-used
								if needed without being transfered again.
								However, the amount of remote file system space
								to be used for caching can be limited using the
								<link linkend="profile.swift.storagesize"><property>swift:storagesize</property></link> profile
								entry in the sites.xml file. Example:
								
<screen>

&lt;pool handle="example" sysinfo="INTEL32::LINUX"&gt;
	&lt;gridftp url="gsiftp://example.org" storage="/scratch/swift" major="2" minor="4" patch="3"/&gt;
	&lt;jobmanager universe="vanilla" url="example.org/jobmanager-pbs" major="2" minor="4" patch="3"/&gt;
	&lt;workdirectory&gt;/scratch/swift&lt;/workdirectory&gt;
	&lt;profile namespace="SWIFT" key="storagesize"&gt;20000000&lt;/profile&gt;
&lt;/pool&gt;

</screen>
								
								
								The decision of which files to keep in the cache
								and which files to remove is made considering
								the value of the
								<property>caching.algorithm</property> property. 							
								Currently, the only available value for this 							
								property is <literal>LRU</literal>, which would
								cause the least recently used files to be
								deleted first.
								
							</para>
						</listitem>
					</varlistentry>
				
					<varlistentry id="property.clustering.enabled">
						<term>
							<property>clustering.enabled</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <literal>true</literal>, <literal>false</literal>
							</para>
							
							<para>
								Default value: <literal>false</literal>
							</para>
							
							<para>
								Enables <link linkend="clustering">clustering</link>.
							</para>
							
						</listitem>
					</varlistentry>
						
					<varlistentry id="property.clustering.min.time">
						<term>
							<property>clustering.min.time</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;int&gt;</parameter>
							</para>
							
							<para>
								Default value: <literal>60</literal>
							</para>
						
							<para>
							
								Indicates the threshold wall time for
								clustering, in seconds. Jobs that have a 
								wall time smaller than the value of this
								property will be considered for clustering.
								
							</para>
						</listitem>
					</varlistentry>

					<varlistentry id="property.clustering.queue.delay">
						<term>
							<property>clustering.queue.delay</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;int&gt;</parameter>
							</para>
							
							<para>
								Default value: <literal>4</literal>
							</para>
							
							<para>
							
								This property indicates the interval, in
								seconds, at which the clustering queue is
								processed.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry id="property.execution.retries">
						<term>execution.retries</term>
						<listitem>
							<para>
								Valid values: positive integers
							</para>
							<para>
								Default value: 2
							</para>
							<para>
								The number of time a job will be retried if it
								fails (giving a maximum of 1 +
								execution.retries attempts at execution)
							</para>
						</listitem>
					</varlistentry>
					

					<varlistentry id="property.foreach.max.threads">
						<term>foreach.max.threads</term>
						<listitem>
							<para>
								Valid values: positive integers
							</para>
							<para>
								Default value: 1024
							</para>
							<para>
Limits the number of concurrent iterations that each foreach statement
can have at one time. This conserves memory for swift programs that 
have large numbers of iterations (which would otherwise all be executed
in parallel). (since Swift 0.9)
							</para>
						</listitem>
					</varlistentry>
	

					<varlistentry>
						<term>
							<property>ip.address</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;ipaddress&gt;</parameter>
							</para>
							
							<para>
								Default value: N/A
							</para>
						
							<para>
								The Globus GRAM service uses a callback
								mechanism to send notifications about the status
								of submitted jobs. The callback mechanism
								requires that the Swift client be reachable from
								the hosts the GRAM services are running on.
								Normally, Swift can detect the correct IP address
								of the client machine. However, in certain cases
								(such as the client machine having more than one
								network interface) the automatic detection
								mechanism is not reliable. In such cases, the IP
								address of the Swift client machine can be
								specified using this property. The value of this
								property must be a numeric address without quotes.
							</para>
							<para>
								This option is deprecated and the hostname
								property should be used instead.
							</para>
						</listitem>
					</varlistentry>
		
					<varlistentry>
						<term>
							<property>kickstart.always.transfer</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <literal>true</literal>, <literal>false</literal>
							</para>
							
							<para>
								Default value: <literal>false</literal>
							</para>
							
							<para>
							
								This property controls when output from
								Kickstart is transfered back to the submit site,
								if Kickstart is enabled. When set to
								<literal>false</literal>, Kickstart output is
								only transfered for jobs that fail. If set to
								<literal>true</literal>, Kickstart output is
								transfered after every job is completed or
								failed.
								
							</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<property>kickstart.enabled</property>
						</term>
						<listitem>
							
							<para>
								Valid values: <literal>true</literal>, <literal>false</literal>, <literal>maybe</literal>
							</para>
							
							<para>
								Default value: <literal>maybe</literal>
							</para>
								
							<para>
								
								This option allows controlling of
								when Swift uses <link linkend="kickstart">Kickstart</link>. A value of
								<literal>false</literal> disables the use of
								Kickstart, while a value of
								<literal>true</literal> enables the use of
								Kickstart, in which case sites specified in the
								<filename type="file">sites.xml</filename> file
								must have valid
								<parameter>gridlaunch</parameter> attributes.
								The <literal>maybe</literal> value will
								enable the use of Kickstart only
								on sites that have the
								<parameter>gridlaunch</parameter> attribute
								specified.

							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>lazy.errors</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <literal>true</literal>, <literal>false</literal>
							</para>
							
							<para>
								Default value: <literal>false</literal>
							</para>
						
							<para>
							
								Swift can report application errors in two
								modes, depending on the value of this property.
								If set to <constant>false</constant>, Swift will
								report the first error encountered and
								immediately stop execution. If set to
								<constant>true</constant>, Swift will attempt to
								run as much as possible from a SwiftScript program before
								stopping execution and reporting all errors
								encountered.
							</para>
							<para>When developing SwiftScript programs, using the
								default value of <constant>false</constant> can
								make the program easier to debug. However
								in production runs, using <constant>true</constant>
								will allow more of a SwiftScript program to be run before
								Swift aborts execution.
							</para>
						</listitem>
					</varlistentry>
				
					<varlistentry>
						<term>
							<property>pgraph</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <literal>true</literal>, <literal>false</literal>, <parameter>&lt;file&gt;</parameter>
							</para>
							
							<para>
								Default value: <literal>false</literal>
							</para>
							
							<para>
							
								Swift can generate a 
<ulink url="http://www.graphviz.org/">Graphviz</ulink> file representing 
								the structure of the SwiftScript program it has run. If this
								property is set to <literal>true</literal>,
								Swift will save the provenance graph in a file
								named by concatenating the program name and the
								instance ID (e.g. <filename
								class="file">helloworld-ht0adgi315l61.dot</filename>). 
							</para>
							<para>
								If set to <literal>false</literal>, no
								provenance  graph will be generated. If a file
								name is used, then  the provenance graph will be
								saved in the specified file.
							</para>
							<para>
								The generated dot file can be rendered
								into a graphical form using
								<ulink
								url="http://www.graphviz.org">Graphviz</ulink>,
								for example with a command-line such as:
							</para>
							<screen>
$ <userinput>swift -pgraph graph1.dot q1.swift</userinput>
$ <userinput>dot -ograph.png -Tpng graph1.dot</userinput>
							</screen>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>pgraph.graph.options</property>
						</term>
						<listitem>
							
							<para>
								Valid values: <parameter>&lt;string&gt;</parameter>
							</para>
							
							<para>
								Default value: <literal>splines="compound", rankdir="TB"</literal>
							</para>
						
							<para>
							
								This property specifies a <ulink
								url="http://www.graphviz.org">Graphviz</ulink>
								specific set of parameters for the graph.
								
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>pgraph.node.options</property>
						</term>
						<listitem>
							
							<para>
								Valid values: <parameter>&lt;string&gt;</parameter>
							</para>
							
							<para>
								Default value: <literal>color="seagreen", style="filled"</literal>
							</para>
						
							<para>
							
								Used to specify a set of <ulink
								url="http://www.graphviz.org">Graphviz</ulink>
								specific properties for the nodes in the graph.
								
							</para>
						</listitem>
					</varlistentry>
	
					<varlistentry>
						<term>
							<property>replication.enabled</property>
						</term>
						<listitem>
							
							<para>
								Valid values: <literal>true</literal>, <literal>false</literal>
							</para>
							
							<para>
								Default value: <literal>false</literal>
							</para>
						
							<para>
Enables/disables replication. Replication is used to deal with jobs sitting
in batch queues for abnormally large amounts of time. If replication is enabled
and certain conditions are met, Swift creates and submits replicas of jobs, and
allows multiple instances of a job to compete.
							</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<property>replication.limit</property>
						</term>
						<listitem>
							
							<para>
								Valid values: positive integers
							</para>
							
							<para>
								Default value: 3
							</para>
						
							<para>
The maximum number of replicas that Swift should attempt.
							</para>
						</listitem>
					</varlistentry>
		
					<varlistentry>
						<term>
							<property>sitedir.keep</property>
						</term>
						<listitem>
							<para>
								Valid values: <parameter>true</parameter>, <parameter>false</parameter>
							</para>

							<para>
								Default value: <literal>false</literal>
							</para>

							<para>
Indicates whether the working directory on the remote site should be
left intact even when a run completes successfully. This can be
used to inspect the site working directory for debugging purposes.
							</para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>sites.file</property>
						</term>
						<listitem>
							
							<para>
								Valid values: <parameter>&lt;file&gt;</parameter>
							</para>
							
							<para>
								Default value: ${<varname>swift.home</varname>}<literal>/etc/sites.xml</literal>
							</para>
						
							<para>
							
								Points to the location of the site
								catalog, which contains a list of all sites that
								Swift should use.

								
							</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<property>status.mode</property>
						</term>
						<listitem>
							<para>
								Valid values: <parameter>files</parameter>, <parameter>provider</parameter>
							</para>

							<para>
								Default value: <literal>files</literal>
							</para>

							<para>
Controls how Swift will communicate the result code of running user programs
from workers to the submit side. In <literal>files</literal> mode, a file
indicating success or failure will be created on the site shared filesystem.
In <literal>provider</literal> mode, the execution provider job status will
be used.
							</para>
							<para>
<literal>provider</literal> mode requires the underlying job execution system
to correctly return exit codes. In at least the cases of GRAM2, and clusters
used with any provider, exit codes are not returned, and so
<literal>files</literal> mode must be used in those cases.  Otherwise,
<literal>provider</literal> mode can be used to reduce the amount of
filesystem access. (since Swift 0.8)
							</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<property>tc.file</property>
						</term>
						<listitem>
							<para>
								Valid values: <parameter>&lt;file&gt;</parameter>
							</para>
							
							<para>
								Default value: ${<varname>swift.home</varname>}<literal>/etc/tc.data</literal>
							</para>
						
							<para>
							
								Points to the location of the transformation
								catalog file which contains information about
								installed applications. Details about the format
								of the transformation catalog can be found
								<ulink
								url="http://vds.uchicago.edu/vds/doc/userguide/html/H_TransformationCatalog.html">here</ulink>.
								
							</para>
						</listitem>
					</varlistentry>
	
  					<varlistentry>
						<term>
							<property>tcp.port.range</property>
						</term>
						<listitem>
							<para>Valid values: <parameter>&lt;start></parameter>,<parameter>&lt;end></parameter> where start and end are integers</para>
							<para>Default value: none</para>
							<para>
A TCP port range can be specified to restrict the ports on which 
GRAM callback services are started. This is likely needed if your
 submit host is behind a firewall, in which case the firewall 
should be configured to allow incoming connections on ports in 
the range. 
							</para>
						</listitem>
  </varlistentry>


					<varlistentry>
						<term>
							<property>throttle.file.operations</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;int&gt;</parameter>, <parameter>off</parameter>
							</para>
							
							<para>
								Default value: <literal>8</literal>
							</para>
							
							<para>
							
								Limits the total number of concurrent file
								operations that can happen at any given time.
								File operations (like transfers) require an
								exclusive connection to a site. These
								connections can be expensive to establish. A
								large number of concurrent file operations may
								cause Swift to attempt to establish many  such
								expensive connections to various sites. Limiting
								the number of concurrent file operations causes
								Swift to use a small number of cached
								connections and achieve better overall
								performance. 
								
							</para>
						</listitem>
					</varlistentry>
				
					<varlistentry>
						<term>
							<property>throttle.host.submit</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;int&gt;</parameter>, <parameter>off</parameter>
							</para>
							
							<para>
								Default value: <literal>2</literal>
							</para>
							
							<para>
							
								Limits the number of concurrent submissions for
								any of the sites Swift will try to send jobs to.
								In other words it guarantees that no more than
								the  value of this throttle jobs sent to any
								site will be concurrently in a state of being
								submitted.
								
							</para>
						</listitem>
					</varlistentry>

					<varlistentry id="property.throttle.score.job.factor">
						<term>
							<property>throttle.score.job.factor</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;int&gt;</parameter>, <parameter>off</parameter>
							</para>
							
							<para>
								Default value: <literal>4</literal>
							</para>
							
							<para>
								The Swift scheduler has the ability to limit
								the number of concurrent jobs allowed on a
								site based on the performance history of that
								site. Each site is assigned a score (initially
								1), which can increase or decrease based on
								whether the site yields successful or faulty
								job runs. The score for a site can take values
								in the (0.1, 100) interval. The number of
								allowed jobs is calculated using the
								following formula:
							</para>
							<para>
								2 + score*throttle.score.job.factor 
							</para>
							<para>
								This means a site will always be allowed
								at least two concurrent jobs and at most
								2 + 100*throttle.score.job.factor. With a
								default of 4 this means at least 2 jobs and
								at most 402. 
							</para>
							<para>
								This parameter can also be set per site
								using the jobThrottle profile key in a site
								catalog entry.
							</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<property>throttle.submit</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;int&gt;</parameter>, <parameter>off</parameter>
							</para>
							
							<para>
								Default value: <literal>4</literal>
							</para>
						
							<para>
							
								Limits the number of concurrent submissions for
								a run. This throttle only limits
								the number of concurrent tasks (jobs) that are
								being sent to sites, not the total number of
								concurrent jobs that can be run. The submission
								stage in GRAM is one of the most CPU expensive
								stages (due mostly to the mutual authentication
								and delegation). Having too many  concurrent
								submissions can overload either or both the
								submit host CPU and the remote host/head node
								causing degraded performance.
								
							</para>
							
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<property>throttle.transfers</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <parameter>&lt;int&gt;</parameter>, <parameter>off</parameter>
							</para>
						
							<para>
								Default value: <literal>4</literal>	
							</para>
							
							<para>
							
								Limits the total number of concurrent file
								transfers that can happen at any given time.
								File transfers consume bandwidth. Too many
								concurrent transfers can cause the network to be
								overloaded preventing various other signaling
								traffic from flowing properly.
								
							</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<property>ticker.disable</property>
						</term>
						<listitem>
							<para>
								Valid values: <parameter>true</parameter>, <parameter>false</parameter>
							</para>

							<para>
								Default value: <literal>false</literal>
							</para>

							<para>
When set to true, suppresses the output progress ticker that Swift sends
to the console every few seconds during a run (since Swift 0.9)
							</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<property>wrapper.invocation.mode</property>
						</term>
						<listitem>
							<para>
Valid values: <parameter>absolute</parameter>, <parameter>relative</parameter>
							</para>
							<para>
Default value: <literal>absolute</literal>
							</para>
							<para>
Determines if Swift remote wrappers will be executed by specifying an
absolute path, or a path relative to the job initial working directory.
In most cases, execution will be successful with either option. However,
some execution sites ignore the specified initial working directory, and
so <literal>absolute</literal> must be used. Conversely on some sites,
job directories appear in a different place on the worker node file system
than on the filesystem access node, with the execution system handling
translation of the job initial working directory. In such cases,
<literal>relative</literal> mode must be used. (since Swift 0.9)
							</para>

						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<property>wrapperlog.always.transfer</property>
						</term>
						<listitem>
						
							<para>
								Valid values: <literal>true</literal>, <literal>false</literal>
							</para>
							
							<para>
								Default value: <literal>false</literal>
							</para>
							
							<para>
							
								This property controls when output from
								the Swift remote wrapper is transfered
								back to the submit site. When set to
								<literal>false</literal>, wrapper logs are 
								only transfered for jobs that fail. If set to
								<literal>true</literal>, wrapper logs are
								transfered after every job is completed or
								failed.
								
							</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<property>provenance.log</property>
						</term>
						<listitem>
							<para>
								Valid values: <literal>true</literal>, <literal>false</literal>
							</para>
							<para>
								Default value: <literal>false</literal>
							</para>
							<para>
								This property controls whether the log file will contain provenance information enabling this will increase the size of log files, sometimes significantly.
							</para>
						</listitem>
					</varlistentry>
										
				</variablelist>
				
				Example:
				
<screen>
sites.file=${vds.home}/etc/sites.xml
tc.file=${vds.home}/etc/tc.data
ip.address=192.168.0.1
</screen>
			
			</para>
		
	</section>


	<section id="profiles"><title>Profiles</title>
		<section id="profile.karajan"><title>Karajan namespace</title>
			<para id="profile.karajan.maxsubmitrate"><literal>maxSubmitRate</literal> limits the maximum rate of job submission, in jobs per second.
For example:
<screen>
&lt;profile namespace="karajan" key="maxSubmitRate"&gt;0.2&lt;/profile&gt;
</screen>
will limit job submission to 0.2 jobs per second (or equivalently,
one job every five seconds).
			</para>
			<para id="profile.karajan.jobThrottle"><literal>jobThrottle</literal>
allows the job throttle factor (see Swift property <link linkend="property.throttle.score.job.factor">throttle.score.job.factor</link>) to be set per site.
			</para>
			<para id="profile.karajan.initialScore"><literal>initialScore</literal>
allows the initial score for rate limiting and site selection to be set to
a value other than 0.
			</para>
			<para id="profile.karajan.delayBase"><literal>delayBase</literal> controls how much a site will be delayed when it performs poorly. With each reduction
in a sites score by 1, the delay between execution attempts will increase by
a factor of delayBase.</para>
			<para id="profile.karajan.status.mode"><literal>status.mode</literal> allows the status.mode property to be set per-site instead of for an entire run.
See the Swift configuration properties section for more information.
(since Swift 0.8)</para>
		</section>
		<section id="profile.swift"><title>swift namespace</title>
			<para id="profile.swift.storagesize"><literal>storagesize</literal> limits the
amount of space that will be used on the remote site for temporary files.
When more than that amount of space is used, the remote temporary file
cache will be cleared using the algorithm specified in the
<link linkend="property.caching.algorithm"><literal>caching.algorithm</literal></link> property.
			</para>
		</section>
		<section id="profile.globus"><title>Globus namespace</title>
			<para id="profile.globus.maxwalltime"><literal>maxwalltime</literal> specifies a walltime limit for each job, in minutes. This profile setting also interacts
with the <link linkend="clustering">clustering mechanism</link>.
			</para>
			<para>
The following formats are recognized:
				<itemizedlist>
					<listitem>Minutes</listitem>
					<listitem>Hours:Minutes</listitem>
					<listitem>Hours:Minutes:Seconds</listitem>
				</itemizedlist>
			</para>
			<para id="profile.globus.queue"><literal>queue</literal> 
is used by the PBS, GRAM2 and GRAM4 providers. This profile
entry specifies which queue jobs will be submitted to. The valid queue names
are site-specific.
			</para>
			<para id="profile.globus.host_types"><literal>host_types</literal>
specifies the types of host that are permissible for a job to run on.
The valid values are site-specific. This profile entry is used by the
GRAM2 and GRAM4 providers.
			</para>
			<para id="profile.globus.condor_requirements"><literal>condor_requirements</literal> allows a requirements string to be specified
when Condor is used as an LRM behind GRAM2. Example: <literal>&lt;profile namespace="globus" key="condor_requirements">Arch == &quot;X86_64&quot; || Arch=&quot;INTEL&quot;&lt;/profile></literal>
			</para>
			<para id="profile.globus.coastersPerNode"><literal>coastersPerNode</literal> specifies
the number of coaster workers to be run on each node. This profile entry
is used by the <link linkend="coasters">coaster execution provider</link>.
			</para>
			<para id="profile.globus.coasterWorkerMaxWalltime"><literal>coasterWorkerMaxwalltime</literal>
specifies the maxwalltime to be used when submitting coaster workers. This
profile entry is used by the <link linkend="coasters">coaster execution
provider</link>. If this entry is not specified, the coaster provider
will compute a maxwalltime based on the maxwalltime of jobs submitted. (since Swift 0.9)
			</para>
			<para id="profile.globus.coasterInternalIP"><literal>coasterInternalIP</literal>
specifies the internal address of the coaster head node, to be used by
coaster workers to communicate with the coaster head node. This can be used
when the address determined automatically by the coaster provider
is inaccessible from coaster workers (for example, when the workers
reside on an unrouted internal network). (since Swift 0.9)
			</para>
		</section>

		<section id="profile.env"><title>env namespace</title>
			<para>
Profile keys set in the env namespace will be set in the unix environment of the
executed job.
			</para>
		</section>
	</section>

	<section id="envvars"><title>Environment variables</title>
		<para>
There are a number of environment variables used by Swift. Some of them are
documented in this section:
		</para>
		<para>
<literal>PATHPREFIX</literal> - set in env namespace profiles. This path is prefixed onto the start
of the <literal>PATH</literal> when jobs are
executed. It can be more useful than setting the <literal>PATH</literal> environment variable directly,
because setting <literal>PATH</literal> will cause the execution site's default path to be lost.
		</para>
		<para>
<literal>GLOBUS_HOSTNAME</literal>, <literal>GLOBUS_TCP_PORT_RANGE</literal> - set in the environment before running
Swift. These can be set to inform Swift of the
configuration of your local firewall. More information can be found in
<ulink url="http://dev.globus.org/wiki/FirewallHowTo">the Globus firewall
How-to</ulink>.
		</para>
		<para>
<literal>COG_OPTS</literal> - set in the environment before running Swift. Options set in this
variable will be passed as parameters to the Java Virtual Machine which
will run Swift. The parameters vary between virtual machine imlementations,
but can usually be used to alter settings such as maximum heap size.
Typing 'java -help' will sometimes give a list of commands. The Sun Java
1.4.2 command line options are <ulink url="http://java.sun.com/j2se/1.4.2/docs/tooldocs/windows/java.html">documented here</ulink>.
		</para>
		<para>
<literal>SWIFT_JOBDIR_PATH</literal> - set in env namespace profiles. If set, then Swift will
use the path specified here as a worker-node local temporary directory to
copy input files to before running a job. If unset, Swift will keep input
files on the site-shared filesystem. In some cases, copying to a worker-node
local directory can be much faster than having applications access the
site-shared filesystem directly.
		</para>
		<para>
<literal>SWIFT_EXTRA_INFO</literal> - set in env namespace profiles. If set,
then Swift will execute the command specified in
<literal>SWIFT_EXTRA_INFO</literal> on execution sites immediately before
each application execution, and will record the stdout of that command in the
wrapper info log file for that job. This is intended to allow software
version and other arbitrary information about the remote site to be gathered
and returned to the submit side. (since Swift 0.9)
		</para>
	</section>
	<section id="sitecatalog"><title>The Site Catalog - sites.xml</title>
		<para>
The site catalog lists details of each site that Swift can use. The default
file contains one entry for local execution, and a large number of
commented-out example entries for other sites.
		</para>

		<para>
By default, the site catalog is stored in <filename>etc/sites.xml</filename>.
This path can be overridden with the <literal>sites.file</literal> configuration property,
either in the Swift configuration file or on the command line.
		</para>

		<para>
The sites file is formatted as XML. It consists of <literal>&lt;pool&gt;</literal> elements,
one for each site that Swift will use.
		</para>

		<section><title>Pool element</title>
		<para>
Each <literal>pool</literal> element must have a <literal>handle</literal> attribute, giving a symbolic name
for the site. This can be any name, but must correspond to entries for
that site in the transformation catalog.
		</para>

		<para>
Optionally, the <literal>gridlaunch</literal> attribute can be used to specify the path to
<link linkend="kickstart">kickstart</link> on the site.
		</para>

		<para>
Each <literal>pool</literal> must specify a file transfer method, an execution method
and a remote working directory. Optionally, <link linkend="profiles">profile settings</link> can be specified.
		</para>

</section>
<section><title>File transfer method specification</title>

		<para>
Transfer methods are specified with either 
the <literal>&lt;gridftp&gt;</literal> element or the 
<literal>&lt;filesystem&gt;</literal> element.
		</para>
		<para>
To use gridftp or local filesystem copy, use the <literal>&lt;gridftp&gt;</literal>
element:
<screen>
&lt;gridftp  url="gsiftp://evitable.ci.uchicago.edu" /&gt;
</screen>
The <literal>url</literal> attribute may specify a GridFTP server, using the gsiftp URI scheme;
or it may specify that filesystem copying will be used (which assumes that
the site has access to the same filesystem as the submitting machine) using
the URI <literal>local://localhost</literal>.
		</para>
		<para>
Filesystem access using scp (the SSH copy protocol) can be specified using the
<literal>&lt;filesystem&gt;</literal> element:
<screen>
&lt;filesystem url="www11.i2u2.org" provider="ssh"/&gt;
</screen>
For additional ssh configuration information, see the ssh execution
provider documentation below.
		</para>
		<para>
Filesystem access using <link linkend="coasters">CoG coasters</link> can be
also be specified using the <literal>&lt;filesystem&gt;</literal> element. More detail about
configuring that can be found in the <link linkend="coasters">CoG
coasters</link> section.
		</para>
</section>

<section><title>Execution method specification</title>

		<para>
Execution methods may be specified either with the <literal>&lt;jobmanager&gt;</literal>
or <literal>&lt;execution&gt;</literal> element.
		</para>

		<para>
The <literal>&lt;jobmanager&gt;</literal> element can be used to specify
execution through GRAM2. For example,
<screen>
    &lt;jobmanager universe="vanilla" url="evitable.ci.uchicago.edu/jobmanager-fork" major="2" /&gt;
</screen>
The <literal>universe</literal> attribute should always be set to vanilla. The
<literal>url</literal> attribute
should specify the name of the GRAM2 gatekeeper host, and the name of the
jobmanager to use. The major attribute should always be set to 2.
		</para>

		<para>
The <literal>&lt;execution&gt;</literal> element can be used to specify
execution through other execution providers:
		</para>
		<para>
To use GRAM4, specify the <literal>gt4</literal> provider. For example:
<screen>
&lt;execution provider="gt4" jobmanager="PBS" url="tg-grid.uc.teragrid.org" /&gt;
</screen>
The <literal>url</literal> attribute should specify the GRAM4 submission site.
The <literal>jobmanager</literal>
attribute should specify which GRAM4 jobmanager will be used.
		</para>

		<para>
For local execution, the <literal>local</literal> provider should be used,
like this:
<screen>
&lt;execution provider="local" url="none" /&gt;
</screen>
		</para>

		<para>
For PBS execution, the <literal>pbs</literal> provider should be used:
<screen>
&lt;execution provider="pbs" url="none" /&gt;
</screen>
The <literal><link linkend="profile.globus.queue">GLOBUS::queue</link></literal> profile key
can be used to specify which PBS queue jobs will be submitted to.
		</para>

		<para>
For execution through SSH, the <literal>ssh</literal> provider should be used:
<screen>
&lt;execution url="www11.i2u2.org" provider="ssh"/&gt;
</screen>
with configuration made in <filename>~/.ssh/auth.defaults</filename> with
the string 'www11.i2u2.org' changed to the appropriate host name:
<screen>
www11.i2u2.org.type=key
www11.i2u2.org.username=hategan
www11.i2u2.org.key=/home/mike/.ssh/i2u2portal
www11.i2u2.org.passphrase=XXXX
</screen>
		</para>
		<para>
For execution using the 
<link linkend="coasters">CoG Coaster mechanism</link>, the <literal>coaster</literal> provider
should be used:
<screen>
&lt;execution provider="coaster" url="tg-grid.uc.teragrid.org"
    jobmanager="gt2:gt2:pbs" />
</screen>
More details about configuration of coasters can be found in the
<link linkend="coasters">section on coasters</link>.
		</para>
</section>
<section><title>Other site catalog parameters</title>

		<para>
The <literal>workdirectory</literal> element specifies where on the site files can be
stored.
<screen>
&lt;workdirectory&gt;/home/benc&lt;/workdirectory&gt;
</screen>
This file must be accessible through the transfer mechanism specified
in the <literal>&lt;gridftp&gt;</literal> element and also mounted on all worker nodes that
will be used for execution. A shared cluster scratch filesystem is
appropriate for this. 
		</para>

		<para>
<link linkend="profiles">Profile keys</link> can be specified using
the &lt;profile&gt; element. For example:
<screen>
&lt;profile namespace="globus" key="queue"&gt;fast&lt;/profile&gt;
</screen>
		</para>
		</section>

		<para>
The site catalog format is an evolution of the VDS site catalog format which
is documented
<ulink url="http://vds.uchicago.edu/vds/doc/userguide/html/H_SiteCatalog.html">here</ulink>.
		</para>
	</section>

	<section id="transformationcatalog"><title>The Transformation Catalog - tc.data</title>
		<para>
The transformation catalog lists where application executables are located
on remote sites.
		</para>
		<para>
By default, the site catalog is stored in <filename>etc/tc.data</filename>.
This path can be overridden with the <literal>tc.file</literal> configuration property,
either in the Swift configuration file or on the command line.
		</para>
		<para>
The format is one line per executable per site, with fields separated by
tabs. Spaces cannot be used to separate fields.
		</para>
		<para>Some example entries:
<screen>
localhost  echo    /bin/echo       INSTALLED       INTEL32::LINUX  null
TGUC       touch   /usr/bin/touch  INSTALLED       INTEL32::LINUX  GLOBUS::maxwalltime="0:1"
</screen>
		</para>
		<para>
The fields are: site, transformation name, executable path, installation
status, platform, and profile entrys.
		</para>
		<para>
The site field should correspond to a site name listed in the sites
catalog.</para>
		<para>
The transformation name should correspond to the transformation name
used in a SwiftScript <literal>app</literal> procedure.
		</para>
		<para>
The executable path should specify where the particular executable is
located on that site.
		</para>
		<para>
The installation status and platform fields are not used. Set them to
<literal>INSTALLED</literal> and <literal>INTEL32::LINUX</literal> respectively.
		</para>
		<para>
The profiles field should be set to <literal>null</literal> if no profile entries are to be
specified, or should contain the profile entries separated by semicolons.
		</para>
	</section>
	<section id="buildoptions"><title>Build options</title>
		<para>
See <ulink url="http://www.ci.uchicago.edu/swift/downloads/">the
Swift download page</ulink> for instructions on downloading and
building Swift from source. When building, various build options can
be supplied on the ant commandline. These are summarised here:
		</para>
		<para>
<literal>with-provider-condor</literal> - build with CoG condor provider
		</para>
		<para>
<literal>with-provider-coaster</literal> - build with CoG coaster provider (see
<link linkend="coasters">the section on coasters</link>). Since 0.8,
coasters are always built, and this option has no effect.
		</para>
		<para>
<literal>with-provider-deef</literal> - build with Falkon provider deef. In order for this
option to work, it is necessary to check out the provider-deef code in
the cog/modules directory alongside swift:

			<screen>
$ <userinput>cd cog/modules</userinput>
$ <userinput>svn co https://svn.ci.uchicago.edu/svn/vdl2/provider-deef</userinput>
$ <userinput>cd ../swift</userinput>
$ <userinput>ant -Dwith-provider-deef=true redist</userinput>
			</screen>

		</para>
		<para>
<literal>with-provider-wonky</literal> - build with provider-wonky, an execution provider
that provides delays and unreliability for the purposes of testing Swift's
fault tolerance mechanisms. In order for this option to work, it is
necessary to check out the provider-wonky code in the <filename>cog/modules</filename>
directory alongside swift:

			<screen>
$ <userinput>cd cog/modules</userinput>
$ <userinput>svn co https://svn.ci.uchicago.edu/svn/vdl2/provider-wonky</userinput>
$ <userinput>cd ../swift</userinput>
$ <userinput>ant -Dwith-provider-wonky=true redist</userinput>
			</screen>
		</para>
		<para>
<literal>no-supporting</literal> - produces a distribution without supporting commands such
as <command>grid-proxy-init</command>. This is intended for when the Swift distribution will be
used in an environment where those commands are already provided by other
packages, where the Swift package should be providing only Swift
commands, and where the presence of commands such as grid-proxy-init from
the Swift distribution in the path will mask the presence of those
commands from their true distribution package such as a Globus Toolkit
package.
<screen>
$ <userinput>ant -Dno-supporting=true redist</userinput>
</screen>
		</para>
	</section>

	<section id="kickstart"> <title>Kickstart</title>
		<para>

Kickstart is a tool that can be used to gather various information 
about the remote execution environment for each job that Swift tries
to run.
		</para>

		<para>
For each job, Kickstart generates an XML <firstterm>invocation
record</firstterm>. By default this record is staged back to the submit
host if the job fails.
		</para>

		<para>
Before it can be used it must be installed on the remote site and
the sites file must be configured to point to kickstart.
		</para>

		<para>
Kickstart can be downloaded as part of the Pegasus 'worker package' available
from the worker packages section of <ulink url="http://pegasus.isi.edu/code.php">the Pegasus download page</ulink>.
		</para>
		<para>
Untar the relevant worker package somewhere where it is visible to all of the
worker nodes on the remote execution machine (such as in a shared application
filesystem).
		</para>

<para>Now configure the gridlaunch attribute of the sites catalog
to point to that path, by adding a <parameter>gridlaunch</parameter>
attribute to the <function>pool</function> element in the site
catalog:

<screen>

&lt;pool handle="example" gridlaunch="/usr/local/bin/kickstart" sysinfo="INTEL32::LINUX"&gt;
[...]
&lt;/pool&gt;

</screen>

		</para>

		<para>
There are various kickstat.* properties, which have sensible default
values. These are documented in <link linkend="engineconfiguration">the
properties section</link>.
		</para>



	</section>

	<section id="restart"> <title>Workflow restart/recovery</title>
		<para>
If a run fails, Swift can resume the program from the point of
failure. When a run fails, a restart log file will be left behind in
a file named using the unique job ID and a .rlog extension. This restart log
can then be passed to a subsequent Swift invocation using the -resume
parameter. Swift will resume execution, avoiding execution of invocations
that have previously completed successfully. The SwiftScript source file
and input data files should not be modified between runs.
		</para>
		<para>
Every run creates a restart
log file with a named composed of the file name of the workflow
being executed, an invocation ID, a numeric ID, and the <filename
class="file">.rlog</filename> extension. For example, <filename
class="file">example.swift</filename>, when executed, could produce
the following restart log file: <filename
class="file">example-ht0adgi315l61.0.rlog</filename>. Normally, if
the run completes successfully, the restart log file is
deleted. If however the workflow fails, <command>swift</command>
can use the restart log file to continue
execution from a point before the
failure occurred. In order to restart from a restart log
file, the <option>-resume <parameter><filename
class="file">logfile</filename></parameter></option> argument can be
used after the SwiftScript program file name. Example:

<screen>
<prompt>&gt;</prompt> <command>swift</command> <option>-resume <filename
class="file">example-ht0adgi315l61.0.rlog</filename></option> <option><filename
class="file">example.swift</filename></option>.
</screen>

		</para>
	</section> 


	<section id="clustering"><title>Clustering</title>
		<para>
Swift can group a number of short job submissions into a single larger
job submission to minimize overhead involved in launching jobs (for example,
caused by security negotiation and queuing delay). In general,
<link linkend="coasters">CoG coasters</link> should be used in preference
to the clustering mechanism documented in this section.
		</para>

		<para>
By default, clustering is disabled. It can be activated by setting the
<link linkend="property.clustering.enabled">clustering.enabled</link>
property to true.
		</para>

		<para>
A job is eligible for clustering if
the <link linkend="profile.globus.maxwalltime"><property>GLOBUS::maxwalltime</property></link> profile is specified in the <filename
type="file">tc.data</filename> entry for that job, and its value is
less than the value of the
<link linkend="property.clustering.min.time"><property>clustering.min.time</property></link>
property.
		</para>

		<para>
Two or more jobs are considered compatible if they share the same site
and do not have conflicting profiles (e.g. different values for the same
environment variable). 
		</para>

		<para>
When a submitted job is eligible for clustering, 
it will be put in a clustering queue rather than being submitted to
a remote site. The clustering queue is processed at intervals 
specified by the
<link linkend="property.clustering.queue.delay"><property>clustering.queue.delay</property></link>
property. The processing of the clustering queue consists of selecting
compatible jobs and grouping them into clusters whose maximum wall time does
not exceed twice the value of the <property>clustering.min.time</property>
property.
		</para>

		
	</section>



	<section id="coasters"><title>Coasters</title>
<para>Coasters were introduced in Swift v0.6 as an experimental feature.
</para>
<para>
In many applications, Swift performance can be greatly enhanced by the
use of CoG coasters. CoG coasters provide a low-overhead job submission
and file transfer mechanism suited for the execution of short jobs
(on the order of a few seconds) and the transfer of small files (on the
order of a few kilobytes) for which other grid protocols such as GRAM
and GridFTP are poorly suited.
</para>
<para>
The coaster mechanism submits a head job using some other execution
mechanism such as GRAM, and for each worker node that will be used in
a remote cluster, it submits a worker job, again using some other
execution mechanism such as GRAM. Details on the design of the coaster
mechanism can be found
<ulink url="http://wiki.cogkit.org/wiki/Coasters">
here.</ulink>
</para>
<para>
The head job manages file transfers and the dispatch of execution jobs
to workers. Much of the overhead associated with other grid protocols
(such as authentication and authorization, and allocation of worker nodes
by the site's local resource manager) is reduced, because that overhead
is associated with the allocation of a coaster head or coaster worker,
rather than with every Swift-level procedure invocation; potentially hundreds
or thousands of Swift-level procedure invocations can be run through a single
worker.
</para>
<para>
Coasters can be configured for use in two situations: job execution and
file transfer.
</para>
<para>
To use for job execution, specify a sites.xml execution element like this:
<screen>
&lt;execution provider="coaster" jobmanager="gt2:gt2:pbs" url="grid.myhost.org"&gt;
</screen>
The jobmanager string contains more detail than with other providers. It
contains either two or three colon separated fields:
1:the provider to be use to execute the coaster head job - this provider
will submit from the Swift client side environment. Commonly this will be
one of the GRAM providers; 2: the provider
to be used to execute coaster worker jobs. This provider will be used
to submit from the coaster head job environment, so a local scheduler
provider can sometimes be used instead of GRAM. 3: optionally, the
jobmanager to be used when submitting worker job using the provider
specified in field 2.
</para>
<para>
To use for file transfer, specify a sites.xml filesystem element like this:
<screen>
&lt;filesystem provider="coaster" url="gt2://grid.myhost.org" /&gt;
</screen>
The url parameter should be a pseudo-URI formed with the URI scheme being
the name of the provider to use to submit the coaster head job, and the
hostname portion being the hostname to be used to execute the coaster
head job. Note that this provider and hostname will be used for execution
of a coaster head job, not for file transfer; so for example, a GRAM
endpoint should be specified here rather than a GridFTP endpoint.
</para>
<para>
Coasters are affected by the following profile settings, which are
documented in the <link linkend="profile.globus">Globus namespace profile
section</link>:
</para>

<table frame="all">
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
  <thead><row><entry>profile key</entry><entry>brief description</entry></row></thead>
  <tbody>
   <row><entry>coastersPerNode</entry><entry>How many coasters to run per execution node</entry></row>
   <row><entry>coasterWorkerMaxwalltime</entry><entry>The maxwalltime that coaster workers should be submitted with</entry></row>
   <row><entry>coasterInternalIP</entry><entry>The IP address of the coaster head node to be used by workers</entry></row>
  </tbody>
 </tgroup>
</table> 
	</section>
	<section id="localhowtos"><title>How-To Tips for Specific User Communities</title>
		<section id="savinglogs"><title>Saving Logs - for UChicago CI Users</title>
			<para>
If you have a UChicago Computation Institute account, run this command in your 
submit directory after each run. It will copy all your logs and kickstart 
records into a directory at the CI for reporting, usage tracking, support and debugging.
			</para>
			<para>
<screen>
rsync --ignore-existing *.log *.d login.ci.uchicago.edu:/disks/ci-gpfs/swift/swift-logs/ --verbose
</screen>
			</para>
		</section>
		<section><title>Specifying TeraGrid allocations</title>
<para>TeraGrid users with no default project or with several project
allocations can specify a project allocation using a profile key in
the site catalog entry for a TeraGrid site:
<screen>
&lt;profile namespace="globus" key="project"&gt;TG-CCR080002N&lt;/profile&gt;
</screen>
</para>

<para>
More information on the TeraGrid allocations process can
be found <ulink url="http://www.teragrid.org/userinfo/access/allocations.php">here</ulink>.
</para>

		</section>
		<section id="tips.mpi"><title>Launching MPI jobs from Swift</title>
<para>
Here is an example of running a simple MPI program.
</para>
<para>
In SwiftScript, we make an invocation that does not look any different
from any other invocation. In the below code, we do not have any input
files, and have two output files on stdout and stderr:
<programlisting>
type file;

(file o, file e) p() { 
    app {
        mpi stdout=@filename(o) stderr=@filename(e);
    }
}

file mpiout &lt;"mpi.out">;
file mpierr &lt;"mpi.err">;

(mpiout, mpierr) = p();
</programlisting>
</para>
<para>
Now we define how 'mpi' will run in tc.data:
<screen>
tguc    mpi             /home/benc/mpi/mpi.sh   INSTALLED       INTEL32::LINUX GLOBUS::host_xcount=3
</screen>
</para>
<para>
mpi.sh is a wrapper script that launches the MPI program. It must be installed
on the remote site:
<screen>
#!/bin/bash
mpirun -np 3 -machinefile $PBS_NODEFILE /home/benc/mpi/a.out 
</screen>
</para>
<para>
Because of the way that Swift runs its server side code, provider-specific
MPI modes (such as GRAM jobType=mpi) should not be used. Instead, the
mpirun command should be explicitly invoked.
</para>
		</section>
		<section id="tips.osg"><title>Generating a sites.xml for OSG</title>
			<para>
The Swift distribution contains a command
<command>swift-osg-ress-site-catalog</command> that can generate a site
catalog based on OSG's ReSS information system (since Swift 0.9)
			</para>

			<screen>
Usage:
    swift-osg-ress-site-catalog [options]

Options:
    --help  Show this help message

    --vo=[name]
            Set what VO to query ReSS for

    --engage-verified
            Only retrieve sites verified by the Engagement VO site
            verification tests This can not be used together with --vo, as
            the query will only work for sites advertising support for the
            Engagement VO.

            This option means information will be retrieved from the
            Engagement collector instead of the top-level ReSS collector.

    --out=[filename]
            Write to [filename] instead of stdout
			</screen>
		</section>
	</section>


</article>

