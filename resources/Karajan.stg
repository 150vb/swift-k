group Karajan;

program(types,procedures,declarations,statements) ::= <<
<project>
  <import file="sys.xml"/>
  <import file="scheduler.xml"/>
  <import file="rlog.xml"/>
  <import file="vdl.k"/>
  $if(types)$
  <types>
    $types$
  </types>
  $endif$
  $procedures;separator="\n"$
  $declarations;separator="\n"$
  $if(statements)$
  <restartLog>
  	<vdl:pre/>
  	<vdl:mains>
		<vdl:mainp>
		    <parallel>
    		  $statements;separator="\n"$
	    	</parallel>
		</vdl:mainp>
	</vdl:mains>
	<vdl:post/>
  </restartLog>  
  $endif$
</project>
>>

procedure(name,outputs,inputs,arguments,optargs,binding,declarations,statements,config) ::= <<
<element name="$name$"$if(arguments)$ arguments="$proc_args(args=arguments)$"$endif$$if(optargs)$ optargs="$proc_args(args=optargs)$"$endif$>
  $optargs:default_arg();separator="\n"$
  $outputs:typecheck();separator="\n"$
  $inputs:typecheck();separator="\n"$
$if(binding)$
  $vdl_execute(outputs=outputs,inputs=inputs,application=binding.application)$

$else$
  $compound(outputs=outputs,inputs=inputs,declarations=declarations,statements=statements)$

$endif$
</element>

>>

compound(outputs,inputs,declarations,statements,config) ::= <<
$declarations;separator="\n"$
$if(statements)$
<parallel>
  $statements;separator="\n"$
</parallel>

$endif$
$outputs:vdl_closedataset();separator="\n"$
>>

proc_args(args) ::= <<
$args:arg_name();separator=","$
>>

arg_name() ::= <<
$it.name$
>>

default_arg() ::= <<
$if(it.default)$
<default name="$it.name$">
$it.default$
</default>
$endif$
>>

typecheck() ::= <<
<vdl:typecheck argname="$it.name$" var="{$it.name$}" type="$it.type.name$"$if(it.isArray)$ isArray="true"$endif$/>
>>

vdl_execute(outputs,inputs,application) ::= <<
<vdl:execute>
  <vdl:tr>$application.exec$</vdl:tr>
  $inputs:vdl_stagein();separator="\n"$
  $outputs:vdl_stageout();separator="\n"$
  $vdl_arguments(arguments=application.arguments, stdin=application.stdin,stdout=application.stdout,stderr=application.stderr)$
</vdl:execute>
$outputs:vdl_closedataset();separator="\n"$
>>

vdl_stagein() ::= <<
<vdl:stagein var="{$it.name$}"/>
>>

vdl_stageout(outputs) ::= <<
<vdl:stageout var="{$it.name$}"/>
>>

vdl_closedataset() ::= <<
<vdl:closedataset var="{$it.name$}"/>
>>

vdl_arguments(arguments,stdin,stdout,stderr) ::= <<
<vdl:arguments>
  $arguments;separator="\n"$
</vdl:arguments>
$if (stdin)$
<vdl:stdin>
  $stdin$
</vdl:stdin>
$endif$
$if (stdout)$
<vdl:stdout>
  $stdout$
</vdl:stdout>
$endif$
$if (stderr)$
<vdl:stderr>
  $stderr$
</vdl:stderr>
$endif$
>>

// the 'function' template in general outputs a karajan code fragment
// that calls a function in the vdl namespace.

// there are a number of special cases:

//  ii. if the 'path' or 'var' attributes are set, then special
//      processing of parameters happens:
//      ii.a: the 'path' attribute (if set) becomes an XML attribute
//            to the function invocation element
//      ii.b: if the 'var' attribute is set, then it becomes an XML
//            attribute to the function invocation element, and processing
//            of the body of the element does not occur.

// if neither i) or ii.b) have occurred, then an XML element body is
// constructed, using the 'value' attribute if it exists, otherwise
// using the 'expr' attribute if it exists.

// This patch can maybe move into trunk now rather than being part of the
// XML merge?

function(name, args) ::= <<
<swiftscript:$name$>
  $if(args)$
    $args$
  $endif$
</swiftscript:$name$>
>>

foreach(var,in,indexVar,declarations,statements) ::= <<
<parallelFor name="\$">
  <getfieldvalue>$in$</getfieldvalue>
  <set names="\$\$, $var$">
    <each items="{\$}"/>
  </set>
$if(indexVar)$
    <set name="$indexVar$">
      <vdl:new type="int" value="{\$\$}"/>
    </set>
$endif$
    $declarations;separator="\n"$
    $if(statements)$
    <parallel>
      $statements;separator="\n"$
    </parallel>
    $endif$
</parallelFor>
>>

call(func, outputs, inputs) ::= <<
<$func$>
  <parallel>
    $outputs;separator="\n"$
    $inputs;separator="\n"$
  </parallel>
</$func$>
>>

call_arg(bind, expr) ::= <<
$if(bind)$
<argument name="$bind$">
  $expr$
</argument>
$else$
$expr$
$endif$
>>

dataset(name,type,mapping,file,isArray) ::= <<
<set name="$name$">
  <vdl:new type="$type$" dbgname="$name$"$if(isArray)$ isArray="true"$endif$>
    $vdl_mapping(mapping=mapping,file=file)$
  </vdl:new>
</set>
>>

vdl_mapping(mapping,file) ::= <<
$if(file)$
<vdl:mapping descriptor="single_file_mapper">
  <vdl:parameter name="file" value="$file.name$"/>
  $if(file.params)$$file.params;separator="\n"$$endif$
</vdl:mapping>
$else$
<vdl:mapping descriptor="$mapping.descriptor$">
  $mapping.params;separator="\n"$
</vdl:mapping>
$endif$
>>

vdl_parameter(name,expr) ::= <<
<vdl:parameter name="$name$">$expr$</vdl:parameter>
>>

variable(name,type,isArray,expr,mapping,nil) ::= <<
<set name="$name$">
  $if(mapping)$
  <vdl:new type="$type$" dbgname="$name$"$if(isArray)$ isArray="true"$endif$>
    $vdl_mapping(mapping=mapping)$
  </vdl:new>
  $else$
  $expr$
  $endif$
</set>
>>

assign(var,value) ::= <<
   <vdl:setfieldvalue>
     <argument name="var">
       $var$
     </argument>
     <argument name="value">
<!-- TODO this should be removed and the equivalent code put in the
java implementation of setfieldvalue itself -->
<getfieldvalue>
       $value$
</getfieldvalue>
     </argument>
   </vdl:setfieldvalue>
>>

array(elements) ::= <<
<vdl:createarray>
  <list>
    $elements;separator="\n"$
  </list>
</vdl:createarray>
>>

range(from,to,step) ::= <<
<vdl:range>
  <argument name="from">
    $from$
  </argument>
  <argument name="to">
    $to$
  </argument>
  $if(step)$
  <argument name="step">
    $step$
  </argument>
  $endif$
</vdl:range>
>>

if(condition,vthen,velse) ::= <<
<if>
  <vdl:getfieldvalue>$condition$</vdl:getfieldvalue>
  <then>
    $vthen$
  </then>
  $if(velse)$
  <else>
    $velse$
  </else>
  $endif$
</if>
>>

sub_comp(declarations,statements) ::= <<
$declarations;separator="\n"$
$if(statements)$
<parallel>
  $statements;separator="\n"$
</parallel>
$endif$
>>

switch(condition,cases,sdefault) ::= <<
<sequential>
  <set name="\$_sw">
    $condition$
  </set>
  <if>
$cases:{case |
    <vdl:getfieldvalue>
    <vdlop:eq>
       <variable>\$_sw</variable>
       $case.value$
    </vdlop:eq>
    </vdl:getfieldvalue>
    <then>
      $sub_comp(declarations=case.declarations, statements=case.statements)$
    </then>
}$
$if(sdefault)$
    <else>
      $sdefault$
    </else>

$endif$
  </if>
</sequential>
>>


operator ::= [
  "+":"vdlop:sum",
  "-":"vdlop:subtraction",
  "*":"vdlop:product",
  "/":"vdlop:fquotient",
  "%/":"vdlop:iquotient",
  "%%":"vdlop:remainder",
  "&lt;=":"vdlop:le",
  "&gt;=":"vdlop:ge",
  "&gt;":"vdlop:gt",
  "&lt;":"vdlop:lt",
  "<=":"vdlop:le",
  ">=":"vdlop:ge",
  ">":"vdlop:gt",
  "<":"vdlop:lt",
  "==":"vdlop:eq"
]

unaryNegation(exp) ::= <<
<vdlop:product>
  <vdl:new type="int" value="-1" />
  $exp$
</vdlop:product>
>>

binaryop(op,left,right) ::= <<
<$operator.(op)$>
  $left$
  $right$
</$operator.(op)$>
>>


and(left,right) ::= <<
<vdlop:and>
  $left$
  $right$
</vdlop:and>
>>

or(left, right) ::= <<
<vdlop:or>
  $left$
  $right$
</vdlop:or>
>>

not(exp) ::= <<
<vdlop:not>
  $exp$
</vdlop:not>
>>

id(var) ::= <<
<variable>$var$</variable>
>>

// TODO tidy the interaction with getfield (perhaps by making two new
// elements, one for structure members, one for array access) that
// doesn't need this strcat.
// or make a varargs karajan level accessor?

extractarrayelement(parent, arraychild, memberchild) ::= <<

$if(arraychild)$
<vdl:getfieldsubscript>
  <argument name="var">$parent$</argument>
  <argument name="subscript">$arraychild$</argument>
</vdl:getfieldsubscript>
$endif$

$if(memberchild)$
<getfield>
  <argument name="var">$parent$</argument>
  <argument name="path">$memberchild$</argument>
</getfield>
$endif$

>>

iConst(value) ::= <<
<vdl:new type="int" value="$value$" />
>>

fConst(value) ::= <<
<vdl:new type="float" value="$value$" />
>>

bConst(value) ::= <<
<vdl:new type="boolean" value="$value$" />
>>

sConst(value,innervalue) ::= <<
<vdl:new type="string" value="$innervalue$" />
>>

