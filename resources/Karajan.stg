group Karajan;

// TODO can move progress ticker start into vdl:mains so karajan files
// are smaller

program(types,procedures,declarations,statements,constants,buildversion,cleanups) ::= <<
// CACHE ID $buildversion$
import(sys)
import(scheduler)
import(rlog)
import(swift)

$if(types)$
types(
	xs:schema(
    	$types;separator="\n"$
    )
)

$endif$
$constants;separator="\n"$
$procedures;separator="\n"$
$declarations;separator="\n"$
$if(statements)$

restartLog() {
	swift:mains(
		swift:startProgressTicker()
		swift:mainp(
			$parallel(statements=statements)$
		)
		swift:stopProgressTicker()
	)
}
$endif$
$cleanups:swift_cleandataset();separator="\n"$
swift:cleanDataset(shutdown=true)
>>

typeDef(name,type,members,sourcelocation) ::= <<
$if(type)$
	xs:element("$name$", "$type$") 
$else$
	$if(!members)$
		xs:simpleType("$name$", xs:restriction("string"))
	$else$
		xs:complexType("$name$",
			xs:sequence(
				$members;separator="\n"$
			)
 	    )
	$endif$
$endif$
>>

memberdefinition(type,name,sourcelocation) ::= <<
	xs:element("$name$", "$type$")
>>

procedure(name, outputs, inputs, arguments, optargs, binding, declarations, statements, config, line, initWaitCounts, cleanups, closes) ::= <<

$name$ := function($if(optargs)$$proc_oargs(args=optargs)$$if(arguments)$, $endif$$endif$$if(arguments)$$proc_args(args=arguments)$$endif$) {
	$swift_log_inputs(inputs)$
	$swift_log_outputs(outputs)$
$if(binding)$
	$swift_execute(outputs=outputs,inputs=inputs,application=binding.application, name=name,line=line)$
$else$
	$compound(outputs=outputs, inputs=inputs, declarations=declarations, statements=statements, name=name, initWaitCounts=initWaitCounts, cleanups=cleanups)$
$endif$
}
>>

swift_log_inputs(params) ::= <<
$params:log_param("input");separator="\n"$
>>
swift_log_outputs(params) ::= <<
$params:log_param("output");separator="\n"$
>>

compound(outputs, inputs, declarations, statements, config, name, initWaitCounts, cleanups) ::= <<
unitStart("COMPOUND", name="$name$", outputs="$outputs:list();separator=","$")
$if(initWaitCounts)$
$initWaitCounts;separator="\n"$
$endif$
$declarations;separator="\n"$
$if(statements)$
$parallel(statements=statements)$
$endif$

$outputs:swift_closedataset();separator="\n"$

$cleanups:swift_cleandataset();separator="\n"$
unitEnd("COMPOUND", name="$name$")
>>

proc_args(args) ::= <<
$args:arg_name();separator=", "$
>>

arg_name() ::= <<
$it.name$
>>

proc_oargs(args) ::= <<
$args:proc_optarg()$
>>

proc_optarg() ::= <<
$it.name$=$if(it.default)$$it.default$$else$null$endif$
>>

swift_execute(outputs,inputs,attributes,application,name,line) ::= <<
unitStart("PROCEDURE", name="$name$", line="$line$", outputs="$outputs:list();separator=","$")
swift:execute(
	$attributes$
	swift:tr("$application.exec$")
	$inputs:swift_stagein();separator="\n"$
	$outputs:swift_stageout();separator="\n"$
	$swift_arguments(attributes=application.attributes,arguments=application.arguments, stdin=application.stdin,stdout=application.stdout,stderr=application.stderr)$
)
$outputs:swift_closedataset();separator="\n"$
unitEnd("PROCEDURE", name="$name$", line="$line$")
>>

log_param(dir) ::= <<
parameterLog("$dir$", "$it.name$", swift:getDatasetProvenanceID($it.name$))
>>

swift_stagein() ::= <<
swift:stageIn($it.name$)
>>

swift_stageout(outputs) ::= <<
swift:stageOut($it.name$)
>>

swift_closedataset() ::= <<
swift:closeDataset($it.name$)
>>

swift_cleandataset() ::= <<
swift:cleanDataset($it$)
>>

list() ::= <<$it.name$>>

swift_arguments(attributes,arguments,stdin,stdout,stderr) ::= <<
$attributes$
swift:arguments(
	$arguments;separator=", "$
)

$if (stdin)$
swift:stdin($stdin$)
$endif$

$if (stdout)$
swift:stdout($stdout$)
$endif$

$if (stderr)$
swift:stderr($stderr$)
$endif$
>>

swift_attributes(entries) ::= <<
swift:attributes(
	map(
		$entries;separator="\n"$
	)
)
>>

map_entry(key,value) ::= <<
	map:entry(swift:getFieldValue($key$), swift:getFieldValue($value$))
>>

parallel(statements) ::= <<
$if(rest(statements))$
parallel(
	$statements;separator="\n"$
)
$else$
$statements$
$endif$
>>


// the 'function' template outputs a karajan code fragment
// that calls a function in the 'swiftscript' namespace.

function(name, args, datatype, line) ::= <<
swiftscript:$name$(
	$if(args)$$args;separator=", "$$endif$
)
>>

iterate(declarations,statements,cond,var,cleanups,trace,line) ::= <<
sys:while($var$, 0) {
	if (vdl:getFieldValue($cond$)) {
		$sub_comp(declarations=declarations, statements=statements, cleanups=cleanups)$
		next($var$ + 1)
	}
}
>>

foreach(var, in, indexVar, indexVarType, declarations, statements, line, refs, selfClose, cleanups, trace) ::= <<
swift:tParallelFor(\$, _traceline="$line$"$if(indexVar)$, _kvar="$indexVar$"$endif$, _vvar="$var$"$if(selfClose)$, selfClose="true"$endif$$if(refs)$, refs="$refs;separator=" "$"$endif$,
$! The iterator !$
	getArrayIterator($in$)) {
	(\$\$, $var$) := each(\$)
$if(indexVar)$
	$indexVar$ := swift:new($indexVarType$, \$\$)		
$endif$
	unitStart("FOREACH_IT", line="$line$") 
	$declarations;separator="\n"$
$if(statements)$
	$parallel(statements=statements)$
	$cleanups:swift_cleandataset();separator="\n"$
$endif$

	unitEnd("FOREACH_IT", line="$line$")
}
>>

// need to log inputs and outputs at the calling stage here because
// they are not
// $outputs:vdl_log_output();separator="\n"$

callInternal(func, outputs, inputs, line, serialize) ::= <<
sequential(
	unitStart("INTERNALPROC", name="$func$", outputs="$outputs:list();separator=","$")
	$func$(
		$if(!serialize)$parallel($endif$
    	$outputs:callInternal_log_output();separator="\n"$
    	$inputs:callInternal_log_input();separator="\n"$
  		$if(!serialize)$)$endif$
	)
	unitEnd("INTERNALPROC", name="$func$")
)
>>

callInternal_log_input() ::= <<
sequential(
	parameterLog("input", "TODO_name_or_pos", vdl:getDatasetProvenanceID($it$))
	$it$
)
>>

callInternal_log_output() ::= <<
sequential(
	parameterLog("output", "TODO_name_or_pos", vdl:getDatasetProvenanceID($it$))
	$it$
)
>>

callUserDefined(func, outputs, inputs, line, serialize, partialClose) ::= <<
$func$(
	$if(!serialize)$parallel($endif$
	$outputs;separator=", "$
	$inputs;separator=", "$
	$if(!serialize)$)$endif$
)
$if(partialClose)$
$partialClose$
$endif$
>>

call_arg(bind, expr, datatype) ::= <<
$if(bind)$
$bind$ = $expr$
$else$
$expr$
$endif$
>>

globalConstant(name, expr, datatype) ::= <<
$name$ := $expr$
>>

variable(name, type, expr, mapping, nil, file, waitCount, input, datatype, isGlobal, line) ::= <<
$name$ := 
	$if(mapping)$
	swift:new("$type$", dbgname="$name$"$if(waitCount)$, waitCount=$waitCount$$endif$$if(line)$, _defline="$line$"$endif$$if(input)$, input=true$endif$
		$swift_mapping(mapping=mapping, file=file)$
	)
	$else$
		$if(file)$
			swift:new("$type$", dbgname="$name$"$if(waitCount)$, waitCount=$waitCount$$endif$$if(line)$, _defline="$line$"$endif$$if(input)$, input=true$endif$
				$swift_mapping(mapping=mapping, file=file)$
			)
		$else$
			swift:new("$type$", dbgname="$name$"$if(waitCount)$, waitCount=$waitCount$$endif$$if(line)$, _defline="$line$"$endif$$if(input)$, input=true$endif$)
		$endif$
	$endif$
$variable_log()$
>>

variable_log() ::= <<
	parameterLog("intermediate", "$name$", swift:getDatasetProvenanceID($name$))
>>

swift_mapping(mapping, file) ::= <<
$if(file)$
swift:mapping("single_file_mapper", swift:parameter("file", "$file.name$") $if(file.params)$$file.params;separator="\n"$$endif$)
$else$
swift:mapping("$mapping.descriptor$", $mapping.params;separator="\n"$)
$endif$
>>

swift_parameter(name,expr) ::= <<
swift:parameter("$name$", $expr$)
>>

assign(var, value, line, partialClose) ::= <<
swift:setFieldValue($if(line)$_traceline="$line$"$endif$
	$var$
	$value$
)
$if(partialClose)$
$partialClose$
$endif$
>>

append(array, value, partialClose) ::= <<
swift:appendArray(
	$array$
	$value$
)
$if(partialClose)$
$partialClose$
$endif$
>>

callexpr(call, datatype, prefix) ::= <<
sequential(
	tmp := swift:new("$datatype$", dbgname="swift#callintermediate",
		swift:mapping("concurrent_mapper",
			swift:parameter("prefix", "_callintermediate-$prefix$")
		)
	)
	$call$
	tmp
)
>>

array(elements, datatype) ::= <<
swift:createarray(
	list(
		$elements;separator="\n"$
	)
)
>>

range(from, to, step, datatype) ::= <<
sequential(
	tmp := swift:range($from$, $to$$if(step)$, step = $step$$endif$)
	tmp
	$range_log()$
) 
>>

range_log() ::= <<
>>

if(condition,vthen,velse,line,trace) ::= <<
if (swift:getFieldValue($condition$)) {
	unitStart("CONDITION_BLOCK")
	$vthen$
}
$if(velse)$
else {
	unitStart("CONDITION_BLOCK")
	$velse$
}
$endif$
>>

sub_comp(declarations, statements, cleanups, preClose) ::= <<
$if(preClose)$
$preClose;separator="\n"$
$endif$
$declarations;separator="\n"$
$if(statements)$
$parallel(statements=statements)$
$cleanups:swift_cleandataset();separator="\n"$
$endif$
>>

switch(condition,cases,sdefault) ::= <<
sequential(
	swc := $condition$
$cases:{case |
	if (swift:getFieldValue(swiftop:eq(swc, $case.value$))) {
		$sub_comp(declarations=case.declarations, statements=case.statements)$
	}
	else 
}$
$if(sdefault)$
    {
      $sdefault$
    }
$endif$
)
>>

// TODO can optimise this like we do with parallel statements so that
// the wrapping layer disappers in the (perhaps common?) case of a
// single layer.
sequential(statements) ::= <<
$if(rest(statements))$
sequential(
   	$statements;separator="\n"$
)
$else$
$statements$
$endif$
>>


partialclose(var, count) ::= <<
partialCloseDataset($var$$if(count)$, count=$count$$endif$)
>>

setWaitCount(name, waitCount) ::= <<
setWaitCount($name$$if(waitCount)$, count=$waitCount$$endif$)
>>

unitStart(type, outputs) ::= <<
  unitStart("$type$", outputs="$outputs$")
>>

unitEnd(type) ::= <<
  unitEnd("$type$")
>>

operator ::= [
  "+":"swiftop:sum",
  "-":"swiftop:subtraction",
  "*":"swiftop:product",
  "/":"swiftop:fquotient",
  "%/":"swiftop:iquotient",
  "%%":"swiftop:remainder",
  "&lt;=":"swiftop:le",
  "&gt;=":"swiftop:ge",
  "&gt;":"swiftop:gt",
  "&lt;":"swiftop:lt",
  "<=":"swiftop:le",
  ">=":"swiftop:ge",
  ">":"swiftop:gt",
  "<":"swiftop:lt",
  "==":"swiftop:eq",
  "!=":"swiftop:ne",
  "&amp;&amp;":"swiftop:and",
  "||":"swiftop:or"
]

unaryNegation(exp, datatype) ::= <<
swiftop:product(swift:new("int", value = -1), $exp$)
>>

binaryop(op,left,right,datatype) ::= <<
$operator.(op)$($left$, $right$)
>>

not(exp, datatype) ::= <<
swiftop:not($exp$)
>>

id(var, datatype) ::= <<
$var$
>>

extractarrayelement(parent, arraychild, datatype) ::= <<
swift:getfieldsubscript($parent$, $arraychild$)
>>

extractstructelement(parent, memberchild, datatype) ::= <<
getfield($parent$, $memberchild$)
>>

slicearray(parent, memberchild, datatype) ::= <<
sequential(
	slice := swift:sliceArray($parent$, $memberchild$, $datatype$)
 	logSliceArray($memberchild$, $parent$)
 	slice
)
>>

logSliceArray(memberchild, array) ::= <<
>>


iConst(value, datatype) ::= <<
swift:new("int", value=$value$)
>>

fConst(value, datatype) ::= <<
swift:new("float", value=$value$)
>>

bConst(value, datatype) ::= <<
swift:new("boolean", value=$value$)
>>

// Why is there a value attribute?
sConst(value,innervalue,datatype) ::= <<
swift:new("string", value="$innervalue$")
>>

