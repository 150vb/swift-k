group Karajan;

program(types,procedures,declarations,statements,constants,buildversion) ::= <<
<project><!-- CACHE ID $buildversion$ -->
  <import file="sys.xml"/>
  <import file="scheduler.xml"/>
  <import file="rlog.xml"/>
  <import file="vdl.k"/>
  $if(types)$
  <types>
     <xs:schema targetNamespace="http://ci.uchicago.edu/swift/2009/02/swiftscript" xmlns="http://ci.uchicago.edu/swift/2009/02/swiftscript" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xs="http://www.w3.org/2001/XMLSchema">
     $types;separator="\n"$  
     </xs:schema>	 
  </types>
  $endif$
  $constants;separator="\n"$
  $procedures;separator="\n"$
  $declarations;separator="\n"$
  $if(statements)$
  <restartLog>
  	<vdl:mains>
<!-- TODO can move into vdl:mains so karajan files are smaller -->
		<vdl:startprogressticker />
		<vdl:mainp>
		    $parallel(statements=statements)$
		</vdl:mainp>
		<vdl:stopprogressticker />
	</vdl:mains>
  </restartLog>  
  $endif$
</project>
>>

typeDef(name,type,members,sourcelocation) ::= <<
 $if(type)$
   	 <xs:element name="$name$" type="$type$"/>      
 $else$
   $if(!members)$
 	   <xs:simpleType name="$name$">
 	   <xs:restriction base="string"/>
 	   </xs:simpleType>
   $else$
 	   <xs:complexType name="$name$">
 	   <xs:sequence>
 	     $members;separator="\n"$
 	   </xs:sequence>
 	   </xs:complexType>
   $endif$
 $endif$
>>
 	
memberdefinition(type,name,sourcelocation) ::= <<
   <xs:element name="$name$" type="$type$"/>
>>

procedure(name,outputs,inputs,arguments,optargs,binding,declarations,statements,config) ::= <<
<element name="$name$"$if(arguments)$ arguments="$proc_args(args=arguments)$"$endif$$if(optargs)$ optargs="$proc_args(args=optargs)$"$endif$>
  $optargs:default_arg();separator="\n"$
  $outputs:typecheck();separator="\n"$
  $inputs:typecheck();separator="\n"$
$if(binding)$
  $vdl_execute(outputs=outputs,inputs=inputs,application=binding.application, name=name)$
$else$
  $compound(outputs=outputs,inputs=inputs,declarations=declarations,statements=statements,name=name)$
$endif$
</element>

>>

compound(outputs,inputs,declarations,statements,config,name) ::= <<
<log level="info"><string>STARTCOMPOUND thread={#thread} name=$name$</string></log>
$declarations;separator="\n"$
$if(statements)$
$parallel(statements=statements)$
$endif$
$outputs:vdl_closedataset();separator="\n"$
<log level="info"><string>ENDCOMPOUND thread={#thread}</string></log>
>>

proc_args(args) ::= <<
$args:arg_name();separator=","$
>>

arg_name() ::= <<
$it.name$
>>

default_arg() ::= <<
$if(it.default)$
<default name="$it.name$">
$it.default$
</default>
$endif$
>>

typecheck() ::= <<
<vdl:typecheck argname="$it.name$" var="{$it.name$}" type="$it.type.name$"$if(it.isArray)$ isArray="true"$endif$/>
>>

vdl_execute(outputs,inputs,application,name) ::= <<
<log>
  <string>info</string>
  <string>PROCEDURE thread={#thread} name=$name$</string>
</log>
$inputs:vdl_log_input();separator="\n"$
$outputs:vdl_log_output();separator="\n"$
<vdl:execute>
  <vdl:tr>$application.exec$</vdl:tr>
  $inputs:vdl_stagein();separator="\n"$
  $outputs:vdl_stageout();separator="\n"$
  $vdl_arguments(arguments=application.arguments, stdin=application.stdin,stdout=application.stdout,stderr=application.stderr)$
</vdl:execute>
$outputs:vdl_closedataset();separator="\n"$
>>

vdl_log_input() ::= <<
<parameterlog>
<string>input</string>
<string>$it.name$</string>
<vdl:getdatasetprovenanceid var="{$it.name$}" />
</parameterlog>
>>

vdl_log_output() ::= <<
<parameterlog>
<string>output</string>
<string>$it.name$</string>
<vdl:getdatasetprovenanceid var="{$it.name$}" />
</parameterlog>
>>

vdl_stagein() ::= <<
<vdl:stagein var="{$it.name$}"/>
>>

vdl_stageout(outputs) ::= <<
<vdl:stageout var="{$it.name$}"/>
>>

vdl_closedataset() ::= <<
<vdl:closedataset var="{$it.name$}"/>
>>

vdl_arguments(arguments,stdin,stdout,stderr) ::= <<
<vdl:arguments>
  $arguments;separator="\n"$
</vdl:arguments>
$if (stdin)$
<vdl:stdin>
  $stdin$
</vdl:stdin>
$endif$
$if (stdout)$
<vdl:stdout>
  $stdout$
</vdl:stdout>
$endif$
$if (stderr)$
<vdl:stderr>
  $stderr$
</vdl:stderr>
$endif$
>>

parallel(statements) ::= <<
$if(rest(statements))$
<parallel>
  $statements;separator="\n"$
</parallel>
$else$
$statements$
$endif$
>>

// the 'function' template outputs a karajan code fragment
// that calls a function in the 'swiftscript' namespace.

function(name, args, datatype) ::= <<
<swiftscript:$name$>
  $if(args)$ $args$ $endif$
</swiftscript:$name$>
>>

iterate(declarations,statements,cond,var) ::= <<

<vdl:infinitecountingwhile>
  <set names="\$\$">
    <each items="{\$}"/>
  </set>
  <set name="$var$">
    <vdl:new type="int" value="{\$\$}" />
  </set>
  $sub_comp(declarations=declarations, statements=statements)$
  <sys:if>
    <vdl:getfieldvalue>$cond$</vdl:getfieldvalue>
    <sys:break/>
  </sys:if>
  
</vdl:infinitecountingwhile>
>>

foreach(var,in,indexVar,declarations,statements) ::= <<
<vdl:tparallelFor name="\$">
  <getarrayiterator>$in$</getarrayiterator>
  <set names="\$\$, $var$">
    <each items="{\$}"/>
  </set>
$if(indexVar)$
    <set name="$indexVar$">
      <vdl:new type="int" value="{\$\$}"/>
    </set>
$endif$
    $declarations;separator="\n"$
    $if(statements)$
      $parallel(statements=statements)$
    $endif$
</vdl:tparallelFor>
>>

call(func, outputs, inputs) ::= <<
<$func$>
  <parallel>
    $outputs;separator="\n"$
    $inputs;separator="\n"$
  </parallel>
</$func$>
>>

call_arg(bind, expr, datatype) ::= <<
$if(bind)$
<argument name="$bind$">
  $expr$
</argument>
$else$
$expr$
$endif$
>>

globalConstant(name, expr, datatype) ::= <<
<global name="$name$">
  $expr$
</global>
>>

variable(name,type,isArray,expr,mapping,nil,file,waitfor,datatype) ::= <<
<set name="$name$">
  $if(mapping)$
  <vdl:new type="$type$" dbgname="$name$"$if(isArray)$ isArray="true"$endif$$if(waitfor)$ waitfor="$waitfor;separator=" "$"$endif$>
    $vdl_mapping(mapping=mapping,file=file,waitfor=waitfor)$
  </vdl:new>
  $else$
    $if(file)$
      <vdl:new type="$type$" dbgname="$name$"$if(isArray)$ isArray="true"$endif$$if(waitfor)$ waitfor="$waitfor;separator=" "$"$endif$>
        $vdl_mapping(mapping=mapping,file=file,waitfor=waitfor)$
      </vdl:new>
    $else$
      $expr$
    $endif$
  $endif$
</set>
>>

vdl_mapping(mapping,file,waitfor) ::= <<
$if(file)$
<vdl:mapping descriptor="single_file_mapper">
  <vdl:parameter name="file" value="$file.name$"/>
  $if(file.params)$$file.params;separator="\n"$$endif$
  $if(!waitfor)$
  <vdl:parameter name="input" value="true" />
  $endif$
</vdl:mapping>
$else$
<vdl:mapping descriptor="$mapping.descriptor$">
  $mapping.params;separator="\n"$
  $if(!waitfor)$
  <vdl:parameter name="input" value="true" />
  $endif$
</vdl:mapping>
$endif$
>>

vdl_parameter(name,expr) ::= <<
<vdl:parameter name="$name$">$expr$</vdl:parameter>
>>

assign(var,value) ::= <<
   <vdl:setfieldvalue>
     <argument name="var">
       $var$
     </argument>
     <argument name="value">
       $value$
     </argument>
   </vdl:setfieldvalue>
>>

callexpr(call, datatype, callID, prefix) ::= <<
<sequential>
	<set name="swift#callintermediate">
		<vdl:new type="$datatype$" dbgname="swift#callintermediate">
			<vdl:mapping descriptor="concurrent_mapper">
				<vdl:parameter name="prefix">_callintermediate-$prefix$</vdl:parameter>
			</vdl:mapping>
		</vdl:new>
	</set>
	$call$
	<variable>swift#callintermediate</variable>
</sequential>
>>

array(elements, datatype) ::= <<
<vdl:createarray>
  <list>
    $elements;separator="\n"$
  </list>
</vdl:createarray>
>>

range(from,to,step,datatype) ::= <<
<vdl:range>
  <argument name="from">
    $from$
  </argument>
  <argument name="to">
    $to$
  </argument>
  $if(step)$
  <argument name="step">
    $step$
  </argument>
  $endif$
</vdl:range>
>>

if(condition,vthen,velse) ::= <<
<if>
  <vdl:getfieldvalue>$condition$</vdl:getfieldvalue>
  <then>
    $vthen$
  </then>
  $if(velse)$
  <else>
    $velse$
  </else>
  $endif$
</if>
>>

sub_comp(declarations,statements) ::= <<
$declarations;separator="\n"$
$if(statements)$
$parallel(statements=statements)$
$endif$
>>

switch(condition,cases,sdefault) ::= <<
<sequential>
  <set name="\$_sw">
    $condition$
  </set>
  <if>
$cases:{case |
    <vdl:getfieldvalue>
    <vdlop:eq>
       <variable>\$_sw</variable>
       $case.value$
    </vdlop:eq>
    </vdl:getfieldvalue>
    <then>
      $sub_comp(declarations=case.declarations, statements=case.statements)$
    </then>
}$
$if(sdefault)$
    <else>
      $sdefault$
    </else>

$endif$
  </if>
</sequential>
>>

// TODO can optimise this like we do with parallel statements so that
// the wrapping layer disappers in the (perhaps common?) case of a
// single layer.
sequential(statements) ::= <<
  <sequential>
    $statements;separator="\n"$
  </sequential>
>>


partialclose(var, closeID) ::= <<
  <partialCloseDataset var="{$var$}" closeID="$closeID$" />
>>



operator ::= [
  "+":"vdlop:sum",
  "-":"vdlop:subtraction",
  "*":"vdlop:product",
  "/":"vdlop:fquotient",
  "%/":"vdlop:iquotient",
  "%%":"vdlop:remainder",
  "&lt;=":"vdlop:le",
  "&gt;=":"vdlop:ge",
  "&gt;":"vdlop:gt",
  "&lt;":"vdlop:lt",
  "<=":"vdlop:le",
  ">=":"vdlop:ge",
  ">":"vdlop:gt",
  "<":"vdlop:lt",
  "==":"vdlop:eq",
  "&amp;&amp;":"vdlop:and",
  "||":"vdlop:or"
]

unaryNegation(exp, datatype) ::= <<
<vdlop:product>
  <vdl:new type="int" value="-1" />
  $exp$
</vdlop:product>
>>

binaryop(op,left,right,datatype) ::= <<
<$operator.(op)$>
  $left$
  $right$
</$operator.(op)$>
>>

not(exp, datatype) ::= <<
<vdlop:not>
  $exp$
</vdlop:not>
>>

id(var, datatype) ::= <<
<variable>$var$</variable>
>>

extractarrayelement(parent, arraychild, datatype) ::= <<
<vdl:getfieldsubscript>
  <argument name="var">$parent$</argument>
  <argument name="subscript">$arraychild$</argument>
</vdl:getfieldsubscript>
>>

extractstructelement(parent, memberchild, datatype) ::= <<
<getfield>
  <argument name="var">$parent$</argument>
  <argument name="path">$memberchild$</argument>
</getfield>
>>

slicearray(parent, memberchild, datatype) ::= <<
<vdl:slicearray>
  <argument name="var">$parent$</argument>
  <argument name="path">$memberchild$</argument>
  <argument name="type">$datatype$</argument>
</vdl:slicearray>
>>


iConst(value, datatype) ::= <<
<vdl:new type="int" value="$value$" />
>>

fConst(value, datatype) ::= <<
<vdl:new type="float" value="$value$" />
>>

bConst(value, datatype) ::= <<
<vdl:new type="boolean" value="$value$" />
>>

sConst(value,innervalue,datatype) ::= <<
<vdl:new type="string" value="$innervalue$" />
>>

