
... in random order

*** Checkpointing may fail if objects that cannot be serialized/deserialized are
put on the stack. This should only happen with bindings to Java libraries that
use such objects.

*** Checkpointing needs more testing

*** Errors may sometimes be generated by elements that do not exist in .k sources,
but are created during the translation to XML. They will show no line number. 
Checkpoints may add incorrect line numbers to these.


*** [Fixed: Since version 0.32, parallel and parallelFor will
return arguments in lexical order, so the issue is not present any more. Nonetheless,
their unbuffered versions (uParallel, uParallelFor), will still exhibit the same
problem.]

The mapping of vargs to named arguments may be weird at times. Suppose there
is an element:

element(foo, [one, two, three, ...])

and it's invoked like this:

foo(two = 2, 3, 4, 5, 6) then the following will be the mapping:
one = 3
two = 2
three = 4
... = [5, 6]

This is because named args are processed first. Then vargs are mapped to 
mandatory named args in the order they are declared, but not for the ones that
already have a value. This may lead to ambiguities when evaluating them in parallel,
even if names are used for all named ones:

foo(parallel(one = 1, two = 2, three = 3, 4, 5, 6))

It this case if 4, 5, or 6 are executed before one = 1, the one = 1 will try to 
assign to an already assigned named argument, which will fail. The workaround is to
always evaluate the named arguments before the vargs (the named ones can still be 
evaluated in parallel, and so can be the vargs):

foo(
  parallel(one = 1, two = 2, three = 3)
  parallel(4, 5, 6)
)

or

foo(1, 2, 3, parallel(4, 5, 6))

*** Future iterators don't have an upper bound on the number of values. That means that
if, for example, used in a producer/consumer model, and the producer produces values 
faster than the consumer consumes them, memory is going to eventually be filled. 

*** There is some inconsistency in the way element names are resolved to implementations.
Right now, the scope of definitions of an element is the container which defined them. 
However, once bound, the binding stays. This is true for Java-defined elements, and not
for user defined elements. One of the reasons is performance. It would be really slow
to remap the definitions every single time an event is sent. But this also makes me think
that maybe the binding should be static to begin with (which on the other hand would mean
that it's impossible to re-define already defined things).

*** [Fixed: imports are not inherited any more]
Namespaces don't work as I would want them to. Normally, a library that works
correctly when included from one file should not fail when included from another one.
This happens in the following way:

Suppose there is a library, foo.k:

include("sys.k")

set(a, list(1, 2, 3))

Since list here can only be sys:list, that's what it will resolve to. However, if included
from a file that defines another list, in a different namespace, then foo.k will not be loaded, 
since 'list' will be ambiguous.

*** The viewer has to be updated with new semantics

*** The debugger is experimental, bare, and buggy.
